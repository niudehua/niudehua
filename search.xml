<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Elasticsearch 教程（一）</title>
      <link href="2021/03/28/elasticsearch-jiao-cheng-yi/"/>
      <url>2021/03/28/elasticsearch-jiao-cheng-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前序"><a href="#一-前序" class="headerlink" title="一 前序"></a>一 前序</h2><blockquote><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要 使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p><p>Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的 RESTful API 来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><p>Elasticsearch的中文网址：<a href="https://www.elastic.co/cn/products/elasticsearch">https://www.elastic.co/cn/products/elasticsearch</a></p></blockquote><h3 id="1-1-正向索引和倒排索引"><a href="#1-1-正向索引和倒排索引" class="headerlink" title="1.1 正向索引和倒排索引"></a>1.1 正向索引和倒排索引</h3><blockquote><p>正向索引与倒排索引，这是在搜索领域中非常重要的两个名词，正向索引通常用于数据库中，在搜索引擎领域使用的最多的就是倒排索引，我们根据如下两个网页来对这两个概念进行阐述：</p></blockquote><p><strong>html1</strong> </p><pre class="line-numbers language-none"><code class="language-none">我爱我的祖国，我爱编程<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>html2</strong> </p><pre class="line-numbers language-none"><code class="language-none">我爱编程，我是个快乐的小码农<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="1-1-1-正向索引"><a href="#1-1-1-正向索引" class="headerlink" title="1.1.1 正向索引"></a>1.1.1 正向索引</h4><blockquote><p>假设我们使用mysql的全文检索，会对如上两句话分别进行分词处理，那么预计得到的结果如下：</p></blockquote><pre class="line-numbers language-none"><code class="language-none">我 爱 爱我 祖国 我的祖国 编程 爱编程 我爱编程 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">我 我爱 爱 编程 爱编程 我爱编程 快乐 码农 小码农<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>假设我们现在使用正向索引搜索 编程 这个词，那么会到第一句话中去查找是否包含有 编程 这个关键词，如果有则加入到结果集中；第二句话也是如此。假设现在有成千上百个网页，每个网页非常非常的分词，那么搜索的效率将会非常非常低些。</p></blockquote><h4 id="1-1-2-倒排索引"><a href="#1-1-2-倒排索引" class="headerlink" title="1.1.2 倒排索引"></a>1.1.2 倒排索引</h4><blockquote><p>倒排索引是按照分词与文档进行映射，我们来看看如果按照倒排索引的效果：</p></blockquote><table><thead><tr><th>关键词</th><th>文档名</th></tr></thead><tbody><tr><td>我</td><td>html1,html2</td></tr><tr><td>爱</td><td>html1,html2</td></tr><tr><td>爱我</td><td>html1</td></tr><tr><td>我爱</td><td>html2</td></tr><tr><td>祖国</td><td>html1</td></tr><tr><td>我的祖国</td><td>html1</td></tr><tr><td>编程</td><td>html1,html2</td></tr><tr><td>我爱编程</td><td>html1,html2</td></tr><tr><td>爱编程</td><td>html1,html2</td></tr><tr><td>快乐</td><td>html2</td></tr><tr><td>码农</td><td>html2</td></tr><tr><td>小码农</td><td>html2</td></tr></tbody></table><blockquote><p>如果采用倒排索引的方式搜索 编程 这个词，那么会直接找到关键词中查找到 编程 ，然后查找到对应的文档，这就是所谓的倒排索引。</p></blockquote><h2 id="二-软件简介以及启动"><a href="#二-软件简介以及启动" class="headerlink" title="二 软件简介以及启动"></a>二 软件简介以及启动</h2><h3 id="2-1-相关软件下载地址"><a href="#2-1-相关软件下载地址" class="headerlink" title="2.1 相关软件下载地址"></a>2.1 相关软件下载地址</h3><table><thead><tr><th>软件名</th><th>下载地址</th></tr></thead><tbody><tr><td>Elasticsearch</td><td><a href="https://www.elastic.co/cn/start">https://www.elastic.co/cn/start</a></td></tr><tr><td>Kibana</td><td><a href="https://www.elastic.co/cn/start">https://www.elastic.co/cn/start</a></td></tr><tr><td>Logstash</td><td><a href="https://www.elastic.co/cn/downloads/logstash">https://www.elastic.co/cn/downloads/logstash</a></td></tr></tbody></table><h3 id="2-2-Elasticsearch安装"><a href="#2-2-Elasticsearch安装" class="headerlink" title="2.2 Elasticsearch安装"></a>2.2 Elasticsearch安装</h3><blockquote><p>进入到 elasticsearch 解压目录下的 bin 目录下，双击 elasticsearch.bat 即可启动。在浏览器地址栏输入: <a href="http://localhost:9200/">http://localhost:9200/</a> ，如果出现如下页面表示 elasticsearch 启动成功</p></blockquote><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210326232004941.png" alt="image-20210326232004941"></p><h3 id="2-3-Kibana"><a href="#2-3-Kibana" class="headerlink" title="2.3 Kibana"></a>2.3 Kibana</h3><h4 id="2-3-1-Kibana简介"><a href="#2-3-1-Kibana简介" class="headerlink" title="2.3.1 Kibana简介"></a>2.3.1 Kibana简介</h4><blockquote><p>Kibana是世界上最受欢迎的开源日志分析平台ELK Stack中的“K” ，它为用户提供了一个工具，用于在存储于Elasticsearch集群中的日志数据进行检索，可视化和构建仪表板。</p><p>Kibana的核心功能是数据查询和分析。使用各种方法，用户可以搜索Elasticsearch中索引的数据，以查找其数据中的特定事件或字符串，以进行根本原因分析和诊断。基于这些查询，用户可以使用Kibana的可视化功能，允许用户使用图表，表格，地理图和其他类型的可视化以各种不同的方式可视化数据。</p></blockquote><h4 id="2-3-2-Kibana的启动"><a href="#2-3-2-Kibana的启动" class="headerlink" title="2.3.2 Kibana的启动"></a>2.3.2 Kibana的启动</h4><blockquote><p>进入到 kibana 解压目录下的 bin 目录下，双击 kibana.bat 即可启动 kibana.在浏览器地址栏输入：<a href="http://localhost:5601，出现如下页面代表">http://localhost:5601，出现如下页面代表</a> kibana 启动成功。</p></blockquote><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210326231828734.png" alt="image-20210326231828734"></p><h3 id="2-4-Logstash"><a href="#2-4-Logstash" class="headerlink" title="2.4 Logstash"></a>2.4 Logstash</h3><h4 id="2-4-1-logstash简介"><a href="#2-4-1-logstash简介" class="headerlink" title="2.4.1 logstash简介"></a>2.4.1 logstash简介</h4><blockquote><p>Logstash是一个开源的服务器端数据处理管道，可以同时从多个数据源获取数据，并对其进行转换，然后将其发送到你最喜欢的“存储”。创建于2009年，于2013年被elasticsearch收购。</p></blockquote><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/%E6%88%AA%E5%B1%8F2021-03-26%2023.22.42-6772201.png" alt="截屏2021-03-26 23.22.42"></p><h4 id="2-4-2-logstash导入数据"><a href="#2-4-2-logstash导入数据" class="headerlink" title="2.4.2 logstash导入数据"></a>2.4.2 logstash导入数据</h4><blockquote><p>虽然 kibana 提供了一些数据集供我们使用，为了加深对 logstash 的理解，我们 movielens的电影数据集。</p><p>movielens 数据集的下载地址为：<a href="http://files.grouplens.org/datasets/movielens%EF%BC%8C%E8%BF%9B%E5%85%A5%E8%AF%A5%E7%BD%91%E9%A1%B5%E5%8F%AA%E7%94%A8%E4%B8%8B%E8%BD%BD">http://files.grouplens.org/datasets/movielens，进入该网页只用下载</a> ml-latest.zip 数据即可，如下图所示：</p></blockquote><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210326232603831.png" alt="image-20210326232603831"></p><blockquote><p>将 ml-latest.zip 加压文件中的 movies.csv 文件拷贝到 logstash 的家目录下；再将 logstash 的 config 目录下新建名为 logstash.conf 的文件，文件内容如下:</p></blockquote><pre class="line-numbers language-none"><code class="language-none">input &#123;  file &#123;    path &#x3D;&gt; &quot;&#x2F;Users&#x2F;deng&#x2F;Documents&#x2F;software&#x2F;logstash-7.12.0&#x2F;movies.csv&quot;    start_position &#x3D;&gt; &quot;beginning&quot;    sincedb_path &#x3D;&gt; &quot;&#x2F;Users&#x2F;deng&#x2F;Documents&#x2F;software&#x2F;logstash-7.12.0&#x2F;db_path.log&quot;  &#125;&#125;filter &#123;  csv &#123;    separator &#x3D;&gt; &quot;,&quot;    columns &#x3D;&gt; [&quot;id&quot;,&quot;content&quot;,&quot;genre&quot;]  &#125;  mutate &#123;    split &#x3D;&gt; &#123; &quot;genre&quot; &#x3D;&gt; &quot;|&quot; &#125;    remove_field &#x3D;&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;]  &#125;  mutate &#123;    split &#x3D;&gt; [&quot;content&quot;, &quot;(&quot;]    add_field &#x3D;&gt; &#123; &quot;title&quot; &#x3D;&gt; &quot;%&#123;[content][0]&#125;&quot;&#125;    add_field &#x3D;&gt; &#123; &quot;year&quot; &#x3D;&gt; &quot;%&#123;[content][1]&#125;&quot;&#125;  &#125;  mutate &#123;    convert &#x3D;&gt; &#123;      &quot;year&quot; &#x3D;&gt; &quot;integer&quot;    &#125;    strip &#x3D;&gt; [&quot;title&quot;]    remove_field &#x3D;&gt; [&quot;path&quot;, &quot;host&quot;,&quot;@timestamp&quot;,&quot;message&quot;,&quot;content&quot;]  &#125;&#125;output &#123;   elasticsearch &#123;     hosts &#x3D;&gt; &quot;http:&#x2F;&#x2F;localhost:9200&quot;     index &#x3D;&gt; &quot;movies&quot;     document_id &#x3D;&gt; &quot;%&#123;id&#125;&quot;   &#125;  stdout &#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>打开命令行，进入到 logstash 的 bin 目录下，执行如下命令导入 movielens 的数据集。</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">logstash -f ..&#x2F;config&#x2F;logstash.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-4-3-验证"><a href="#2-4-3-验证" class="headerlink" title="2.4.3 验证"></a>2.4.3 验证</h4><blockquote><p>进入到 kibana 的命令行页面，执行 GET _cat/indices 验证数据是否成功导入</p></blockquote><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210326233836276.png" alt="image-20210326233836276"></p><h2 id="三-Elasticsearch的基本概念"><a href="#三-Elasticsearch的基本概念" class="headerlink" title="三 Elasticsearch的基本概念"></a>三 Elasticsearch的基本概念</h2><h3 id="3-1-索引"><a href="#3-1-索引" class="headerlink" title="3.1 索引"></a>3.1 索引</h3><blockquote><p>Elasticsearch中的索引有多层的意思：</p><p>a. 某一类文档的集合就构成了一个索引，类比到数据库就是一个数据库(或者数据库表); </p><p>b.它还描述了一个动作，就是将某个文档保存在elasticsearch的过程也叫索引; </p><p>c. 倒排索引。</p></blockquote><h3 id="3-2-文档"><a href="#3-2-文档" class="headerlink" title="3.2 文档"></a>3.2 文档</h3><blockquote><p>具体的一条数据，类比到数据库就是一条记录。</p></blockquote><h3 id="3-3-ES文档的结构"><a href="#3-3-ES文档的结构" class="headerlink" title="3.3 ES文档的结构"></a>3.3 ES文档的结构</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;_index&quot;: &quot;movies&quot;,    # _index:索引    &quot;_type&quot;: &quot;_doc&quot;,    # _type:类型    &quot;_id&quot;: &quot;83556&quot;,    # _id:id    &quot;_score&quot;: 1,    &quot;_source&quot;: &#123;    # _source:存放具体的数据        &quot;year&quot;: 2008,        &quot;genre&quot;: [            &quot;Drama&quot;        ],        &quot;title&quot;: &quot;Stella&quot;,        &quot;id&quot;: &quot;83556&quot;,        &quot;@version&quot;: &quot;1&quot;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-mapping"><a href="#3-4-mapping" class="headerlink" title="3.4 mapping"></a>3.4 mapping</h3><blockquote><p>mapping 是ES每一个文档的约束信息，例如属性的类型，是否能被索引等。</p></blockquote><h3 id="3-5-DSL"><a href="#3-5-DSL" class="headerlink" title="3.5 DSL"></a>3.5 DSL</h3><blockquote><p>DSL 是 ES 的查询语言。</p></blockquote><h3 id="3-6-类比"><a href="#3-6-类比" class="headerlink" title="3.6 类比"></a>3.6 类比</h3><blockquote><p>我们通过大家比较熟悉的 DBMS 与 ES 的基本概念进行类比，加深大家的理解。</p></blockquote><table><thead><tr><th>DBMS</th><th>Elasticsearch</th></tr></thead><tbody><tr><td>database</td><td>Index</td></tr><tr><td>table</td><td>type(在7.0之后type为固定值_doc)</td></tr><tr><td>Row</td><td>Document</td></tr><tr><td>Column</td><td>Field</td></tr><tr><td>Schema</td><td>Mapping</td></tr><tr><td>SQL</td><td>DSL(Descriptor Structure Language)</td></tr></tbody></table><blockquote><p>在7.0之前，一个Index可以创建多个类型，从7.0开始，一个索引只能创建一个类型，也就是 _doc</p></blockquote><h2 id="四-RestAPI"><a href="#四-RestAPI" class="headerlink" title="四 RestAPI"></a>四 RestAPI</h2><h3 id="4-1-基本CRUD"><a href="#4-1-基本CRUD" class="headerlink" title="4.1 基本CRUD"></a>4.1 基本CRUD</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search # 查询movies的数据 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_count #查询movies的总数 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET _cat&#x2F;indices #查看所有的索引 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_doc&#x2F;24 #查询id为24的数据 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST users&#x2F;_doc&#x2F;1  #添加id为1的文档 ，如果没有指定id，ES会自动生成&#123;    &quot;firstname&quot;: &quot;will&quot;,    &quot;lastname&quot;: &quot;smith&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST users&#x2F;_create&#x2F;2#创建id为2的文档，如果索引中已存在相同id，会报错；&#123;    &quot;firstname&quot;: &quot;will&quot;,    &quot;lastname&quot;: &quot;smith&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST users&#x2F;_update&#x2F;2 #在id位2的文档中添加一个age属性，修改结构 &#123;    &quot;doc&quot;: &#123;        &quot;age&quot;: 30    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">DELETE users&#x2F;_doc&#x2F;2 #删除id为2的文档 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">DELETE users #删除 users 索引 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT users&#x2F;_doc&#x2F;1 #创建或者修改文档&#123;    &quot;firstname&quot;: &quot;Jack&quot;,    &quot;lastname&quot;: &quot;ma&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT users&#x2F;_create&#x2F;2  #创建id为2的文档，如果已存在就报错，如果不存在就创建 &#123;    &quot;firstname&quot;: &quot;will&quot;,    &quot;lastname&quot;: &quot;smith&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET mget   #批量查询多个指定的id的数据，也可以批量查询&#123;    &quot;docs&quot;: [        &#123;            &quot; index&quot;: &quot;users&quot;,            &quot; id&quot;: 1        &#125;,        &#123;            &quot; index&quot;: &quot;users&quot;,            &quot;_id&quot;: 2        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">POST users&#x2F; bulk  #批量插入数据 &#123;&quot;index&quot;: &#123;&quot; id&quot;: 3&#125;&#125; &#123;&quot;firstname&quot;: &quot;A&quot;, &quot;lastname&quot;: &quot;a&quot;&#125; &#123;&quot;index&quot;: &#123;&quot; id&quot;: 4&#125;&#125; &#123;&quot;firstname&quot;: &quot;B&quot;, &quot;lastname&quot;: &quot;b&quot;&#125; &#123;&quot;index&quot;: &#123;&quot; id&quot;: 5&#125;&#125;&#123;&quot;firstname&quot;: &quot;X&quot;, &quot;lastname&quot;: &quot;x&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 6&#125;&#125;&#123;&quot;firstname&quot;: &quot;Z&quot;, &quot;lastname&quot;: &quot;z&quot;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-URI查询"><a href="#4-2-URI查询" class="headerlink" title="4.2 URI查询"></a>4.2 URI查询</h3><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;2012 #查询所有的属性中只要包含2012的所有的数据，泛查询<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;2012&amp;df&#x3D;title #查询title中包含2012的所有的电影，df(default field)或者 GET movies&#x2F;_search?q&#x3D;title:2012 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:2012&amp;from&#x3D;10&amp;size&#x3D;8 #查询title中包含2012，从第10条开始，查询8条数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:Beautiful Mind #查询title中包含Beautiful或者Mind的所有的数据 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:(Beautiful Mind) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:(+Beautiful +Mind) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:&quot;Beautiful Mind&quot; #查询title中包含 &quot;Beautiful Mind&quot;这个短语的所有的数据 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:(Mind AND Beautiful) #查询title中既包含Mind又包含Beautiful的所有的数据，与顺序没有关系 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:(Beautiful NOT Mind) #查询title中包含Beautiful但是不包含mind的所有的数据 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:(Beautiful -Mind) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:Beautiful AND year:&gt;&#x3D;2012 #查询title中包含Beautiful且电影上映时间在2012年之后的所有的数据 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;year:&gt;&#x3D;2018 #查询2018年之后上映的电影 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;year:(&gt;&#x3D;2012 AND &lt;2018) #查询在2012到2017年上映的电影 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;year:&#123;2015 TO 2017] #查询2016年到2017年上映的电影，必须以 ] 结尾 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:Min?x # ？代表一个字母 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search?q&#x3D;title:Min* # 查询title中包含以 Min开头的字母的电影 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="五-Analysis"><a href="#五-Analysis" class="headerlink" title="五 Analysis"></a>五 Analysis</h2><blockquote><p>analysis(只是一个概念)，文本分析是将全文本转换为一系列单词的过程，也叫分词。analysis是通过analyzer(分词器)来实现的，可以使用Elasticsearch内置的分词器，也可以自己去定制一些分词器。 <strong>除了在数据写入的时候进行分词处理，那么在查询的时候也可以使用分析器对查询语句进行分词</strong>。 </p><p>anaylzer是由三部分组成，例如有:</p><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210329234134720-7032592.png" alt="image-20210329234134720"></p><ol><li><p>Character Filter: 将文本中html标签剔除掉。</p></li><li><p>Tokenizer: 按照规则进行分词，在英文中按照空格分词。</p></li><li><p>Token Filter: 去掉stop world(停顿词，a, an, the, is, are等)，然后转换小写</p></li></ol></blockquote><p><strong>Analyzer的处理过程</strong></p><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210327090828161.png" alt="image-20210327090828161"></p><h4 id="5-1-内置分词器"><a href="#5-1-内置分词器" class="headerlink" title="5.1 内置分词器"></a>5.1 内置分词器</h4><table><thead><tr><th>分词器名称</th><th>处理过程</th></tr></thead><tbody><tr><td>Standard Analyzer</td><td>默认的分词器，按词切分，小写处理</td></tr><tr><td>Simple Analyzer</td><td>按照非字母切分(符号被过滤)，小写处理</td></tr><tr><td>Stop Analyzer</td><td>小写处理，停用词过滤(the, a, this)</td></tr><tr><td>Whitespace Analyzer</td><td>按照空格切分，不转小写</td></tr><tr><td>Keyword Analyzer</td><td>不分词，直接将输入当做输出</td></tr><tr><td>Pattern Analyzer</td><td>正则表达式，默认是\W+(非字符串分隔)</td></tr></tbody></table><h4 id="5-2-内置分词器示例"><a href="#5-2-内置分词器示例" class="headerlink" title="5.2 内置分词器示例"></a>5.2 内置分词器示例</h4><h5 id="5-2-1-Standard-Analyzer"><a href="#5-2-1-Standard-Analyzer" class="headerlink" title="5.2.1 Standard Analyzer"></a>5.2.1 Standard Analyzer</h5><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET _analyze &#123;   &quot;analyzer&quot;: &quot;standard&quot;,   &quot;text&quot;: &quot;2 Running quick brown-foxes leap over lazy dog in the summer evening&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-2-2-Simple-Analyzer"><a href="#5-2-2-Simple-Analyzer" class="headerlink" title="5.2.2 Simple Analyzer"></a>5.2.2 Simple Analyzer</h5><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET _analyze &#123; &quot;analyzer&quot;: &quot;simple&quot;, &quot;text&quot;: &quot;2 Running quick brown-foxes leap over lazy dog in the summer evening&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-2-3-Stop-Analyzer"><a href="#5-2-3-Stop-Analyzer" class="headerlink" title="5.2.3 Stop Analyzer"></a>5.2.3 Stop Analyzer</h5><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET _analyze &#123; &quot;analyzer&quot;: &quot;stop&quot;, &quot;text&quot;: &quot;2 Running quick brown-foxes leap over lazy dog in the summer evening&quot; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-2-4-Whitespace-Analyzer"><a href="#5-2-4-Whitespace-Analyzer" class="headerlink" title="5.2.4 Whitespace Analyzer"></a>5.2.4 Whitespace Analyzer</h5><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET _analyze &#123; &quot;analyzer&quot;: &quot;whitespace&quot;, &quot;text&quot;: &quot;2 Running quick brown-foxes leap over lazy dog in the summer evening&quot; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-2-5-Keyword-Analyzer"><a href="#5-2-5-Keyword-Analyzer" class="headerlink" title="5.2.5 Keyword Analyzer"></a>5.2.5 Keyword Analyzer</h5><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET _analyze &#123; &quot;analyzer&quot;: &quot;keyword&quot;, &quot;text&quot;: &quot;2 Running quick brown-foxes leap over lazy dog in the summer evening&quot; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-2-6-Pattern-Analyzer"><a href="#5-2-6-Pattern-Analyzer" class="headerlink" title="5.2.6 Pattern Analyzer"></a>5.2.6 Pattern Analyzer</h5><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET _analyze &#123; &quot;analyzer&quot;: &quot;pattern&quot;, &quot;text&quot;: &quot;2 Running quick brown-foxes leap over lazy dog in the summer evening&quot; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch 教程（二）</title>
      <link href="2021/03/28/elasticsearch-jiao-cheng-er/"/>
      <url>2021/03/28/elasticsearch-jiao-cheng-er/</url>
      
        <content type="html"><![CDATA[<h2 id="一-Request-Body深入搜索"><a href="#一-Request-Body深入搜索" class="headerlink" title="一 Request Body深入搜索"></a>一 Request Body深入搜索</h2><h3 id="1-1-term查询"><a href="#1-1-term查询" class="headerlink" title="1.1 term查询"></a>1.1 term查询</h3><blockquote><p>term是表达语义的最小单位，在搜索的时候基本都要使用到term。 </p><p>term查询的种类有：Term Query、Range Query等。</p><p>在ES中，Term查询不会对输入进行分词处理，将输入作为一个整体，在倒排索引中查找准确的词项。我们也可以使用 Constant Score 将查询转换为一个filter,避免算分，利用缓存，提高查询的效率。 </p></blockquote><h4 id="1-1-1-term与terms"><a href="#1-1-1-term与terms" class="headerlink" title="1.1.1 term与terms"></a>1.1.1 term与terms</h4><blockquote><p><strong>查询电影名字中包含有 beautiful 这个单词的所有的电影，用于查询的单词不会进行分词的处理</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search &#123;    &quot;query&quot;: &#123;        &quot;term&quot;: &#123;            &quot;title&quot;: &#123;                &quot;value&quot;: &quot;beautiful&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询电影名字中包含有 beautiful 或者 mind 这两个单词的所有的电影，用于查询的单词不会进行分词的处理</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;terms&quot;: &#123;            &quot;title&quot;: [                &quot;beautiful&quot;,                &quot;mind&quot;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-2-range"><a href="#1-1-2-range" class="headerlink" title="1.1.2 range"></a>1.1.2 range</h4><blockquote><p><strong>查询上映在2016到2018年的所有的电影，再根据上映时间的倒序进行排序</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;range&quot;: &#123;            &quot;year&quot;: &#123;                &quot;gte&quot;: 2016,                &quot;lte&quot;: 2018            &#125;        &#125;    &#125;,    &quot;sort&quot;: [        &#123;            &quot;year&quot;: &#123;                &quot;order&quot;: &quot;desc&quot;            &#125;        &#125;    ]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-3-Constant-Score"><a href="#1-1-3-Constant-Score" class="headerlink" title="1.1.3 Constant Score"></a>1.1.3 Constant Score</h4><blockquote><p><strong>查询title中包含有beautiful的所有的电影，不进行相关性算分，查询的数据进行缓存，提高效率</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;constant_score&quot;: &#123;            &quot;filter&quot;: &#123;                &quot;term&quot;: &#123;                    &quot;title&quot;: &quot;beautiful&quot;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-全文查询"><a href="#1-2-全文查询" class="headerlink" title="1.2 全文查询"></a>1.2 全文查询</h3><blockquote><p>全文查询的种类有: Match Query、Match Phrase Query、Query String Query等 </p><p><strong>索引和搜索的时候都会进行分词，在查询的时候，会对输入进行分词，然后每个词项会逐个到底层进行查询，将最终的结果进行合并</strong> </p></blockquote><h4 id="1-2-1-match"><a href="#1-2-1-match" class="headerlink" title="1.2.1 match"></a>1.2.1 match</h4><blockquote><p><strong>查询电影名字中包含有beautiful的所有电影，每页十条，取第二页的数据</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;match&quot;: &#123;            &quot;title&quot;: &quot;beautiful&quot;        &#125;    &#125;,    &quot;from&quot;: 10,    &quot;size&quot;: 10&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询电影名字中包含有 beautiful 或者 mind 的所有的数据，但是只查询title和id两个属性</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;_source&quot;: [        &quot;title&quot;,        &quot;id&quot;    ],    &quot;query&quot;: &#123;        &quot;match&quot;: &#123;            &quot;title&quot;: &quot;beautiful mind&quot;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-2-match-phrase"><a href="#1-2-2-match-phrase" class="headerlink" title="1.2.2 match_phrase"></a>1.2.2 match_phrase</h4><blockquote><p><strong>查询电影名字中包含有 “beautiful mind” 这个短语的所有的数据</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;match_phrase&quot;: &#123;            &quot;title&quot;: &quot;beautiful mind&quot;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-3-multi-match"><a href="#1-2-3-multi-match" class="headerlink" title="1.2.3 multi_match"></a>1.2.3 multi_match</h4><blockquote><p><strong>查询 title 或 genre 中包含有 beautiful 或者 Adventure 的所有的数据</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;multi_match&quot;: &#123;            &quot;query&quot;: &quot;beautiful Adventure&quot;,            &quot;fields&quot;: [                &quot;title&quot;,                &quot;genre&quot;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-4-match-all"><a href="#1-2-4-match-all" class="headerlink" title="1.2.4 match_all"></a>1.2.4 match_all</h4><blockquote><p><strong>查询所有的数据</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;match_all&quot;: &#123;&#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-5-query-string"><a href="#1-2-5-query-string" class="headerlink" title="1.2.5 query_string"></a>1.2.5 query_string</h4><blockquote><p><strong>查询 title 中包含有 beautiful 和 mind 的所有的电影</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;query_string&quot;: &#123;            &quot;default_field&quot;: &quot;title&quot;,            &quot;query&quot;: &quot;mind AND beautiful&quot;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;query_string&quot;: &#123;            &quot;default_field&quot;: &quot;title&quot;,            &quot;query&quot;: &quot;mind beautiful&quot;,            &quot;default_operator&quot;: &quot;AND&quot;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-6-simple-query-string"><a href="#1-2-6-simple-query-string" class="headerlink" title="1.2.6 simple_query_string"></a>1.2.6 simple_query_string</h4><blockquote><p>simple_query_string 覆盖了很多其他查询的用法。</p></blockquote><blockquote><p><strong>查询 title 中包含有 beautiful 和 mind 的所有的电影</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;simple_query_string&quot;: &#123;            &quot;query&quot;: &quot;beautiful + mind&quot;,            &quot;fields&quot;: [                &quot;title&quot;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;simple_query_string&quot;: &#123;            &quot;query&quot;: &quot;beautiful mind&quot;,            &quot;fields&quot;: [                &quot;title&quot;            ],            &quot;default_operator&quot;: &quot;AND&quot;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询title中包含 “beautiful mind” 这个短语的所有的电影 (用法和match_phrase类似)</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;simple_query_string&quot;: &#123;            &quot;query&quot;: &quot;\&quot;beautiful mind\&quot;&quot;,            &quot;fields&quot;: [                &quot;title&quot;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询title或genre中包含有 beautiful mind romance 这个三个单词的所有的电影 （与multi_match类似）</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search &#123;    &quot;query&quot;: &#123;        &quot;simple_query_string&quot;: &#123;            &quot;query&quot;: &quot;beautiful mind Romance&quot;,            &quot;fields&quot;: [                &quot;title&quot;,                &quot;genre&quot;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询title中包含 “beautiful mind” 或者 “Modern Romance” 这两个短语的所有的电影</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;simple_query_string&quot;: &#123;            &quot;query&quot;: &quot;\&quot;beautiful mind\&quot; | \&quot;Modern Romance\&quot;&quot;,            &quot;fields&quot;: [                &quot;title&quot;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询title或者genre中包含有 beautiful + mind 这个两个词，或者Comedy + Romance + Musical + Drama + Children 这个五个词的所有的数据</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;simple_query_string&quot;: &#123;            &quot;query&quot;: &quot;(beautiful + mind) | (Comedy + Romance + Musical + Drama + Children)&quot;,            &quot;fields&quot;: [                &quot;title&quot;,                &quot;genre&quot;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询 title 中包含 beautiful 和 people 但是不包含 Animals 的所有的数据</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;simple_query_string&quot;: &#123;            &quot;query&quot;: &quot;beautiful + people + -Animals&quot;,            &quot;fields&quot;: [                &quot;title&quot;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>.</p><h3 id="1-3-模糊搜索"><a href="#1-3-模糊搜索" class="headerlink" title="1.3 模糊搜索"></a>1.3 模糊搜索</h3><blockquote><p><strong>查询title中从第6个字母开始只要最多纠正一次，就与 neverendign 匹配的所有的数据</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;fuzzy&quot;: &#123;            &quot;title&quot;: &#123;                &quot;value&quot;: &quot;neverendign&quot;,                &quot;fuzziness&quot;: 1,                &quot;prefix_length&quot;: 5            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-4-多条件查询"><a href="#1-4-多条件查询" class="headerlink" title="1.4 多条件查询"></a>1.4 多条件查询</h3><blockquote><p><strong>查询title中包含有beautiful或者mind单词，并且上映时间在2016~1018年的所有的电影</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;bool&quot;: &#123;            &quot;must&quot;: [                &#123;                    &quot;simple_query_string&quot;: &#123;                        &quot;query&quot;: &quot;beautiful mind&quot;,                        &quot;fields&quot;: [                            &quot;title&quot;                        ]                    &#125;                &#125;,                &#123;                    &quot;range&quot;: &#123;                        &quot;year&quot;: &#123;                            &quot;gte&quot;: 2016,                            &quot;lte&quot;: 2018                        &#125;                    &#125;                &#125;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询title中包含有beautiful或者mind单词，并且上映时间不在2016~1018年的所有的电影</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;bool&quot;: &#123;            &quot;must&quot;: [                &#123;                    &quot;simple_query_string&quot;: &#123;                        &quot;query&quot;: &quot;beautiful mind&quot;,                        &quot;fields&quot;: [                            &quot;title&quot;                        ]                    &#125;                &#125;            ],            &quot;must_not&quot;: [                &#123;                    &quot;range&quot;: &#123;                        &quot;year&quot;: &#123;                            &quot;gte&quot;: 2016,                            &quot;lte&quot;: 2018                        &#125;                    &#125;                &#125;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询 title 中包含有 beautiful 这个单词，并且上映年份在2016~2018年间的所有电影，但是不进行相关性的算分</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json"># filter不会进行相关性的算分，并且会将查出来的结果进行缓存，效率上比 query 高 GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;bool&quot;: &#123;            &quot;filter&quot;: [                &#123;                    &quot;term&quot;: &#123;                        &quot;title&quot;: &quot;beautiful&quot;                    &#125;                &#125;,                &#123;                    &quot;range&quot;: &#123;                        &quot;year&quot;: &#123;                            &quot;gte&quot;: 2016,                            &quot;lte&quot;: 2018                        &#125;                    &#125;                &#125;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询 title 中包含有 beautiful 这个单词，或者年份在2016~2018年间的所有电影</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;bool&quot;: &#123;            &quot;should&quot;: [                &#123;                    &quot;term&quot;: &#123;                        &quot;title&quot;: &quot;beautiful&quot;                    &#125;                &#125;,                &#123;                    &quot;range&quot;: &#123;                        &quot;year&quot;: &#123;                            &quot;gte&quot;: 2016,                            &quot;lte&quot;: 2018                        &#125;                    &#125;                &#125;            ]        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>must</strong></p><p>文档 必须 匹配这些条件才能被包含进来。</p><p><strong>must_not</strong></p><p>文档 必须不 匹配这些条件才能被包含进来。不评分模式查询</p><p><strong>should or</strong></p><p>如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。</p><p><strong>filter</strong></p><p>必须 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档。</p></blockquote><h2 id="二-Mapping"><a href="#二-Mapping" class="headerlink" title="二 Mapping"></a>二 Mapping</h2><blockquote><p>mapping类似于数据库中的schema，作用如下: </p><ol><li><p>定义索引中的字段类型；</p></li><li><p>定义字段的数据类型，例如：布尔、字符串、数字、日期….. </p></li><li><p>字段倒排索引的设置</p></li></ol></blockquote><h3 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h3><table><thead><tr><th><strong>类型名 描述</strong></th><th></th></tr></thead><tbody><tr><td>Text/Keyword</td><td>字符串， <strong>Keyword的意思是字符串的内容不会被分词处理，输入是什么内容，存储在ES中就是什么内容。Text类型ES会自动的添加一个Keyword类型的子字段</strong></td></tr><tr><td>Date</td><td>日期类型</td></tr><tr><td>Integer/Float/Long</td><td>数字类型</td></tr><tr><td>Boolean</td><td>布尔类型</td></tr></tbody></table><blockquote><p> ES中还有 “对象类型/嵌套类型”、”特殊类型（geo_point/geo_shape）”。</p></blockquote><h3 id="2-2-Mapping的定义"><a href="#2-2-Mapping的定义" class="headerlink" title="2.2 Mapping的定义"></a>2.2 Mapping的定义</h3><blockquote><p>语法格式如下：</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT users &#123;    &quot;mappings&quot;: &#123;&#x2F;&#x2F; define your mappings here&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>定义mapping的建议方式: 写入一个样本文档到临时索引中，ES会自动生成mapping信息，通过访问mapping信息的api查询mapping的定义，修改自动生成的mapping成为我们需要方式，创建索引，删除临时索引，简而言之就是 “卸磨杀驴” 。</strong></p></blockquote><h3 id="2-3-常见参数"><a href="#2-3-常见参数" class="headerlink" title="2.3 常见参数"></a>2.3 常见参数</h3><h4 id="2-3-1-index"><a href="#2-3-1-index" class="headerlink" title="2.3.1 index"></a>2.3.1 index</h4><blockquote><p>可以给属性添加一个 布尔类型的index属性，标识该属性是否能被倒排索引，也就是说是否能通过该字段进行搜索。</p></blockquote><h4 id="2-3-2-null-value"><a href="#2-3-2-null-value" class="headerlink" title="2.3.2 null_value"></a>2.3.2 null_value</h4><blockquote><p>在数据索引进ES的时候，当某些数据为 null 的时候，该数据是不能被搜索的，可以使用null_value 属性指定一个值，当属性的值为 null 的时候，转换为一个通过 null_value 指定的值。 <strong>null_value属性只能用于Keyword类型的属性</strong> </p></blockquote><h2 id="三-再谈搜索"><a href="#三-再谈搜索" class="headerlink" title="三 再谈搜索"></a><strong>三</strong> 再谈搜索</h2><h3 id="3-1-聚合查询"><a href="#3-1-聚合查询" class="headerlink" title="3.1 聚合查询"></a>3.1 聚合查询</h3><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210327120547522.png" alt="image-20210327120547522"></p><blockquote><p>聚合搜索的语法格式如下：</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET indexName&#x2F;_search &#123;    &quot;aggs&quot;: &#123;   #聚合分析的名字是由用户自定义的        &quot;aggs_name&quot;: &#123;            &quot;aggs_type&quot;: &#123;               # aggregation body            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>给employee索引创建mapping信息</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT employee&#123;    &quot;mappings&quot;: &#123;        &quot;properties&quot;: &#123;            &quot;id&quot;: &#123;                &quot;type&quot;: &quot;integer&quot;            &#125;,            &quot;name&quot;: &#123;                &quot;type&quot;: &quot;keyword&quot;            &#125;,            &quot;job&quot;: &#123;                &quot;type&quot;: &quot;keyword&quot;            &#125;,            &quot;age&quot;: &#123;                &quot;type&quot;: &quot;integer&quot;            &#125;,            &quot;gender&quot;: &#123;                &quot;type&quot;: &quot;keyword&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>往 employee索引中写入数据</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">PUT employee&#x2F;_bulk &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 1&#125;&#125;&#123;&quot;id&quot;: 1, &quot;name&quot;: &quot;Bob&quot;, &quot;job&quot;: &quot;java&quot;, &quot;age&quot;: 21, &quot;sal&quot;: 8000, &quot;gender&quot;: &quot;female&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 2&#125;&#125; &#123;&quot;id&quot;: 2, &quot;name&quot;: &quot;Rod&quot;, &quot;job&quot;: &quot;html&quot;, &quot;age&quot;: 31, &quot;sal&quot;: 18000, &quot;gender&quot;: &quot;female&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 3&#125;&#125; &#123;&quot;id&quot;: 3, &quot;name&quot;: &quot;Gaving&quot;, &quot;job&quot;: &quot;java&quot;, &quot;age&quot;: 24, &quot;sal&quot;: 12000, &quot;gender&quot;: &quot;male&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 4&#125;&#125; &#123;&quot;id&quot;: 4, &quot;name&quot;: &quot;King&quot;, &quot;job&quot;: &quot;dba&quot;, &quot;age&quot;: 26, &quot;sal&quot;: 15000, &quot;gender&quot;: &quot;female&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 5&#125;&#125; &#123;&quot;id&quot;: 5, &quot;name&quot;: &quot;Jonhson&quot;, &quot;job&quot;: &quot;dba&quot;, &quot;age&quot;: 29, &quot;sal&quot;: 16000, &quot;gender&quot;: &quot;male&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 6&#125;&#125; &#123;&quot;id&quot;: 6, &quot;name&quot;: &quot;Douge&quot;, &quot;job&quot;: &quot;java&quot;, &quot;age&quot;: 41, &quot;sal&quot;: 20000, &quot;gender&quot;: &quot;female&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 7&#125;&#125; &#123;&quot;id&quot;: 7, &quot;name&quot;: &quot;cutting&quot;, &quot;job&quot;: &quot;dba&quot;, &quot;age&quot;: 27, &quot;sal&quot;: 7000, &quot;gender&quot;: &quot;male&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 8&#125;&#125; &#123;&quot;id&quot;: 8, &quot;name&quot;: &quot;Bona&quot;, &quot;job&quot;: &quot;html&quot;, &quot;age&quot;: 22, &quot;sal&quot;: 14000, &quot;gender&quot;: &quot;female&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 9&#125;&#125;&#123;&quot;id&quot;: 9, &quot;name&quot;: &quot;Shyon&quot;, &quot;job&quot;: &quot;dba&quot;, &quot;age&quot;: 20, &quot;sal&quot;: 19000, &quot;gender&quot;: &quot;female&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 10&#125;&#125; &#123;&quot;id&quot;: 10, &quot;name&quot;: &quot;James&quot;, &quot;job&quot;: &quot;html&quot;, &quot;age&quot;: 18, &quot;sal&quot;: 22000, &quot;gender&quot;: &quot;male&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 11&#125;&#125;&#123;&quot;id&quot;: 11, &quot;name&quot;: &quot;Golsling&quot;, &quot;job&quot;: &quot;java&quot;, &quot;age&quot;: 32, &quot;sal&quot;: 23000, &quot;gender&quot;: &quot;female&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 12&#125;&#125; &#123;&quot;id&quot;: 12, &quot;name&quot;: &quot;Lily&quot;, &quot;job&quot;: &quot;java&quot;, &quot;age&quot;: 24, &quot;sal&quot;: 2000, &quot;gender&quot;: &quot;male&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 13&#125;&#125; &#123;&quot;id&quot;: 13, &quot;name&quot;: &quot;Jack&quot;, &quot;job&quot;: &quot;html&quot;, &quot;age&quot;: 23, &quot;sal&quot;: 3000, &quot;gender&quot;: &quot;female&quot;&#125; &#123;&quot;index&quot;: &#123;&quot;_id&quot;: 14&#125;&#125; &#123;&quot;id&quot;: 14, &quot;name&quot;: &quot;Rose&quot;, &quot;job&quot;: &quot;java&quot;, &quot;age&quot;: 36, &quot;sal&quot;: 6000, &quot;gender&quot;: &quot;female&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 15&#125;&#125; &#123;&quot;id&quot;: 15, &quot;name&quot;: &quot;Will&quot;, &quot;job&quot;: &quot;dba&quot;, &quot;age&quot;: 38, &quot;sal&quot;: 4500, &quot;gender&quot;: &quot;male&quot;&#125;&#123;&quot;index&quot;: &#123;&quot;_id&quot;: 16&#125;&#125;&#123;&quot;id&quot;: 16, &quot;name&quot;: &quot;smith&quot;, &quot;job&quot;: &quot;java&quot;, &quot;age&quot;: 32, &quot;sal&quot;: 23000, &quot;gender&quot;: &quot;male&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-1-单值的输出"><a href="#3-1-1-单值的输出" class="headerlink" title="3.1.1 单值的输出"></a>3.1.1 单值的输出</h4><blockquote><p>ES中大多数的数学计算只输出一个值，如：min、max、sum、avg、cardinality</p></blockquote><blockquote><p><strong>查询工资的总和</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search &#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;other_info&quot;: &#123;            &quot;sum&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询员工的平均工资</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search &#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;other_aggs_info&quot;: &#123;            &quot;avg&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询总共有多少个岗位, cardinality的值类似于sql中的 count distinct,即去重统计总数</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;job_count&quot;: &#123;            &quot;cardinality&quot;: &#123;                &quot;field&quot;: &quot;job&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询航班票价的最高值、平均值、最低值</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET kibana_sample_data_flights&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;max_price&quot;: &#123;            &quot;max&quot;: &#123;                &quot;field&quot;: &quot;AvgTicketPrice&quot;            &#125;        &#125;,        &quot;min_price&quot;: &#123;            &quot;min&quot;: &#123;                &quot;field&quot;: &quot;AvgTicketPrice&quot;            &#125;        &#125;,        &quot;avg_price&quot;: &#123;            &quot;avg&quot;: &#123;                &quot;field&quot;: &quot;AvgTicketPrice&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-2-多值的输出"><a href="#3-1-2-多值的输出" class="headerlink" title="3.1.2 多值的输出"></a>3.1.2 多值的输出</h4><blockquote><p>ES还有些函数，可以一次性输出很多个统计的数据: terms、stats </p></blockquote><blockquote><p><strong>查询工资的信息</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;sal_info&quot;: &#123;            &quot;stats&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询到达不同城市的航班数量</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET kibana_sample_data_flights&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;flight_dest&quot;: &#123;            &quot;terms&quot;: &#123;                &quot;field&quot;: &quot;DestCountry&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询每个岗位有多少人</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;job_count&quot;: &#123;            &quot;terms&quot;: &#123;                &quot;field&quot;: &quot;job&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询目标地的航班次数以及天气信息</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET kibana_sample_data_flights&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;dest_city&quot;: &#123;            &quot;terms&quot;: &#123;                &quot;field&quot;: &quot;DestCityName&quot;            &#125;,            &quot;aggs&quot;: &#123;                &quot;whether_info&quot;: &#123;                    &quot;terms&quot;: &#123;                        &quot;field&quot;: &quot;DestWeather&quot;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询每个岗位下工资的信息(平均工资、最高工资、最少工资等)</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;job_inf&quot;: &#123;            &quot;terms&quot;: &#123;                &quot;field&quot;: &quot;job&quot;            &#125;,            &quot;aggs&quot;: &#123;                &quot;sal_info&quot;: &#123;                    &quot;stats&quot;: &#123;                        &quot;field&quot;: &quot;sal&quot;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询不同工种的男女员工数量、然后统计不同工种下男女员工的工资信息</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;job_info&quot;: &#123;            &quot;terms&quot;: &#123;                &quot;field&quot;: &quot;job&quot;            &#125;,            &quot;aggs&quot;: &#123;                &quot;gender_info&quot;: &#123;                    &quot;terms&quot;: &#123;                        &quot;field&quot;: &quot;gender&quot;                    &#125;,                    &quot;aggs&quot;: &#123;                        &quot;sal_info&quot;: &#123;                            &quot;stats&quot;: &#123;                                &quot;field&quot;: &quot;sal&quot;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询年龄最大的两位员工的信息</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;top_age_2&quot;: &#123;            &quot;top_hits&quot;: &#123;                &quot;size&quot;: 2,                &quot;sort&quot;: [                    &#123;                        &quot;age&quot;: &#123;                            &quot;order&quot;: &quot;desc&quot;                        &#125;                    &#125;                ]            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询不同区间员工工资的统计信息</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;sal_info&quot;: &#123;            &quot;range&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;,                &quot;ranges&quot;: [                    &#123;                        &quot;key&quot;: &quot;0 &lt;&#x3D; sal &lt;&#x3D; 5000&quot;,                        &quot;from&quot;: 0,                        &quot;to&quot;: 5000                    &#125;,                    &#123;                        &quot;key&quot;: &quot;5001 &lt;&#x3D; sal &lt;&#x3D; 10000&quot;,                        &quot;from&quot;: 5001,                        &quot;to&quot;: 10000                    &#125;,                    &#123;                        &quot;key&quot;: &quot;10001 &lt;&#x3D; sal &lt;&#x3D; 15000&quot;,                        &quot;from&quot;: 10001,                        &quot;to&quot;: 15000                    &#125;                ]            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>以直方图的方式以每5000元为一个区间查看工资信息</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;sal_info&quot;: &#123;            &quot;histogram&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;,                &quot;interval&quot;: 5000,                &quot;extended_bounds&quot;: &#123;                    &quot;min&quot;: 0,                    &quot;max&quot;: 30000                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>interval: 以指定的值为一个区间。</p><p>extended_bounds: 可以指定区间的范围，如果超出了区间范围以实际为准，如果没有超出其他区间的数据依然显示。</p></blockquote><blockquote><p><strong>查询平均工资大于最低的工种</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;job_info&quot;: &#123;            &quot;terms&quot;: &#123;                &quot;field&quot;: &quot;job&quot;            &#125;,            &quot;aggs&quot;: &#123;                &quot;job_avg_sal&quot;: &#123;                    &quot;avg&quot;: &#123;                        &quot;field&quot;: &quot;sal&quot;                    &#125;                &#125;            &#125;        &#125;,        &quot;min_sal_job&quot;: &#123;            &quot;min_bucket&quot;: &#123;                &quot;buckets_path&quot;: &quot;job_info&gt;job_avg_sal&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询工资和工种的信息</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;job_inf&quot;: &#123;            &quot;terms&quot;: &#123;                &quot;field&quot;: &quot;job&quot;            &#125;        &#125;,        &quot;sal_info&quot;: &#123;            &quot;stats&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询年龄大于30岁的员工的平均工资</strong></p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;query&quot;: &#123;        &quot;range&quot;: &#123;            &quot;age&quot;: &#123;                &quot;gte&quot;: 30            &#125;        &#125;    &#125;,    &quot;aggs&quot;: &#123;        &quot;avg_sal&quot;: &#123;            &quot;avg&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>查询Java员工的平均工资</strong> </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;query&quot;: &#123;        &quot;constant_score&quot;: &#123;            &quot;filter&quot;: &#123;                &quot;term&quot;: &#123;                    &quot;job&quot;: &quot;java&quot;                &#125;            &#125;,            &quot;boost&quot;: 1.2        &#125;    &#125;,    &quot;aggs&quot;: &#123;        &quot;avg_sal&quot;: &#123;            &quot;avg&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>求30岁以上的员工的平均工资和所有员工的平均工资 </p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET employee&#x2F;_search&#123;    &quot;size&quot;: 0,    &quot;aggs&quot;: &#123;        &quot;get_30_emp_info&quot;: &#123;            &quot;filter&quot;: &#123;                &quot;range&quot;: &#123;                    &quot;age&quot;: &#123;                        &quot;gte&quot;: 30                    &#125;                &#125;            &#125;,            &quot;aggs&quot;: &#123;                &quot;get_30_emp_avg_sal&quot;: &#123;                    &quot;avg&quot;: &#123;                        &quot;field&quot;: &quot;sal&quot;                    &#125;                &#125;            &#125;        &#125;,        &quot;all_emp_avg_sal&quot;: &#123;            &quot;avg&quot;: &#123;                &quot;field&quot;: &quot;sal&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-推荐搜索"><a href="#3-2-推荐搜索" class="headerlink" title="3.2 推荐搜索"></a>3.2 推荐搜索</h3><blockquote><p>在搜索过程中，因为单词的拼写错误，没有得到任何的结果，希望ES能够给我们一个推荐搜索。</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;suggest&quot;: &#123;      # title_suggestion为我们自定义的名字        &quot;title_suggestion&quot;: &#123;            &quot;text&quot;: &quot;drema&quot;,            &quot;term&quot;: &#123;                &quot;field&quot;: &quot;title&quot;,                &quot;suggest_mode&quot;: &quot;popular&quot;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>suggest_mode，有三个值：popular、missing、always</strong> </p><ol><li>popular 是推荐词频更高的一些搜索。</li><li>missing 是当没有要搜索的结果的时候才推荐。</li><li>always 无论什么情况下都进行推荐。</li></ol></blockquote><h3 id="3-3-自动补全"><a href="#3-3-自动补全" class="headerlink" title="3.3 自动补全"></a>3.3 自动补全</h3><blockquote><p>自动补全应该是我们在日常的开发过程中最常见的搜索方式了，如百度搜索和京东商品搜索。</p></blockquote><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210327134915454.png" alt="image-20210327134915454"></p><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210327135125237.png" alt="image-20210327135125237"></p><blockquote><p>自动补全的功能对性能的要求极高，用户每发送输入一个字符就要发送一个请求去查找匹配项。</p><p>ES采取了不同的数据结构来实现，并不是通过倒排索引来实现的；需要将对应的数据类型设置为<strong>completion</strong> ; 所以在将数据索引进ES之前需要先定义 mapping 信息。</p></blockquote><h4 id="3-3-1-定义mapping"><a href="#3-3-1-定义mapping" class="headerlink" title="3.3.1 定义mapping"></a>3.3.1 <strong>定义</strong>mapping</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;movies&quot;: &#123;        &quot;mappings&quot;: &#123;            &quot;properties&quot;: &#123;                &quot;@version&quot;: &#123;                    &quot;type&quot;: &quot;text&quot;,                    &quot;fields&quot;: &#123;                        &quot;keyword&quot;: &#123;                            &quot;type&quot;: &quot;keyword&quot;,                            &quot;ignore_above&quot;: 256                        &#125;                    &#125;                &#125;,                &quot;genre&quot;: &#123;                    &quot;type&quot;: &quot;text&quot;,                    &quot;fields&quot;: &#123;                        &quot;keyword&quot;: &#123;                            &quot;type&quot;: &quot;keyword&quot;,                            &quot;ignore_above&quot;: 256                        &#125;                    &#125;                &#125;,                &quot;id&quot;: &#123;                    &quot;type&quot;: &quot;text&quot;,                    &quot;fields&quot;: &#123;                        &quot;keyword&quot;: &#123;                            &quot;type&quot;: &quot;keyword&quot;,                            &quot;ignore_above&quot;: 256                        &#125;                    &#125;                &#125;,                &quot;title&quot;: &#123;                  # 需要自动提示的属性类型必须是 completion                    &quot;type&quot;: &quot;completion&quot;                &#125;,                &quot;year&quot;: &#123;                    &quot;type&quot;: &quot;long&quot;                &#125;            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>定义完 mapping 信息之后，导入响应的数据</p></blockquote><h4 id="3-3-2-前缀搜索"><a href="#3-3-2-前缀搜索" class="headerlink" title="3.3.2 前缀搜索"></a>3.3.2 前缀搜索</h4><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;_source&quot;: [        &quot;title&quot;    ],    &quot;suggest&quot;: &#123;        &quot;prefix_suggestion&quot;: &#123;            &quot;prefix&quot;: &quot;Lan&quot;,            &quot;completion&quot;: &#123;                &quot;field&quot;: &quot;title&quot;,                &quot;skip_duplicates&quot;: true,                &quot;size&quot;: 10            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自动提示功能实现</strong></p><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210328001210925.png" alt="image-20210328001210925"></p><blockquote><p>skip_duplicates: 表示忽略掉重复。</p><p>size: 表示返回多少条数据。</p></blockquote><h3 id="3-4-高亮显示"><a href="#3-4-高亮显示" class="headerlink" title="3.4 高亮显示"></a>3.4 高亮显示</h3><blockquote><p>高亮显示在实际的应用中也会碰到很多，如下给出了百度和知乎的两个高亮搜索的案例：</p></blockquote><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210328001547959.png" alt="image-20210328001547959"></p><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210328001809732.png" alt="image-20210328001809732"></p><blockquote><p>将所有的包含有 beautiful 的单词高亮显示</p></blockquote><pre class="line-numbers language-json" data-language="json"><code class="language-json">GET movies&#x2F;_search&#123;    &quot;query&quot;: &#123;        &quot;match&quot;: &#123;            &quot;title&quot;: &quot;beautiful&quot;        &#125;    &#125;,    &quot;highlight&quot;: &#123;        &quot;post_tags&quot;: &quot;&lt;&#x2F;span&gt;&quot;,        &quot;pre_tags&quot;: &quot;&lt;span color&#x3D;&#39;red&#39;&gt;&quot;,        &quot;fields&quot;: &#123;            &quot;title&quot;: &#123;&#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>pre_tags: 是需要高亮文本的前置 html 内容。</p><p>post_tags: 是需要高亮的后置html内容。</p><p>fields: 是需要高亮的属性。</p></blockquote><p><strong>高亮结果</strong></p><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20210328002445538.png" alt="image-20210328002445538"></p>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软考模拟考题</title>
      <link href="2021/02/01/ruan-kao-mo-ni-kao-ti/"/>
      <url>2021/02/01/ruan-kao-mo-ni-kao-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="软考模拟考题"><a href="#软考模拟考题" class="headerlink" title="软考模拟考题"></a>软考模拟考题</h1><h2 id="作业题"><a href="#作业题" class="headerlink" title="作业题"></a>作业题</h2><h3 id="1、赶工与快速跟进的区别。"><a href="#1、赶工与快速跟进的区别。" class="headerlink" title="1、赶工与快速跟进的区别。"></a>1、赶工与快速跟进的区别。</h3><p>(1)赶工。通过增加资源，以最小的成本增加来压缩进度工期的一种技术。赶工的例子包括：批准加班、增加额外资源或支付加急费用，来加快关键路径上的活动。赶工只适用于那些通过增加资源就能缩短持续时间的，且位于关键路径上的活动。赶工并非总是切实可行，它可能导致风险和/或成本的增加。<br>(2)快速跟进。一种进度压缩技术，将正常情况下按顺序进行的活动或阶段改为至少是部分并行开展。它只适用于能够通过并行活动来缩短项目工期的情况。<br>区别：赶工需要给钱，加班加点的做；并行施工把后面的工作提前做。</p><h3 id="2、资源平衡与资源平滑的区别。"><a href="#2、资源平衡与资源平滑的区别。" class="headerlink" title="2、资源平衡与资源平滑的区别。"></a>2、资源平衡与资源平滑的区别。</h3><p>资源平衡：为了在资源需求与资源供给之间取得平衡，根据资源制约对开始日期和结束日期进行调整的一种技术。资源平衡往往导致关键路径改变，通常是延长。<br>资源平滑：对进度模型中的活动进行调整，从而使项目资源需求不超过预定的资源限制的一种技术。相对于资源平衡而言，资源平滑不会改变项目关键路径，完工日期也不会延迟。资源平滑技术可能无法实现所有资源的优化。<br>区别：资源平衡有可能改变关键路径。资源平滑不会改变关键路径。</p><h3 id="3、关键链法的概念。"><a href="#3、关键链法的概念。" class="headerlink" title="3、关键链法的概念。"></a>3、关键链法的概念。</h3><p>关键链法增加了作为“非工作活动”的持续时间缓冲，用来应对不确定性。项目缓冲放置在关键链末端的缓冲，用来保证项目不因关键链的延误而延误。接驳缓冲放置在非关键链与关键链的接合点，用来保护关键链不受非关键链延误的影响。</p><h3 id="4、通常采用哪些方法缩短项目工期？"><a href="#4、通常采用哪些方法缩短项目工期？" class="headerlink" title="4、通常采用哪些方法缩短项目工期？"></a>4、通常采用哪些方法缩短项目工期？</h3><p>赶工；快速跟进；采用新技术；采用高效人员；减少项目范围；加强质量管理，减少返工。</p><h3 id="5、成本估算的过程？（3个步骤）"><a href="#5、成本估算的过程？（3个步骤）" class="headerlink" title="5、成本估算的过程？（3个步骤）"></a>5、成本估算的过程？（3个步骤）</h3><p>估算成本的主要步骤：(1)识别并分析成本的构成科目。(2）根据已识别的项目成本构成科目，估算每一科目的成本大小。(3)分析成本估算结果，找出各种可以相互替代的成本，协调各种成本之问的比例关系。</p><h3 id="6、直接成本与间接成本的区别。"><a href="#6、直接成本与间接成本的区别。" class="headerlink" title="6、直接成本与间接成本的区别。"></a>6、直接成本与间接成本的区别。</h3><p>直接成本：直接可以归属于项目工作的成本为直接成本，如项目团队差旅费、工资、项目使用的物料及设备使用费等。可以由项目经理控制。<br>间接成本：来自一般管理费用科目或几个项目共同担负的项目成本所分摊给本项目的费用，如税金、额外福利和保卫费用等。<br>区别：直接成本项目经理可以控制；间接成本项目经理没办法控制，关键词分摊。</p><h3 id="7、机会成本的特点。"><a href="#7、机会成本的特点。" class="headerlink" title="7、机会成本的特点。"></a>7、机会成本的特点。</h3><p>机会成本：利用一定的时间或资源生产一种商品时，而失去的利用这些资源生产其他最佳替代晶的机会就是机会成本，泛指一切在做出选择后其中一个最大的损失。<br>特点：看到的，但是没有拿到的最大损失。</p><h3 id="8、应急储备与管理储备的区别。"><a href="#8、应急储备与管理储备的区别。" class="headerlink" title="8、应急储备与管理储备的区别。"></a>8、应急储备与管理储备的区别。</h3><p>应急储备用于已知-未知的风险，项目经理可以动用；管理储备用于未知-未知的风险，项目经理无权动用。</p>]]></content>
      
      
      <categories>
          
          <category> 考证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考高项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备战软考</title>
      <link href="2021/01/20/bei-zhan-ruan-kao/"/>
      <url>2021/01/20/bei-zhan-ruan-kao/</url>
      
        <content type="html"><![CDATA[<h1 id="备战软考"><a href="#备战软考" class="headerlink" title="备战软考"></a>备战软考</h1><h2 id="考试介绍"><a href="#考试介绍" class="headerlink" title="考试介绍"></a>考试介绍</h2><h3 id="考试简介"><a href="#考试简介" class="headerlink" title="考试简介"></a>考试简介</h3><p>信息系统项目管理师是全国计算机技术与软件专业技术资格（水平）考试中的<strong>高级</strong>水平测试，综合素质要求高、以计算机基础技术为依托、考查项目管理方面的内容、覆盖面较广、有一定难度、但是没有任何报名条件。</p><p>计算机技术与软件专业技术资格（水平）考试是由国家人力资源和社会保障部、工业和信息化部领导下的国家级考试。考试合格者将颁发由中华人民共和国人力资源和社会保障部、工业和信息化部用印的计算机技术与软件专业技术资格（水平）证书。该证书在全国范围内有效。</p><h3 id="资格证书（待补充）"><a href="#资格证书（待补充）" class="headerlink" title="资格证书（待补充）"></a>资格证书（待补充）</h3><h3 id="证书作用"><a href="#证书作用" class="headerlink" title="证书作用"></a>证书作用</h3><ul><li>获得职称、评标专家</li><li>能入户、提薪资</li><li>抵个税</li></ul><h2 id="考试说明"><a href="#考试说明" class="headerlink" title="考试说明"></a>考试说明</h2><h3 id="考试科目、题型"><a href="#考试科目、题型" class="headerlink" title="考试科目、题型"></a>考试科目、题型</h3><table><thead><tr><th>考试科目</th><th>形式</th><th>题目数量</th><th>满分</th><th>及格线</th><th>考试时间</th></tr></thead><tbody><tr><td>基础知识</td><td>单选</td><td>75道</td><td>75分</td><td>45分</td><td>9:00-11:30</td></tr><tr><td>案例分析</td><td>主观题</td><td>3道</td><td>75分</td><td>45分</td><td>13:30-15:00</td></tr><tr><td>论文写作</td><td>主观题</td><td>2选1</td><td>75分</td><td>45分</td><td>15:20-17:20</td></tr></tbody></table><h3 id="考试要求"><a href="#考试要求" class="headerlink" title="考试要求"></a>考试要求</h3><p>（1）掌握信息系统知识；</p><p>（2）掌握信息系统项目管理知识和方法；</p><p>（3）掌握大型、复杂项目管理和多项目管理的知识和方法；</p><p>（4）掌握项目整体绩效评估方法；</p><p>（5）熟悉知识管理和战略管理；</p><p>（6）掌握常用项目管理工具；</p><p>（7）熟悉过程管理；</p><p>（8）熟悉业务流程管理知识；</p><p>（9）熟悉信息化知识和管理科学基础知识；</p><p>（10）熟悉信息系统工程监理知识；</p><p>（11）熟悉信息安全知识；</p><p>（12）熟悉信息系统有关法律法规、技术标准与规范；</p><p>（13）熟悉项目管理师职业道德要求；</p><p>（14）熟练阅读并准确理解相关领域的英文文献。 </p><h3 id="考查目的"><a href="#考查目的" class="headerlink" title="考查目的"></a>考查目的</h3><p>（1）通过本考试的合格人员能够掌握信息系统项目管理的知识体系，具备管理大型、复杂信息系统项目和多项目的经验和能力；</p><p>（2）能根据需求组织制订可行的项目管理计划；</p><p>（3）能够组织项目实施，对项目的人员、资金、设备、进度和质量等进行管理，并能根据实际情况及时做出调整，系统地监督项目实施过程的绩效，保证项目在一定的约束条件下达到既定的项目目标；</p><p>（4）能分析和评估项目管理计划和成果；</p><p>（5）能在项目进展的早期发现问题，并有预防问题的措施；</p><p>（6）能协调信息系统项目所涉及的相关人员；</p><p>（7）具有高级工程师的实际工作能力和业务水平。</p><h2 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h2><ul><li><p>书籍（《软考32小时》《信息系统项目管理师真题精析与命题密卷》《信息系统项目管理师考点精炼》）</p></li><li><p>在线学习（PC端+APP移动端）</p></li><li><p>刷题（章节习题+测验+模考+题库）</p></li><li><p>闯关（刷题闯关）</p></li><li><p>助教（班主任+直播讲师+班长学委+答疑助教）</p></li></ul><h1 id="项目管理专题"><a href="#项目管理专题" class="headerlink" title="项目管理专题"></a>项目管理专题</h1><h2 id="项目管理基础"><a href="#项目管理基础" class="headerlink" title="项目管理基础"></a>项目管理基础</h2><ul><li>项目是为提供一项独特产品、服务或成果所做的临时性努力</li><li>项目的具体特点：临时性（一次性）；独特的产品、服务或成果；逐步完善；资源约束；目的性。</li><li>项目工作的三个主要目标（三约束）：时间、成本和质量。</li><li>项目经理的责任就是在时间、成本、质量和<strong>项目范围</strong>之间进行权衡以保证项目的成功。</li><li>日常运作和项目之间的区分<ul><li>日常运作是持续不断和重复进行的，儿项目是临时性的、独特的。</li><li>项目和日常运作的目标有本质的不同。项目的目标是实现目标，然后结束项目，而持续进行的日常运作的目标一般是为了维持运营。</li><li>项目的实现机制与日常运作大相庭径，因为当宣布的目标实现时，项目即结束。</li></ul></li></ul><table><thead><tr><th>不同点</th><th>项目</th><th>日常运作</th></tr></thead><tbody><tr><td>目的</td><td>独特的</td><td>常规的、普遍的</td></tr><tr><td>责任人</td><td>项目经理</td><td>部门经理</td></tr><tr><td>持续时间</td><td>有限的</td><td>相对无限的</td></tr><tr><td>持续性</td><td>一次性</td><td>重复性</td></tr><tr><td>组织结构</td><td>项目组织</td><td>职能部门</td></tr><tr><td>考核指标</td><td>以目标为导向</td><td>效率和有效性</td></tr><tr><td>资源需求</td><td>多变性</td><td>稳定性</td></tr></tbody></table><ul><li>项目管理就是把各种知识、技能、手段和技术应用于项目活动之中，以达到项目的要求。</li><li>项目管理是通过应用和综合诸如启动、计划、实施、监控和收尾等项目管理过程来进行的。</li><li>管理一个项目包括：识别需求；确定清楚而又能够实现的目标；权衡质量、范围、时间和成本方面互不相让的要求；使技术规格说明书、计划和方法适合于各种各样项目干系人的不同需求与期望等内容。</li><li>项目团队应当将项目置于其所处的文化、社会、国际政治和自然的环节及其同这些环境之间的关系中加以考虑：文化与社会环境；国际与政治环境；自然环境。</li></ul><h3 id="项目管理知识体系构成"><a href="#项目管理知识体系构成" class="headerlink" title="项目管理知识体系构成"></a>项目管理知识体系构成</h3><ul><li><p>有效的管理要求项目管理组至少能理解和使用以下五方面的专门知识领域：项目管理知识体系；应用领域的知识、标准和规定；项目环境知识；通用的管理知识和技能；软技能或人际关系技能。</p></li><li><p>国际标准化组织（ISO）是这样区分标准和规则的（ISO，1994）：</p><ul><li><p>标准是“一致同意建立并由公认的机构批准的文件，该团队提供通用的和可重复使用的规则、指南、活动或其结果的特征”；</p></li><li><p>规则是政府强制的要求；标准和规则之间有很大一块灰色区；</p></li><li><p>标准通常以描述一项为多数人选用的最佳方案的准则形式开始，然后随着其得到广泛的采用，变成了实际的规则；</p></li><li><p>可以再不同的组织层次上规定或强制遵守，例如由政府机构、执行组织的管理层、项目管理团队建立的特定政策和规程。</p></li></ul></li><li><p>项目管理团队应该在项目的社会、政治和自然环境背景下考虑该项目。</p></li></ul><h3 id="IPMP-PMP"><a href="#IPMP-PMP" class="headerlink" title="IPMP/PMP"></a>IPMP/PMP</h3><h3 id="PRINCE2"><a href="#PRINCE2" class="headerlink" title="PRINCE2"></a>PRINCE2</h3><p>四要素：原则、流程、主题、项目环境</p><p>七原则：持续业务验证；吸取经验教训；明确定义的角色和职责；按阶段管理；例外管理；关注产品；根据项目环境裁剪。</p><p>主题：商业论证；组织；质量；计划；风险；变更；进展。</p><h3 id="组织结构对项目的影响"><a href="#组织结构对项目的影响" class="headerlink" title="组织结构对项目的影响"></a>组织结构对项目的影响</h3><ul><li><p>以项目为基础的组织是指他们的业务主要由项目组成，分为两大类</p><ul><li>其主要收入是源自依照合同为他人履行项目的组织；</li><li>采用项目制进行管理的组织。</li></ul></li><li><p>组织结构</p><p>职能型组织优点：</p><ul><li>便于知识、技能和经验交流；</li><li>清晰的职业生涯晋升路线；</li><li>沟通、交流简单、责任和权限清晰；</li><li>重复性工作为主的过程管理。</li></ul><p>缺点：</p><ul><li>职能利益由于项目；</li><li>组织横向之间联系薄弱，部门间沟通、协调难度大；</li><li>项目经理缺少权利、权威；</li><li>项目管理发展方向不明，缺少项目基准。</li></ul><p>项目型组织优点：</p><ul><li>责权分明，利于统一指挥；</li><li>目标明确单一；</li><li>沟通简介、方便；</li><li>决策快。</li></ul><p>缺点：</p><ul><li>管理成本过高；</li><li>项目环境比较封闭，不利于沟通、技术知识共享；</li><li>员工缺乏事业上的连续性和保障。</li></ul><p>矩阵型组织优点：</p><ul><li>项目经理责任制、有明确的项目目标；</li><li>改善了项目经理对整体资源的控制；</li><li>及时影响；</li><li>获得职能组织更多的支持；</li><li>最大限度利用公司的稀缺资源；</li><li>降低了跨职能部门间的协调合作难度；</li><li>使质量、成本、时间等制约因素得到更好的平衡；</li><li>团队成员有归属感，士气高，问题少；</li><li>出现的冲突少，且易处理解决。</li></ul><p>缺点：</p><ul><li>管理成本增加；</li><li>多头领导；</li><li>难以检测和控制；</li><li>资源分配与项目优先问题产生冲突；</li><li>权利难以保持平衡。</li></ul><p>复合型组织</p><p>根据工作需要，一个组织内在运作项目时，或多或少同时包含多种组织形式。</p></li></ul><h3 id="信息系统项目的生命周期"><a href="#信息系统项目的生命周期" class="headerlink" title="信息系统项目的生命周期"></a>信息系统项目的生命周期</h3><ul><li>通用的生命周期结构具有以下特征：<ul><li>成本与人力投入在开始时较低，在工作执行期间达到最高，并在项目快要结束时迅速回落。</li><li>风险和不确定性在项目开始时最大，并在项目的整个生命周期中随着决策的制定与可交付成果的验收而逐步降低。</li></ul></li><li>阶段与阶段之间的关系有两种基本类型： 顺序关系、交叠关系<ul><li>在交叠关系中，一个阶段在前一个阶段完成前就开始，可作为进度压缩的一种技术，被称为“快速跟进”。</li><li>阶段交叠可能需要增加额外的资源来并行开展工作，可能增加风险，也可能因尚未获得前一阶段的准确信息就开始后续工作而造成返工</li></ul></li></ul><h3 id="信息系统项目典型生命周期模型"><a href="#信息系统项目典型生命周期模型" class="headerlink" title="信息系统项目典型生命周期模型"></a>信息系统项目典型生命周期模型</h3><ul><li><p>瀑布模型（用户需求明确）：可行性分析（计划）、需求分析、软件设计（概要设计、详细设计）、编码（含单元测试）、测试、运行维护 等六个阶段。</p></li><li><p>原型模型（用户需求不明确）：实际可行，具有最终系统的基本特征，构造方便、快速，造价低</p></li><li><p>螺旋模型是将原型模型实现的迭代特征与瀑布模型中控制的和系统化的方面结合起来，使得软件的增量版本的快速开发，适用于庞大复杂高风险的系统：制定计划、<strong>风险分析</strong>、实施工程、客户评估。</p></li><li><p>喷泉模型：主要用于描述面向对象的开发过程，体现面向对象开发过程的迭代和连续性</p></li><li><p>迭代模型：按阶段由高到低</p><table><thead><tr><th>核心工作流\阶段</th><th>初始</th><th>细化</th><th>构造</th><th>移交</th></tr></thead><tbody><tr><td>业务建模</td><td></td><td></td><td></td><td></td></tr><tr><td>需求获取</td><td></td><td></td><td></td><td></td></tr><tr><td>分析&amp;设计</td><td></td><td></td><td></td><td></td></tr><tr><td>实现</td><td></td><td></td><td></td><td></td></tr><tr><td>测试</td><td></td><td></td><td></td><td></td></tr><tr><td>部署</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>V模型 ：单元测试、集成测试、系统测试、验收测试，开发和测试同样重要，适用于需求明确和需求变更不频繁的情形。</p></li><li><p>敏捷开发：以用户需求进化为和核心，采用迭代、循序渐进的方法进行软件开发</p><ul><li>快速迭代</li><li>让测试人员和开发者参与需求讨论</li><li>编写可测试的需求文档</li><li>多沟通、尽量减少文档</li><li>做好产品原型</li><li>及早考虑测试</li></ul></li></ul><h3 id="单个项目的管理过程"><a href="#单个项目的管理过程" class="headerlink" title="单个项目的管理过程"></a>单个项目的管理过程</h3><ul><li>PDCA循环（戴明环）：计划（Plan）–执行（Do）–检查（Check）–行动（Act）循环</li><li>过程组：启动、计划、执行、监督与控制、收尾</li></ul><h2 id="项目立项管理"><a href="#项目立项管理" class="headerlink" title="项目立项管理"></a>项目立项管理</h2><ul><li>立项管理内容<ul><li>项目建议书</li><li>项目建议书的审批</li></ul></li><li>可行性研究 <ul><li>机会可行性研究</li><li>初步可行性研究</li><li>详细可行性研究</li></ul></li><li>项目评估与论证<ul><li>项目论证</li><li>项目评估</li></ul></li><li>项目招投标</li><li>供应商项目立项</li></ul><h3 id="立项管理内容"><a href="#立项管理内容" class="headerlink" title="立项管理内容"></a>立项管理内容</h3><p>项目立项一般包括：提交项目建议书、项目可行性研究、项目论证、项目评估、项目招投标、签订合同这几个阶段。</p><ul><li><p>项目建议书（立项申请）：项目建设单位向上级主管部门提交项目申请时必须的文件。包含内容：<strong>项目必要性、项目的市场预测、产品方案或服务的市场预测、项目建设必需的条件</strong></p></li><li><p>项目建议书的审批：项目审批部门在征求相关部门意见，并委托有资格的咨询机构评估后审核平复，或报国务院审批后下达批复（<strong>规模小的项目可以省略项目建议书环节，将其与项目可行性分析阶段合并</strong>）</p></li></ul><h3 id="可行性研究阶段"><a href="#可行性研究阶段" class="headerlink" title="可行性研究阶段"></a>可行性研究阶段</h3><p>可行性研究包括：投资必要性、技术的可行性、财务可行性、组织可行性、经济可行性、社会可行性、风险因素及对策。</p><ul><li>机会可行性：对投资项目或者投资方向提出建议，并对各种设想的项目和投资机会做出鉴定，其目的是激发投资者的兴趣，寻找最佳的投资机会</li><li>初步可行性：在项目意向确定后，对项目的初步估计，初步可行性研究可能出现4中结果<ol><li>肯定，对于比较小的项目甚至可以直接“上马”；</li><li>肯定，转入详细可行性研究，进行更深入更详细的分析研究；</li><li>展开专题研究，如建立原型系统，演示主要功能模块或者验证关键技术；</li><li>否定，项目应该“下马”。</li></ol></li><li>详细可行性：在初步可行性研究的基础上，详细评判，包含内容：<ol><li>概述：项目开发背景、必要性和经济意义等。</li><li>需求确定：调查客户需求、技术分析、确定项目规模、目标、产品、方案、发展方向等。</li><li>现有资源、设施情况分析。</li><li>设计（初步）技术方案。</li><li>项目实施进度计划建议。</li><li>投资估算和资金筹措计划。</li><li>项目组织、人力资源、技术培训计划。</li><li>经济和社会效益分析（效果评价）。</li><li>合作/协作方式。</li></ol></li><li>效益的预测与评估：效益量化及计算的6种方法：函数求解法；相关关系法；模糊数字法；专家意见法（德尔菲法）；成本降低法；利润增加法。</li><li>可行性研究报告的审批：可行性研究报告的编制内容与项目建议书内容有重大变更的，应重新报批项目建议书。初步设计方案和投资概算与可行性研究报告批复内容有重大变更或变更投资超出已批复总额10%的，应重新报批可行性研究报告。只要少量调整且额度未超出10%的，需要在提交项目初步设计方案和投资概算报告时以独立章节对调整部分进行定量补充说明。</li></ul><h3 id="项目的评估与论证"><a href="#项目的评估与论证" class="headerlink" title="项目的评估与论证"></a>项目的评估与论证</h3><ul><li><p>项目论证：“先论证，后决策 ”是现代项目管理的基本原则，项目论证应该围绕着市场需求、开发技术、财务经济三个方面展开调查和分析，市场是前提，技术是手段，财务经济是核心。</p></li><li><p>项目论证作用：</p><ul><li><p>项目论证是确定项目是否实施的依据。</p></li><li><p>项目论证是筹措资金、向银行贷款的依据。</p></li><li><p>项目论证是编制计划、设计、采购、施工以及机构设备、资源配置的依据。</p></li><li><p>项目论证是防范风险、提高项目效率的保证。</p></li></ul></li><li><p>项目论证一般分为以下三个阶段：机会研究；初步可行性研究；详细可行性研究三个阶段。对各个阶段的工作内容、费用、准确性要求；</p><table><thead><tr><th>阶段</th><th>工作内容</th><th>费用</th><th>误差</th></tr></thead><tbody><tr><td>机会研究</td><td>寻求投资机会，鉴别投资方向</td><td>占总投资的0.2% - 1%</td><td>±30%</td></tr><tr><td>初步可行性研究</td><td>初步判断项目是否有生命力，能否盈利</td><td>占总投资的0.25% - 1.5%</td><td>±20%</td></tr><tr><td>详细可行性研究</td><td>详细技术经济论证，在多方案比较的基础上选择出最优方案</td><td>中小项目占总投资的1% - 3%<br />大项目占总投资的0.2% - 1%</td><td>±10%</td></tr></tbody></table></li><li><p>项目论证的内容：<br>（1）项目运行环境评价；<br>（2）项目技术评价；<br>（3）项目财务评价；<br>（4）项目国民经济评价；<br>（5）项目环境评价；<br>（6）项目社会影响评价；<br>（7）项目不确定性和风险评价；<br>（8）项目综合评价等。</p></li><li><p>项目评估：项目评估指在项目可行性研究的基础上，由第三方（国家、银行或有关机构）进行的评估过程。其目的是审查项目可行性研究的可靠性、真实性和客观性，为银行的贷款决策或行政主管部门的审批决策提供科学依据。</p></li><li><p>项目评估的依据：<br>① 项目建议书及其批准文件<br>② 项目可行性研究报告<br>③ 报送单位的申请报告及主管部门的初审意见<br>④ 有关资源、配件、燃料、水、电、资金等方面的协议文件<br>⑤ 必须的其他文件和资料</p></li></ul><h3 id="项目的招投标"><a href="#项目的招投标" class="headerlink" title="项目的招投标"></a>项目的招投标</h3><ul><li><p>招标：</p><ul><li>公开招标：是指招标人以招标公告的方式邀请不特定的法人或者其他组织投标。</li><li>邀请招标：是指招标人以投标邀请书的方式邀请特定的法人或者其他组织投标。</li></ul></li><li><p>投标：</p><p>是指投标人应招标人的邀请，按照招标的要求和条件，在规定的时间内向招标人提交标书，争取中标的行为。<br>注意以下说法：投标文件是要约；招标文件是要约邀请；中标通知书是承诺。<br>为防止投标人在投标后撤标或在中标后拒不签订合同，招标人通常都要求投标人提供一定比例或金额的投标保证金。（投标保证金≤2%，履约保证金≤10%）</p><ul><li>《招投标法》第二十八条规定，投标人应当在招标文件要求提交投标文件的截止时间前，将投标送达投标地点。招标人收到投标文件后，应当签收保存，不得开启。投标人少于三个的，招标人应当依照本法重新招标。</li><li>在招标文件要求提交投标文件的截止时间后送达的投标文件，招标人应当拒收。以邮寄方式送达的，投标人必须留出邮寄时间，保证投标文件能够在截止日期之前送达招标人指定的地点，而不是以”邮戳为准“。在截止时间后送达的投标文件，即已经过了招标有效期的，招标人应当原封退回，不得进入开标阶段。</li></ul></li><li><p>评标：评标由评标委员会负责。评标委员会由具有高级职称或同等专业水平的技术、经济等相关领域专家、招标人和招标机构代表等5人以上单数组成，其中技术、经济等方面专家人数不得少于成员总数的2/3。评标委员会成员名单在评标结束公示前必须保密。</p></li><li><p>选定承建方：中标人的投标应当符合下列条件之一：</p><ul><li>能最大限度地满足招标文件中规定的各项综合评价标准。</li><li>能满足招标文件的实质性要求，并且经评审的投标价格最低；但是投标价格低于成本的除外。</li><li>招标人和中标人应当自中标通知书发出之日30日内，按照招标文件和中标人的投标文件订立书面合同。招标人和中标人不得再订立背离合同实质性内容的其他协议。</li><li>依法必须进行招标的项目，招标人应当自确定中标人之日起15天内，向有关行政监督部门提交招标情况的书面报告。（政府采购法规定，政府采购规定自签订后7日内。）</li></ul></li></ul><h3 id="供应商项目立项"><a href="#供应商项目立项" class="headerlink" title="供应商项目立项"></a>供应商项目立项</h3><p>系统集成商进行项目立项主要有以下几个原因：<br>（1）通过立项方式为项目分配资源<br>（2）通过立项方式确定合理的项目绩效目标，有助于提升人员的积极性<br>（3）以项目型工作方式，提升项目实施效率。系统集成供应商在进行项目内部立项时一般包括的内容有项目资源估算、项目资源分配、准备项目任务书和任命项目经理等。</p><h2 id="项目整体管理"><a href="#项目整体管理" class="headerlink" title="项目整体管理"></a>项目整体管理</h2><h3 id="项目整体管理概述"><a href="#项目整体管理概述" class="headerlink" title="项目整体管理概述"></a>项目整体管理概述</h3><p>​        项目整体管理知识领域包 括识别、确定、结合、统一与协调各项目管理过程组内不同过程与项目管理活动所需进行的各种过程和活动，是一个全局性的、综合性的管理。</p><h3 id="制定项目章程"><a href="#制定项目章程" class="headerlink" title="制定项目章程"></a>制定项目章程</h3><p>项目章程是正式批准项目的文件。由于项目章程要授权项目经理在项目活动中动用组织的资源，所以，项目经理任何时候都应在规划开始之前被委派，最好是在制定项目章裎之时。 </p><p>项目章程的批准，标志着项目的正式启动。在项目中；应尽早确认并任命项目经理，由于项目章程将授权项目经理在项目活动中使用组织资源，项目经理应该参与制定项目章程。 </p><p>项目由项目以外的人员批准，如发起人、项目管理办公室或项目组合指导委员会。项目章程经启动者签字，即标志着项目获得批准。</p><ul><li><p>输入：项目工作说明书、商业论证、协议（合同）、事业环境因素、组织过程资产</p></li><li><p>工具：专家判断、引导技术</p></li><li><p>输出：项目章程</p></li><li><p>项目章程内容：</p><ol><li>项目目的或批准项目的原因</li><li>可测量的项目目标和相关的成功标准</li><li>项目的总体要求</li><li>概括性的项目描述</li><li>项目的主要风险</li><li>总体里程碑进度计划</li><li>总体预算</li><li>项目审批要求（用什么标准评价项目成功，由谁对项目成功下结论，由谁来签署项目结束） </li><li>委派的项目经理及其职责和职权</li><li>发起人或其他批准项目章程的人员的姓名和职权 </li></ol></li><li><p>工作说明书：</p><p>​        工作说明书是对应由项目提供的产品或服务的文字说明。对于内部项目，项目发起人或赞助人根据业务需求、产品或服务要求提供一份工作说明书。对于外部项目，工作说明书属于顾客招标文件的一部分，如建议邀请书、信息请求、招标邀请书或合同中的一部分。工作说明书指明如下事项之一：</p><ol><li>业务需求—组织的业务需求可能基于培训需求、市场需求、技术进步、法律要求或政府标准。 </li><li>产品范围说明书—是项目创造的产品或服务要求与特征的文件。 </li><li>战略计划—所有的项目都应支持组织的战略目标。</li></ol></li><li><p>事业环境因素：</p><p>（1）组织或公司的文化与组成结构。 </p><p>（2）政府或行业标准（如管理部门的规章制度、产品标准、质量标准与工艺标准)。 </p><p>（3）基础设施(如现有的软件与硬件基础设施）。 </p><p>（4）现有的人力资源（如技能、专业与知识；例如设计、开发、法律、合同发包 与采购)。 </p><p>（5）人事管理（如雇用与解雇指导方针、员工业绩评价与培训记录)。 </p><p>（6）公司工作核准制度。 </p><p>（7）市场情况。 </p><p>（8）商业数据库（如标准的成本估算数据、行业风险研究信息与风险数据库）。 </p><p>（9）项目管理信息系统</p></li><li><p>组织过程资产：</p><p>​        组织过程资产反映了组织从以前项目中吸取的教训和学习到的知识，如完成的进 度表、风险数据和实现价值数据。可以归纳为2类：</p><p>（1）组织进行工作的过程与程序 </p><p>（2）组织整体信息存储检索知识库。</p></li><li><p>项目启动会</p><p>​        是一个项目的开始，一般由项目经理负责组织和召开。召开项目启动会议的主要目的在于使项目的主要利益相关者明确项目的目标、范围、需求、背景及各自的职责与权限。</p></li></ul><h3 id="制定项目管理管理计划"><a href="#制定项目管理管理计划" class="headerlink" title="制定项目管理管理计划"></a>制定项目管理管理计划</h3><p>​        一个项目管理计划一般包括项目范围管理计划、进度管理计划、成本管理计划、质量管理计划、过程改进计划、人员配备管理计划、沟通管理计划、风险管理计划、采购管理计划等分计划。项目管理计划详略均可。</p><p>​        <strong>项目计划编制工作流程</strong>：</p><p>​        （1）明确目标 </p><p>​        （2）成立初步的项目团队 </p><p>​        （3）工作准备与信息收集 </p><p>​        （4）依据模板、标准编写初步的概要的项目计划。 </p><p>​        （5）把上述计划纳入项目计划，然后对项目计划进行综合平衡、优化 </p><p>​        （6）项目经理负责组织编写项目计划 </p><p>​        （7）评审与批准项目计划 </p><p>​        （8）获得批准后的项目计划就是项目的基准计划。</p><p>​        <strong>编制项目计划所遵循的基本原则有</strong>： 目标的统一管理、方案的统一管理、过程的统一管理、技术工作与管理工作的统一协调、计划的统一管理、人员资源的统一管理、各干系人的参与、逐步精确。</p><h3 id="指导与管理项目的执行"><a href="#指导与管理项目的执行" class="headerlink" title="指导与管理项目的执行"></a>指导与管理项目的执行</h3><p>​        指导与管理项目执行过程要求项目经理和项目团队采取多种行动执行项目管理计划，完成项目范围说明书中明确的工作。</p><ul><li><p>项目管理系统：项目管理信息系统是由用于归纳、综合和传播项目管理程序输出的工具和技术组成。一个项目管理信息系统主要由两部分组成的—计划系统和控制系统。 </p><ol><li>配置管理系统：配置管理系统是整个项目管理信息系统的一个子系统。该系统包括的过程用于提交变更建议，追踪变更建议的审查与批准制度，确定变更的批准级别，以及确认批准的变更方法。配置管理系统在软件项目中具有非常重要的作用，一般目前常用的配置管理软件工具有CVS、VSS、ClearCase等。</li><li>变更控制系統：变更控制系统是正式形成文件的过程的全体，用于确定控制，改变和批准项目可交付成果和文件的方式、方法。</li></ol></li><li><p>工作绩效数据：是在执行项目工作的过程中，从每个正在执行的活动中收集到的原始观察结果和测量值。数据是指最底层的细节，将由其他过程从中提炼出项目信息。在工作执行过程中收集数据，再交由各控制过程做进一步分析。工作绩效数据包括但不限于以下项目。 </p><ol><li>表明进度绩效的状态信息。 </li><li>已经完成与尚未完成的可交付成果。 </li><li>已经开始与已经完成的计划活动。 </li><li>质量标准满足的程度。 </li><li>批准与已经开销的费用。 </li><li>对完成己经开始的计划活动的估算。</li><li>绩效过程中的计划活动实际完成百分比。</li><li>吸取并已记录且转入经验教训知识库的教训。</li><li>资源利用的细节。</li></ol></li></ul><h3 id="监控项目工作"><a href="#监控项目工作" class="headerlink" title="监控项目工作"></a>监控项目工作</h3><p>​        监视和控制项目工作过程是监视和控制启动、规划、执行和结束项目所需的各个过程。采取纠正或预防措施控制项目的实施效果。监视是贯穿项目始终的项目管理的一个方面。监视包括收集、测量并散发绩效信息，并评价测量结果和实施过程改进的趋势。连续的监视使项目管理团队能够洞察项目的状态是否正常，并识别任何可能要求给予特别注意的方面。</p><ul><li>进度预测：基于实际进展与进度基准的比较而计算出进度预测，即完工尚需时间估算，通常表示为进度偏差和进度绩效指数。</li><li>成本与此：基于实际进展与成本基准的比较而计算出的完工尚需估算，通常表示为成本偏差和成本绩效指数。</li><li>确认的变更：批准的变更是实施整体变更控制过程的结果。需要对它们的执行情况进行确认，以保证它们都得到正确的落实。确认的变更用数据说明变更已得到正确落实。</li><li>分析技术：在项目管理中，根据可能的项目或环境变量的变化，以及它们与其他变量之间的关系，采用分析技术来预测潜在的后果。例如，可用于项目的分析技术包括：回归分析；分组方法；因果分析；根本原因分析；预测方法（如时间序列、情景构建、模拟等）；失效模式与影响分析；故障树分析；储备分析；趋势分析；挣值管理；差异分析。 </li><li>工作绩效报告：是为制定决策、采取行动或引起关注而汇编工作绩效信息所形成的实物或电子项目文件。 </li></ul><h3 id="实施整体变更控制"><a href="#实施整体变更控制" class="headerlink" title="实施整体变更控制"></a>实施整体变更控制</h3><p>​        整体变更控制过程贯穿于项目的始终。由于项目很少会准确地按照项目管理计划进行，因而变更控制必不可少。 </p><ul><li><p>整体变更控制过程中的几个配置管理活动如下：</p><ol><li>配置识别。是确定与核实产品配置、标识产品与文件、管理变更，以及保持信息公开的基础。 </li><li>配置状态记录。捕捉、存储和评价有效地管理产品和产品信息所需的配置信息。 </li><li>配置核实与审计。查明配置文件中确定的性能与功能要求已经达到。 </li></ol></li><li><p>整体变更控制过程包括一个负责批准或否决变更请求的变更控制委员会。</p></li><li><p>变更日志：变更日志用来记录项目过程中出现的变更。应该与相关的干系人沟通这些变更及其对项目时间、成本和风险的影响。被否决的变更请求也应该记录在变更日志中。</p></li></ul><h3 id="结束项目或阶段"><a href="#结束项目或阶段" class="headerlink" title="结束项目或阶段"></a>结束项目或阶段</h3><p>​        结束项目或阶段是完结所有项目管理过程组的所有活动，以正式结束项目或阶段的过程。本过程的主要作用是，总结经验教训，正式结束项目工作，为开展新工作而释放组织资源。</p><ul><li>验收的可交付成果可能包括批准的产品规范、交货收据和工作绩效文件。在分阶段实施的项目或被取消的项目中 ，可能会包括未全部完成的可交付成果或中间可交付成果。</li></ul><h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><h3 id="项目范围管理概述"><a href="#项目范围管理概述" class="headerlink" title="项目范围管理概述"></a>项目范围管理概述</h3><p>项目范围管理就是要做范围内的事，而且只做范围内的事，既不少做也不多做。</p><p>项目范围管理需要做以下三个方面的工作： </p><p>（1）明确项目边界 </p><p>（2）对项目执行工作进行监控 </p><p>（3）防止项目范围发生蔓延。 </p><p><strong>项目的范围基准是经过批准的项目范围说明书、WBS和WBS词典。</strong><br>|类型|描述|<br>|–|–|<br>| 产品范围 | 是指产品或者服务所应该包含的功能。<br>产品范围是项目范围的基础，产品范围的定义是产品要求的描述。<br>产品范围是否完成，则根据产品是否满足了产品描述来判断。<br>产品范围描述是项目范围说明书的重要组成部分，因此，产品范围变更后，首先受到影响的是项目的范围。 |<br>| 项目范围 | 是指为了能够交付产品，项目所必须做的工作。<br> 项目范围的定义是产生项目管理计划的基础。<br> 判断项目范围是否完成，要以范围基准来衡量。 |</p><h3 id="规划范围管理"><a href="#规划范围管理" class="headerlink" title="规划范围管理"></a>规划范围管理</h3><p>​        规划范围管理是编制范围管理计划，书面描述将如何定义、确认和控制项目范围的过程，其主要作用是在整个项目中对如何管理范围提供指南方向。</p><ul><li>范围管理计划是制订项目管理计划过程和其他范围管理过程的主要输入，包含如下内容： <ul><li>如何制订项目范围说明书</li><li>如何根据范围说明书创建WBS</li><li>如何维护和批准WBS</li><li>如何确认和正式验收已完成的项目可交付成果</li><li>如何处理项目范围说明书的变更，该工作与实施整体变更控制过程直接相联。</li></ul></li><li>项目范围管理计划可能在项目管理计划之中，也可能作为单独的一项。 根据不同的项目，可以是详细的或者概括的，可以是正式的或者非正式的。</li><li>需求管理贯穿于整个过程，它的最基本的任务就是明确需求，并使项目 团队和用户达成共识，即建立需求基线。另外，还要建立需求跟踪能力联 系链确保所有用户需求都被正确地应用，并且在需求发生变更时，能够完 全地控制其影响范围，始终保持产品与需求的一致性。 需求管理计划描述在整个项目生命周期内如何分析、记录和管理需求。 主要包括以下内容：<ul><li>如何规划、跟踪和汇报各种需求活动 </li><li>需求管理需要使用的资源 </li><li>培训计划 </li><li>项目干系人参与需求管理的策略</li><li>判断项目范围与需求不一致的准则和纠正规程 </li><li>需求跟踪结构，即哪些需求属性将列入跟踪矩阵，并可在其他哪些项目文件中追踪 到这些需求 </li><li>可在其他哪些项目文件中追踪到这些需求</li><li>配置管理活动</li></ul></li></ul><h3 id="收集需求"><a href="#收集需求" class="headerlink" title="收集需求"></a>收集需求</h3><ul><li><p>收集需求是为实现项目目标而确定、记录并管理干系人的需要和需求的 过程，其作用是为定义和管理项目范围（包括产品范围）奠定基础。</p></li><li><p>需求的分类如下：</p><table><thead><tr><th>需求</th><th>描述</th></tr></thead><tbody><tr><td>业务需求</td><td>整个组织的高层级需要，例如，解决业务问题或抓住业务机会，以及实施项目的原因。</td></tr><tr><td>干系人需求</td><td>是指干系人或干系人群体的需要。</td></tr><tr><td>解决方案需求</td><td>是为满足业务需求和干系人需求，产品、服务或成果必须具备的特性、功能和特征。 解决方案需求又进一步分为功能需求和非功能需求。功能需求是关于产品能开展的行 为，例如，流程、数据，以及与产品的互动等。非功能需求是对功能需求的补充，是 产品正常运行所需的环境条件或质量，例如，可靠性、安全性、性能、服务水平等。</td></tr><tr><td>过渡需求</td><td>从当前状态过渡到将来状态所需的临时能力，例如，数据转换和培训需求。</td></tr><tr><td>项目需求</td><td>项目需要满足的行动、过程或其他条件。</td></tr><tr><td>质量需求</td><td>用于确认项目可交付成果的成功完成或其他项目需求的实现的任何条件或标准。QFD 对质量需求进行了细分，分为基本需求、期望需求和意外需求。</td></tr></tbody></table></li><li><p>收集需求的工具与技术主要有访谈、焦点小组、引导式研讨会、群体创 新技术、群体决策技术、问卷调查、观察、原型法、标杆对照、系统交互 图、文件分析等。</p><table><thead><tr><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>访谈</td><td>直接交谈</td></tr><tr><td>焦点小組</td><td>群体访谈，预先选定的干系人和主题专家</td></tr><tr><td>引导式研讨会</td><td>跨职能干系人，比单项会议更快地发现和解决问题</td></tr><tr><td>群体创新技术</td><td>1）头脑风暴：各抒己见 <br>2）名义小组技术：名义小组技术是头脑风暴法的深化应用 <br>3）德尔菲技术：专家背靠背 <br>4）概念/思维导图：引导新的创意 <br>5）亲和图：又称为KJ法，核心是头脑风暴法，是根据结果去找原因。<br> 6）多标准决策分析：是借助决策矩阵</td></tr><tr><td>群体决策</td><td>对多个未来行动方案进行评估</td></tr><tr><td>问卷调查</td><td>设计书面问题</td></tr><tr><td>观察</td><td>直接观察工作和实施流程</td></tr><tr><td>原型法</td><td>是指干系人或干系人群体的需要。</td></tr><tr><td>标杆对照</td><td>与其他类似组织比较，识别最佳实践。</td></tr><tr><td>系统交互图</td><td>可视化描述，系统与参与者之间的交互。</td></tr><tr><td>文件分析</td><td>分析文档，挖掘需求。</td></tr></tbody></table></li><li><p>需求文件描述各种单一的需求将如何满足与项目相关的业务需求。 需求文件的内容包括（但不限于）以下几个方面：</p><ul><li>（1）业务需求</li><li>（2）干系人需求</li><li>（3）解决方案需求</li><li>（4）项目需求</li><li>（5）过渡需求。 </li><li>（6）与需求有关的假设条件、依赖关系和制约因素。</li></ul></li><li><p>需求管理包括在产品开发过程中维持需求一致性和精确性的所有活动， 包括控制需求基线，保持项目计划与需求一致，控制单个需求和需求文档 的版本情况，管理需求和联系链之间的联系，或管理单个需求和项目其他 可交付物之间的依赖关系，跟踪基线中需求的状态。</p></li><li><p>可跟踪性是项目需求的一个重要特征，需求跟踪是将单个需求和其他元 素之间的依赖关系和逻辑联系建立跟踪，这些元素包括各种类型的需求、 业务规则、系统组件，以及帮助文件等。可验证性是需求的最基本特性。 每个配置项的需求到其涉及的产品（或构件）需求都要具有双向可跟踪 性。所谓双向跟踪，包括正向跟踪和反向跟踪，正向跟踪是指检查需求文 件中的每个需求是否都能在后继工作产品（成果）中找到对应点；反向跟 踪也称为逆向跟踪，是指检查设计文档、产品构件、测试文档等工作成果 是否都能在需求文件中找到出处。具体来说，需求跟踪涉及五种类型。</p></li><li><p>表示需求和其他产品元素之间的联系链的最普遍方式是使用需求跟踪（能力） 矩阵，需求跟踪矩阵是将产品需求从其来源连接到能满足需求的可交付成果的一 种表格。</p></li></ul><h3 id="定义范围"><a href="#定义范围" class="headerlink" title="定义范围"></a>定义范围</h3><ul><li>定义范围是制定项目和产品详细描述的过程，其主要作用是明确 所收集的需求哪些将包含在项目范围内，哪些将排除在项目范围外， 从而明确产品、服务或成果的边界。</li><li>项目范围说明书是对项目范围、主要可交付成果、假设条件和制约因素的描述。 项目范围说明书记录了整个范围，包括项目范围和产品范围，详细描述项目的可交 付成果，以及为提交这些可交付成果而必须开展的工作。</li><li>项目范围说明书包括如下内容： <ul><li>（1）产品范围描述。 </li><li>（2）验收标准。定义可交付成果通过验收前必须满足的一系列条件，以及验收的 过程。 </li><li>（3）可交付成果。 </li><li>（4）项目的除外责任。通常需要识别出什么是被排除在项目之外的。明确说明哪 些内容不属于项目范围，有助于管理干系人的期望。 </li><li>（5）制约因素。列出并说明与项目范围有关且限制项目团队选择的具体项目制约 因素。 </li><li>（6）假设条件。</li></ul></li><li>项目范围说明书的主要作用如下： <ul><li>（1）确定范围 </li><li>（2）沟通基础 </li><li>（3）规划和控制依据 </li><li>（4）变更基础 </li><li>（5）规划基础。 </li></ul></li></ul><h3 id="创建分解结构"><a href="#创建分解结构" class="headerlink" title="创建分解结构"></a>创建分解结构</h3><ul><li>创建WBS是将项目可交付成果和项目工作分解成较小的、更易于 管理的组件的过程，其主要作用是对所要交付的内容提供一个结构化的视图。 </li><li>工作包是位于WBS每条分支最底层的可交付成果或项目工作 组成部分，工作包应该非常具体，以便承担者能明确自己的任务、 努力的目标和承担的责任。工作包的大小需要遵循8/80原则。</li><li>较常用的WBS表示形式主要有分级的树型结构（组织结构图式） 和表格形式（列表式）。树型结构图的WBS层次清晰、直观性和结 构性强，但不容易修改，对大的、复杂的项目很难表示出项目的全 貌，用于中小型项目。表格形式的直观性比较差，但能够反映出项 目所有的工作要素，用于大型项目。</li><li>要将整个项目工作分解为工作包，通常需要开展以下活动：<ul><li>识别和分析可交付成果及相关工作。 </li><li>确定WBS的结构和编排方法。</li><li>自上而下逐层细化分解。 </li><li>为WBS组件制定和分配标识编码。</li><li>核实可交付成果分解的程度是恰当的。</li></ul></li><li>分解的原则<ul><li>功能或者技术原则。在创建WBS时，需要考虑将不同人员的工作分开。</li><li>组织结构。对于职能型的项目组织而言，WBS也要适应项目的组织结构形式。 </li><li>系统或者子系统。总的系统划分为几个主要的子系统，然后对每个子系统再进 行分解。</li></ul></li><li>在进行WBS分解时，可以有如下三种方式： <ul><li>将项目生命周期的各阶段作为分解的第二层 </li><li>主要可交付成果作为分解的第二层 </li><li>子项目作为分解的第二层</li></ul></li><li>在分解的过程中，应该注意以下8个方面。<ul><li>WBS必须是面向可交付成果的。</li><li>WBS必须符合项目的范围。 </li><li>WBS的底层应该支持计划和控制。</li><li>WBS中的元素必须有人负责，而且只由一个人负责。 </li><li>WBS作为指导而不是原则，应控制在4〜6层。 </li><li>WBS应包括项目管理工作,也要包括分包出去的工作。</li><li>WBS的编制需要所有项目干系人的参与。</li><li>WBS并非是一成不变。</li></ul></li><li>当一个项目的WBS分解完成后，项目干系人对完成的WBS应该给予确认， 并对此达成共识。WBS的目的和用途主要体现在以下8个方面。<ul><li>明确和准确说明项目范围 </li><li>清楚地定义项目的边界 </li><li>可以确定完成项目所需要的技术和人力资源 </li><li>提高估算的准确性 </li><li>确定项目进度和控制的基准 </li><li>将项目工作和项目的财务账目联系起来 </li><li>确定工作内容和工作顺序 </li><li>有助于防止需求蔓延</li></ul></li></ul><h3 id="确认范围"><a href="#确认范围" class="headerlink" title="确认范围"></a>确认范围</h3><ul><li><p>确认范围是正式验收项目已完成的可交付成果的过程，其主要作用是使验 收过程具有客观性，同时，通过验收每个可交付成果，提高最终产品、服务 或成果获得验收的可能性。 </p></li><li><p>确认范围包括与客户或发起人一起审查可交付成果，确保可交付成果已圆 满完成，并获得客户或发起人的正式验收。</p></li><li><p>确认范围应该贯穿项目的始终，一般步骤如下：</p><ul><li>（1）确定需要进行范围确认的时间。 </li><li>（2）识别范围确认需要哪些投入。 </li><li>（3）确定范围正式被接受的标准和要素。</li><li>（4）确定范围确认会议的组织步骤。</li><li>（5）组织范围确认会议。 通常情况下，在确认范围前，项目团队需要先进行质量控制工作，例如，在确 认软件项目的范围之前，需要进行系统测试等工作，以确保确认工作的顺利完成。</li></ul></li><li><p>项目干系人进行范围确认时，一般需要检查以下6个方面的问题。</p><ul><li>（1）可交付成果是否是确定的、可确认的。 </li><li>（2）每个可交付成果是否有明确的里程碑，里程碑是否有明确的、可辨别的事 件。</li><li>（3）是否有明确的质量标准。 </li><li>（4）审核和承诺是否有清晰的表达。</li><li>（5）项目范围是否覆盖了需要完成的产品或服务进行的所有活动，有没有遗漏 或者错误</li><li>（6）项目范围的风险是否太高，管理层是否能够降低可预见的风险发生时对项 目的冲击</li></ul></li><li><p>核实产品是针对产品是否完成，在项目（或阶段）结束时由发起人或客户来验证，强调产品是否完整。</p></li><li><p>确认范围是针对项目可交付成果，由客户或发起人在阶 段末确认验收的过程。 </p></li><li><p>确认范围与质量控制，与的不同之处在于：</p><table><thead><tr><th>类型</th><th>不同点</th></tr></thead><tbody><tr><td>确认范围</td><td>（1）主要强调可交付成果获得客户或发起人的接受 <br>（2）一般在阶段末尾进行 <br>（3）由外部干系人（客户或发起人）进行检查验收。</td></tr><tr><td>质量控制</td><td>（1）可交付成果的正确性，并符合质量标准<br> （2）在确认范围前进行，也可同时进行<br> （3）属内部检查，由执行组织的相应质量部门实施</td></tr></tbody></table></li><li><p>确认范围与项目收尾，确认范围与项目收尾的不同之处在于：</p><table><thead><tr><th>类型</th><th>不同点</th></tr></thead><tbody><tr><td>确认范围</td><td>核实与接受可交付成果</td></tr><tr><td>项目收尾</td><td>流程性工作，验收产品</td></tr></tbody></table></li></ul><h3 id="控制范围"><a href="#控制范围" class="headerlink" title="控制范围"></a>控制范围</h3><ul><li>控制范围是监督项目和产品的范围状态、管理范围基准变更的过程，其主要作 用是在整个项目期间保持对范围基准的维护。</li><li>范围变更控制的主要工作如下： <ul><li>（1）影响导致范围变更的因素，并尽量使这些因素向有利的方面发展。</li><li>（2）判断范围变更是否已经发生。</li><li>（3）范围变更发生时管理实际的变更，确保所有被请求的变更按照项目整体变 更控制过程处理。</li></ul></li></ul><h2 id="项目进度管理"><a href="#项目进度管理" class="headerlink" title="项目进度管理"></a>项目进度管理</h2><h3 id="规划进度管理"><a href="#规划进度管理" class="headerlink" title="规划进度管理"></a>规划进度管理</h3><ul><li>是为实施项目进度管理制定政策、程序，并形成文档化的项目进 度管理计划的过程。</li><li>作用：为如何在整个项目过程中管理、执行和控制 项目进度提供指南和方向。</li></ul><h3 id="定义活动"><a href="#定义活动" class="headerlink" title="定义活动"></a>定义活动</h3><ul><li>活动：为完成工作包所需进行的工作，是实施项目时安排工作的最基本的工作 单元。活动与工作包是1对1或多对1的关系，即有可能多个活动完成一个工作包 </li><li>定义活动：识别和记录为完成项目可交付成果而需采取的所有活动；将工作包分解为活动，作为对项目工作进行估算、进度规划、执行、监督和控 制的基础；自顶向下，逐步细化。渐进明细，更加可控</li><li>分解：分解是一种把项目范围和项目可交付成果逐步划分为更小、更便于管理的组成部分 的技术 </li><li>通过工作分解结构（WBS），将项目分解为一系列更小更易管理的活动，定义活动通常与工作分解相结合，这些小的活动是具体、可实施的详细任务</li><li>活动清单：应当将所有活动，编制成一个明确 的活动清单。活动清单应当采取文 档的形式，以便项目其它过程使用 和管理活动清单应当使用团队成员 明确自己的工作和责任。</li><li>里程碑：活动被划分为更细的层次同时产生 了大量的控制点是项目中的重大事 项，通常指一个或多个交付物的完 成突出特征：达到此里程碑的标准 没有歧义。</li></ul><h3 id="排列活动顺序"><a href="#排列活动顺序" class="headerlink" title="排列活动顺序"></a>排列活动顺序</h3><table><thead><tr><th>排列活动顺序</th><th>识别和记录项目活动之间的关系的过程</th></tr></thead><tbody><tr><td>主要作用</td><td>定义工作之间的逻辑顺序，以便在既定的所有项目制约因素下获得最高的效率</td></tr><tr><td>特点</td><td>除了首尾两项活动之外，每项活动和每个里程碑都至少有一项紧前活动和一项紧后</td></tr><tr><td>活动排序</td><td>可以由项目管理软件、 手动或者自动化工具来完成</td></tr></tbody></table><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>1.进度管理计划<br>2.活动清单<br>3.活动属性<br>4.里程碑清单<br>5.事业环境因素<br>6.项目范围说明书</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>1.项目进度网络图<br>2.项目文件更新（ 活动清单、活动属性、 里程碑清单、风险登记册）</p><h4 id="工具与技术"><a href="#工具与技术" class="headerlink" title="工具与技术"></a>工具与技术</h4><ul><li><p>前导图法（单代号网络图）<br>包括4种类型的依赖关系：<br>（1）结束-开始的关系（F-S型）<br>（2）结束–结束的关系（F-F型）<br>（3）开始-开始的关系（S-S型）<br>（4）开始–结束的关系（S-F型<br>每个节点的活动会有如下几个时间：<br>（1）最早开始时间（ES），某项活动能够开始的最早时间。<br>（2）最早结束时间（EF），某项活动能够完成的最早时间。EF=ES+工期<br>（3）最迟结束时间（LF）。为了使项目按时完成，某项活动必须完成的最迟时间。<br>（4）最迟开始时间（LS）。为了使项目按时完成，某项活动必须开始的最迟时间。<br>LS = LF - 工期 </p></li><li><p>箭线图法:是用箭线表示活动、节点表示事件的一种网络图绘制方法，也被 称作双代号网络图。在箭线图法中，活动的开始（箭尾）事件叫作该活动的 紧前事件，活动的结束（箭头）事件叫该活动的紧后事件</p></li><li><p>虚活动：在网络图中由一个虚 箭线表示。虚活动不消耗时间， 也不消耗资源，只是为了弥补 箭线图在表达活动依赖关系方 面的不足。</p></li><li><p>箭线图法三个基本原则：<br>（1）网络图中每一活动和每一事件都必须有唯一的一个代号，即网 络图中不会有相同的代号。<br>（2）任两项活动的紧前事件和紧后事件代号至少有一个不相同，节 点代号沿箭线方向越来越大<br>（3）流入（流出）同一节点的活动，均有共同的紧后活动（或紧前 活动）</p></li><li><p>提前量和滞后量</p><ul><li>提前量 是相对于紧前活动，紧后活动可以提前的时间量。</li><li>滞后量 是相对于紧前活动，紧后活动需要推迟的时间量。</li></ul></li></ul><h3 id="估算活动资源"><a href="#估算活动资源" class="headerlink" title="估算活动资源"></a>估算活动资源</h3><table><thead><tr><th>估算活动资源</th><th>是估算执行各项活动所需的材料、人员、设备或用品的种类和数量的过程</th></tr></thead><tbody><tr><td>作用</td><td>明确完成活动所需的资源种类、数量和特性，以便做出更 准确的成本和持续时间估算</td></tr><tr><td>估算资源活动与估算成本过程紧密相关</td><td></td></tr><tr><td>资源日历是表明每种具体资源的可用工作日或工作班次的日历</td><td></td></tr><tr><td>活动资源需求明确了工作包中每个活动所需的资源类型和数量</td><td></td></tr><tr><td>资源分解结构（RBS）是资源依类别和类型的层级展现</td><td></td></tr></tbody></table><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>1.进度管理计划<br>2.活动清单<br>3.活动属性<br>4.资源日历<br>5.风险登记册<br>6.活动成本估算<br>7.事业环境因素<br>8.组织过程资产</p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>1.活动资源需求<br>2.资源分解结构<br>3.项目文件更新 （活动清单 、活动属性、资源日历）</p><h3 id="估算活动持续时间"><a href="#估算活动持续时间" class="headerlink" title="估算活动持续时间"></a>估算活动持续时间</h3><ul><li>估算活动持续时间：根据资源估算的结果，估算完成单项活动所需工 作时段数的过程</li><li>本过程的作用：确定完成每个活动所需花费的时间量，为制定进度计 划过程提供主要输入。</li></ul><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>1）进度管理计划<br>2）活动清单<br>3）活动属性<br>4）活动资源需求<br>5）资源日历<br>6）项目范围说明书<br>7）风险登记册<br>8）资源分解结构<br>9）事业环境因素<br>10）组织过程资产</p><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>1）活动持续时间估算<br>2）项目文件更新 （ 活动属性 、 为估算活动持续时间而制定的假设条件）</p><h4 id="估算步骤"><a href="#估算步骤" class="headerlink" title="估算步骤"></a>估算步骤</h4><ul><li>应该由项目团队叫最熟悉具体活动的个人或叫组来进行估算<ol><li>估算出具体活动的工作 量</li><li>估算出计划投入该活动 的资源数量</li><li>估算出完成该活动持续 时间</li></ol></li></ul><h4 id="工具与技术-1"><a href="#工具与技术-1" class="headerlink" title="工具与技术"></a>工具与技术</h4><ul><li><p>专家判断 通过借鉴历史信息，专家判断能提供持续时间估算所需信息，根据以往类似 项目经验，给出活动持续时间上限。也可用于决定是否需要联合使用多种估 算方法，以及如何协调各种估算方法之间的差异</p></li><li><p>三点估算 也叫PERT法(Program Evaluation and Review Technique)， 在估算每项活动的工期时都考虑三种可能性，即最悲观的工 期、最可能的工期和最乐观的工期，再据此计算出该活动的 期望工期（平均工期）</p></li><li><p>参数估算 是一种基于历史参数和项目参数，利用历史数 据之间的统计关系以及与其他参数变量来计算 成本或持续时间的估算技术。常用的参数估算法有回归分析。</p></li><li><p>类比估算  是指一种自上而下的成本估算方法， 它通过比照已完成的类似项目的实 际持续时间（成本），估算出新项 目持续时间（成本）。 类比估算法是最简单实质上是一种专家判断法。</p></li><li><p>群体决策 技术 调动团队成员参与， 提高估算准确度。</p><table><thead><tr><th>三点估算法</th><th>估计活动的最可能、最乐观以及最悲观时间，通过设置权重，运用统计规律降低历时估算的不确定性</th></tr></thead><tbody><tr><td>最可能时间</td><td>在为计划活动分派的资源、资源生产效率以及资源的可利用性都充分考虑的前提下，对计划活动估算的持续时间</td></tr><tr><td>最乐观时间</td><td>当估算最可能持续时间的依据条件形成最有利的组合时，估算出来的持续时间</td></tr><tr><td>最非观时间</td><td>当估算最可能持续时间的依据条件形成最不利的组合时，估算出来的持续时间</td></tr></tbody></table></li><li><p>适用场景：</p><ul><li><p>在PERT中，某些或全部活动持续时间事先我不能完全肯定，是利用网络顺序逻辑关系和加权历时来估算项目历时的重要技术 </p></li><li><p>这种网络计划方法适用于不可预知因素较多、从未做过的新项目或者复杂项目</p></li></ul></li><li><p>专家判断 以前做过该类轮子的绘制，一般需要10天</p></li><li><p>类比估算 我绘制过3次类似轮子，用了都没到10天</p><ol><li>类比法适合评估一些与历史项目在应用领域、环境和复杂度相似的项目，通过新项目与历史项目的比较得到估计数据。 </li><li>因此估计结果的精确度取决于历史项目数据的完整性和准确度 </li><li>项目详细信息不足时，例如在项目的早期阶段，就经常使用这种技术来估算项目持续时间，但准确性较低</li></ol></li><li><p>参数估算 将应当完成的工作量乘以生产率时，就可以估算出活动历时。</p></li><li><p>参数估算的准确性 取决于参数模型的成熟度和基础数据的可靠性</p></li><li><p>参数估算使用 参数数估算可以针对整个项目或项目中的某个部分，并可与其它估算方法联合使用 </p></li></ul><h3 id="制定进度计划"><a href="#制定进度计划" class="headerlink" title="制定进度计划"></a>制定进度计划</h3><ul><li>制定进度计划是分析活动顺序、持续时间、资源需求和进度制约因素，创建项目进度模型的过程。 </li><li>作用：把活动、持续时间、资源、资源可用性和逻辑关系代入进度规划工具，从而形成包含各个项目活动的计划日期的进度模型</li></ul><h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><ol><li>进度管理计划</li><li>活动清单 </li><li>活动属性 </li><li>项目进度网络图 </li><li>活动资源需求</li><li>资源日历</li><li>活动持续时间估算</li><li>项目范围说明书 </li><li>风险登记册 </li><li>项目人员分配 </li><li>资源分解结构</li><li>事业环境因素</li><li>组织过程资产</li></ol><h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><ol><li>进度基准</li><li>项目进度计划</li><li>进度数据</li><li>项目日历</li><li>项目管理计划更新 <ul><li>进度基准</li><li>进度管理计划 </li></ul></li><li>项目文件更新<ul><li>活动资源需求</li><li>活动属性</li><li>日历</li><li>风险登记册</li></ul></li></ol><h4 id="工具与技术-2"><a href="#工具与技术-2" class="headerlink" title="工具与技术"></a>工具与技术</h4><ul><li>关键路径的定义：不考虑任何资源限制的情况下，沿项目进度网络路径进行顺 推与逆推分析，计算出全部活动理论上的最早开始和完成日期、最迟开始和完成日期。</li><li>关键路径<ul><li>网络图中最长工期的那条路线，决定项目最短完成时间 </li><li>总浮动时间为0或负数</li><li>关键路径上的活动叫关键活动</li><li>关键路径可能有多条</li></ul></li><li>次关键路径<ul><li>时长与关键路径最接近的路线 </li><li>项目经理应该时刻关注次关 键路径，因为在优化工期的 时候，它最有可能变为关键路径，而影响项目工期</li></ul></li><li>关键路径的特点</li></ul><ol><li>在网络图的各条路径中，总工期最长</li><li>可以有两条甚至两条以上</li><li>在进度计划的优化或项目实施过程中， 关键路径可能发生变化</li><li>关键路径越多， 项目的风险就越大，就越难管理</li></ol><ul><li><p>关键路径的识别 用有方向的线段标出各结点的紧前活动和紧后活动的关系，使之成为一个 有方向的网络图</p></li><li><p>用正推法和逆推法计算出各个活动的最早开始时间和最早完工时间，最晚开始时间和最迟完工时间，并计算出各个活动的自由时差</p></li><li><p>找出所有时差为零的活动所组成的路线，即为关键路径识</p></li><li><p>别出次关键路径，为工期优化提供参考</p></li><li><p>七格图</p><ul><li>ES:最早开始时间 </li><li>EF:最早结束时间 </li><li>DU:活动时长 </li><li>LS:最晚开始时间 </li><li>LF:最晚结束时间 </li><li>FF:自由时差 </li><li>TF:总时差</li></ul></li><li><p>自由时差：在不延误紧随活动的最早开始日期的情况下，该活动可以推迟的时间； </p></li><li><p>总时差：在不延误项目完成日期的情况下，该活动自其最早起可以延误的时间。</p></li><li><p>浮动时间(Float/Slack)</p><ul><li>总浮动时间：在不延误项目完成日期或违反进度制约因素的前提 下，某进度活动可以推迟的总时间量（从其最早开 始日期起算）。采用关键路径法，计算最早完成日 期与最晚完成日期之间的差值，即得到总浮动时间。</li><li>自由浮动时间：在不延误其紧后进度活动最早开始日期的前提下， 某进度活动可以推迟的时间量。</li><li>项目浮动时间：一个项目可以延误但不会影响外界要求的项目完工 时间的时间，不耽误工期</li></ul></li><li><p>进度压缩技术</p><ul><li>赶工：在尽量少增加项目费用的前提下，最大限度的压缩 项目的总工期，赶工意味着用成本来争取时间，此 时优先考虑的是缩短那些位于项目关键路径中的活 动持续时间</li><li>快速跟进：在通常情况下按先后顺序进行的活动并行的方式执 行，压缩项目的工期，并行往往会造成返工，增加 项目风险</li><li>次关键路径演变： 在这两种情况下，都要注意防止次关键路径变为关 键路径 <table><thead><tr><th></th><th>赶工</th><th>快速跟进</th></tr></thead><tbody><tr><td>作用</td><td>在不改变项目范围的情况，都可以加快进度工期</td><td></td></tr><tr><td>方法</td><td>通过增加资源减少活动的持续时间， 不改变活动的逻辑关系</td><td>不增加资源投入，将后续活动提前执行改变活动的</td></tr><tr><td>成本</td><td>增加当前资源（成本）投入</td><td>不增加当前资源（成本）投入，但是未来风险可能导致成本增加</td></tr><tr><td>风险</td><td>导致风险增加，属于局部风险</td><td>导致风险增加，属于全局风险</td></tr><tr><td>活动</td><td>关键路径活动，强调单位费率最低的活动</td><td>关键路径活动</td></tr></tbody></table></li></ul></li><li><p>在不缩减项目范围的前提下，缩短进度工期，满足进度目标。</p></li><li><p>资源平衡</p></li></ul><ol><li>初始计划所需要的资源往往超过实际可利用资源，尝试在项目进度计划和实际可用资源之间进行平衡和优化 </li><li>用于已经用关键路径法分析过的进度模型中，均匀的使用资源</li><li>将稀缺资源（关键资源只在一定时间/只有一定数量可用） 分配到关键路径上</li><li>资源决定法：项目进度比预期长（受资源限制） </li><li>使用资源从非关键路径重新分配到关键路径上，是使用项 目最可能与初始进度一致的方法</li></ol><ul><li>在用关键路径法编制出理论上可行的进度计划后，就需要考虑资源 限制了。应该采用资源优化技术，根据资源限制来调整项目进度计划， 或为了提高资源使用效率而调整项目进度计划。 </li><li>例如：没有足够的资源来实施原来计划的工作任务（出现资源短缺），就需要进行资源平衡； </li><li>如果在原计划中各个时段所需要的资源数量起伏太大，就需要进行资源平滑，使各时段所需的资源数相对平稳。</li><li>如果出现资源短缺，就需要做资源平衡。资源平衡往往导致关键 路径的改变，导致工期的延长。</li><li>如果各事期资源需求量起伏太大，就需要做资源平滑。资源平滑 是在各浮动时间允许的范围内，在项目不同时间段调剂资源分配，不 会导致项目工期的延长，一般也不会改变关键路径。</li><li>资源平衡包括资源平滑。资源平滑是资源平衡的一种特殊 形式,主要工作削峰填谷。</li><li>关键链<ul><li>帕金森定律：工作会自动地膨胀占满所有可用的时 间。如果安排给一个任务的时间有富余，人们就会放慢节奏消耗掉所有富余 时间，怎么办？</li><li>解决方案：最早开始法则，所有活动都越早越好，取消每个活动的弹性时间，集中到路径末段，就是准备项目缓冲。</li></ul></li></ul><h3 id="控制进度"><a href="#控制进度" class="headerlink" title="控制进度"></a>控制进度</h3><ul><li>项目进度控制：是依据项目进度计划，对项目的实际进展 情况进行控制，使项目能够按时完成</li></ul><ol><li>定期收集项 目完成情况的数据，将实际完成与计划对比</li><li>分析进度， 找出偏离达到纠偏要求的地方</li><li>确哪定些应具采体取纠正措施</li><li>修改计划， 将纠正措施列入计划</li><li>重新估算项目进度，评 估采取纠正措施的效果</li></ol><h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><ol><li>项目管理计划 </li><li>项目进度计划</li><li>工作绩效数据</li><li>项目日历</li><li>进度数据</li><li>组织过程资产</li></ol><h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><ol><li>工作绩效信息 </li><li>进度预测</li><li>变更请求</li><li>项目管理计划更新 </li><li>项目文件更新 <ul><li>进度数据</li><li>项目进度计划</li><li>风险登记册</li></ul></li><li>组织过程资质更新<ul><li>偏差原因</li><li>纠正措施</li><li>其它经验教训</li></ul></li></ol><ul><li>变更管理</li><li>变更的源头：<ul><li>领导层：不断变化的想法与欲望 </li><li>项目团队：成员技能与团队冲突 </li><li>项目优先级：市场变化 资源变化 其他项目影响</li></ul></li></ul><h2 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h2><p>就是要确保在批准的预算内完成项目</p><h3 id="成本分类"><a href="#成本分类" class="headerlink" title="成本分类"></a>成本分类</h3><ul><li>可变成本 随生产量或工作量而变的成本，如人员工资、消耗的 原材料等</li><li>固定成本 不随生产规模变化的非重复成本，如设备费用、场地 租赁费用等</li><li>直接成本 能够直接归属于项目工作的成本，如项目组差旅费用、 项目组人员工资和奖金、项目使用的物质等</li><li>间接成本 一般管理费用科目或几个项目共同分担的成本，如员 工福利、保安费用、行政部门和财务部门费用等</li></ul><hr><ul><li>沉没成本 <ul><li>指业已发生或承诺、无法回收的成本支出，如因失误造成的不可收回的投资。</li><li>沉没成本是一种历史成本，对现有决策而言是不可控的成本，不会影响当前行为或未来决策。</li><li>在投资决策时应排除沉没成本的干扰。</li></ul></li><li>机会成本 如果选择另一个项目而放弃这一项目收益所引发的成本，为了选择A，放弃B，B的收益就是A的机会成本。</li></ul><hr><ul><li>储备<ul><li>应急储备：（单项目-已知的未知）和管理储备（公司 级-未知的未知），主要为防范风险预留的成本。 </li><li>管理储备：是一个单列的计划出来的成本，以备未来 不可预见的事情发生时使用。包含成本或进度储备， 以降低偏离成本或进度的风险。 </li></ul></li><li>基准 成本基准：是经批准的按时间安排的成本支出计划， 并随时反映了经批准的项目成本变更，被用于度量 和监督项目的实际执行成本</li><li>质量成本 <ul><li>达到产品或服务质量而进行的全部工作所发生的所有 成本，包括为使所生产的产品或服务符合要求的所有 工作及返工的工作。 </li><li>分为质量保证成本（预防）和质量故障成本（损失）， 在项目的前期和后期，质量成本较高。<table><thead><tr><th>阶段</th><th>描述</th><th></th></tr></thead><tbody><tr><td>规划成本</td><td>确定如何估算、预算、管理、 监督和控制项目成本的过程。</td><td>一谋：规划成本</td></tr><tr><td>估算成本</td><td>对完成项目活动所需货币资源 进行近似估算的过程。</td><td>二估（估算成本【工作包或活 动成本】</td></tr><tr><td>制定预算</td><td>汇总所有单个活动或工作包的 估算成本，建立一个经批准的 成本基准的过程。</td><td>三定（制定预算【求重点、定 基准—用来考核的】）</td></tr><tr><td>控制成本</td><td>监督项目状态，以更新项目成 本和管理成本基准变更的过程。</td><td>四控（控制成本求挣值—找偏 差）</td></tr></tbody></table></li></ul></li></ul><h3 id="规划成本"><a href="#规划成本" class="headerlink" title="规划成本"></a>规划成本</h3><ul><li>规划成本是确定如 何估算、预算、管 理、监督和控制项 目成本的过程</li><li>在成本管理计划中规定：（1）计量单 位（2）精确度（3）准确度（4）组织 程序链接（5）控制临界值（6）绩效 测量规则（7）报告格式 （8）过程描 述（9）其他细节</li></ul><h4 id="输入-5"><a href="#输入-5" class="headerlink" title="输入"></a>输入</h4><p>① 项目管理计划 ② 项目章程 ③ 事业环境因素 ④ 组织过程资产</p><h4 id="输出-5"><a href="#输出-5" class="headerlink" title="输出"></a>输出</h4><p>成本管理计划</p><h3 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h3><ul><li>对完成项目活动所需资金进行近似估算的过程</li></ul><ol><li>识别并分析成本的构成科目。</li><li>根据已识别的项目成本构成科目，估算 每一科目的成本大小</li><li>分析估算成本结果，找出各种可以相互 替代的成本，协调各种成本之间的比例关系</li></ol><h4 id="输入-6"><a href="#输入-6" class="headerlink" title="输入"></a>输入</h4><p>① 成本管理计划 ② 人力资源管理计划 ③ 范围基准 ④ 项目进度计划 ⑤ 风险登记册 ⑥ 事业环境因素 ⑦ 组织过程资产</p><h4 id="输出-6"><a href="#输出-6" class="headerlink" title="输出"></a>输出</h4><p>① 活动估算成本 ② 估算依据 ③ 项目文件更新 (风险登记册)</p><h4 id="工具（三单估算）"><a href="#工具（三单估算）" class="headerlink" title="工具（三单估算）"></a>工具（三单估算）</h4><ul><li>三角分布：cE= (cO+cM+cP) / 3 </li><li>贝塔分布：cE= (cO+ 4cM+cP) / 6<table><thead><tr><th></th><th>类比估算（自上而下）</th><th>自下而上</th><th>参数估算</th></tr></thead><tbody><tr><td>定义</td><td>对照已经完成的类似项目 的实际成本，估算出新项 目的总成本。这又被称之 为自上而下法。是一种专 家评定法</td><td>基于WBS体系，先估算 各个单位活动或工作包 的独立成本然后将单个 的估算自下而上层层进 行汇总，得到项目的整 体成本</td><td>将项目特征用于数学模 型来预测项目成本。</td></tr><tr><td>优点</td><td>方法简易，省时省力，计 算成本低</td><td>估算成本比较准确，符 合实际</td><td>信息采集量小，省时节</td></tr><tr><td>缺点</td><td>信息量模糊，估算准确度 低</td><td>信息采集量大，耗时费工成本高</td><td>不校验则准确性无法保证，无法适应变</td></tr><tr><td>适用场景</td><td>在下述情况下非常可靠； 以前项目在事实上而不 仅仅是在外表上相似 进行估算的个人或团体 具有所需要的专门知识。 费用最低，可靠性最差</td><td>成本和精度受单个活动 或工作包大小复杂程度 的制约，较小的活动在 提高估算精度的同时将 增加成本</td><td>在下述情况下非常可靠 用于建立模型的历史 信息是准确的； 在模型中使用的参数 是很容易量化 模型可按比例调整</td></tr></tbody></table></li></ul><h3 id="制定预算"><a href="#制定预算" class="headerlink" title="制定预算"></a>制定预算</h3><ul><li>活动估算成本是对完成项目工作可能需要的成本的量化估算 </li><li>项目预算:包括经批准用于项目的全部资金。 </li><li>成本基准:是经过批准且按时间段分配的项目预算，但不包括管理储备</li></ul><h4 id="输入-7"><a href="#输入-7" class="headerlink" title="输入"></a>输入</h4><p>① 成本管理计划 ② 范围基准 ③ 活动成本估算 ④ 估算依据 ⑤ 项目进度计划 ⑥ 资源日历 ⑦ 风险登记册 ⑧ 协议 ⑨ 组织过程资产</p><h4 id="输出-7"><a href="#输出-7" class="headerlink" title="输出"></a>输出</h4><p>① 成本基准 ② 项目资金需求 ③ 项目文件更新 （风险登记册 、活动成本估算 、项目进度计划）</p><table><thead><tr><th></th><th>应急储备</th><th>管理储备</th></tr></thead><tbody><tr><td>属于的过程</td><td>估算成本过程</td><td>制定预算过程</td></tr><tr><td>用来应对哪些事件</td><td>预期但不确定的事件， 即：已知的未知事件</td><td>未计划但可能存在的项目 范围 和成本的变化，即：未知的未知 事件</td></tr><tr><td>是否属于成本基准</td><td>属于成本基准</td><td>不属于成本基准，但属于 项目 总预算</td></tr><tr><td>项目经理的处理权限</td><td>项目经理可自由使用</td><td>必须经批准才可动用</td></tr><tr><td>是否纳入挣值计算</td><td>纳入挣值计算</td><td>不纳入挣值计算</td></tr></tbody></table><h3 id="控制成本"><a href="#控制成本" class="headerlink" title="控制成本"></a>控制成本</h3><ul><li>控制成本：监督项目状态，以更新项目成本：管理成本基准变更的过程 包括以下事项：</li></ul><ol><li>对造成成本基准变更的因素施加影响。</li><li>确保所有变更请求都得到及时处理。</li><li>当变更实际发生时，管理这些变更。</li><li>确保成本支出不超过批准的资金限额，既不超出按时段、按WBS 组件、按活动分配的限额，也不超出项目总限额。</li><li>监督成本绩效，找出并分析与成本基准间的偏差。</li><li>对照资金支出，监督工作绩效。</li><li>防止在成本或资源使用报告中出现未经批准的变更。</li><li>向有关干系人报告所有经批准的变更及其相关成本。</li><li>设法把预期的成本超支控制在可接受的范围内。</li></ol><h4 id="输入-8"><a href="#输入-8" class="headerlink" title="输入"></a>输入</h4><p>① 项目管理计划 ② 项目资金需求 ③ 工作绩效数据 ④ 组织过程资产</p><h4 id="输出-8"><a href="#输出-8" class="headerlink" title="输出"></a>输出</h4><p>① 工作绩效信息 ② 成本预测 ③ 变更请求 ④ 项目管理计划更新（成本基准、成本管理计划） ⑤ 项目文件更新 （成本估算 、估算依据） ⑥ 组织过程资产更新 （偏差原因、纠正措施、财务数据库、其它经验教训）</p><h4 id="工具与技术-挣值分析"><a href="#工具与技术-挣值分析" class="headerlink" title="工具与技术 挣值分析"></a>工具与技术 挣值分析</h4><ul><li>计划值（PV，Plan Value） PV：计划工作的预算价值 又叫计划工作量的预算费用(BCWS，Budgeted Cost for Work Scheduled )。是指 项目实施过程中某阶段计划要求完成的工作量所需的预算工时（或费用）。 计算公式是： PV=BCWS=计划工作量*预算定额 PV主要反映进度计划应当完成的工作量，而不是反映应消耗的工时或费用。</li><li>实际成本（AC，Actual Cost） AC：实际工作的实际花费 又叫已完成工作量的实际费用（ACWP，Actual Cost for Work Performed）。指项目实施过程中 某阶段实际完成的工作量所消耗的工时（或费用）。 主要反映项目执行的实际消耗指标。</li><li>挣值（EV，Earned Value） EV：实际工作的预算价值（挣值） 又叫已完成工作量的预算成本（BCWP，Budgeted Cost for Work Performed）。指项目实施过程中 某阶段实际完成工作量及按预算定额计算出来的工 时（或费用）之积。计算公式是： EV=BCWP=已完成工作量*预算定额。<table><thead><tr><th>简称</th><th>说明</th><th>公式说明</th></tr></thead><tbody><tr><td>BAC</td><td>完工预算</td><td>整个项目的预算(总的PV)</td></tr><tr><td>PV</td><td>计划值</td><td>计划完成工作的预算值</td></tr><tr><td>EV</td><td>挣值</td><td>实际完成工作的预算值</td></tr><tr><td>AC</td><td>实际成本</td><td>实际花费成本</td></tr><tr><td>ETC</td><td>完工尚需估算</td><td>剩下的工作还需多少钱</td></tr><tr><td>EAC</td><td>完工估算</td><td>EAC=AC+ETC(实际成本+完工尚需估算)</td></tr><tr><td>VAC</td><td>完工偏差</td><td>VAC=BAC-EAC</td></tr><tr><td>SV</td><td>进度偏差</td><td>SV=EV-PV(挣值-计划值 )</td></tr><tr><td>SPI</td><td>进度偏差指数</td><td>SPI=EV/PV(挣值/计划值 )</td></tr><tr><td>CV</td><td>成本偏差</td><td>CV= EV-AC(挣值-实际成本)</td></tr><tr><td>CPI</td><td>成本偏差指数</td><td>CPI=EV/AC(挣值/实际成本)</td></tr></tbody></table></li></ul><h2 id="项目质量管理"><a href="#项目质量管理" class="headerlink" title="项目质量管理"></a>项目质量管理</h2><ul><li><p>质量管理基础</p><ul><li>质量：反映实体满足主体明确和隐含需求的能力的特性总和</li><li>质量管理：确定质量方针、目标和职责，并通过质量体系中的质量规划、质量保证和质量控制以及质量改进来使其实现所有管理职能的全部活动</li><li>质量方针：由组织的最高管理者正式发布的该组织总的质量宗旨和方向</li><li>质量目标：“在质量方面所追求的目的”，它是落实质量方针的具体要求</li></ul></li><li><p>质量管理体系， ISO9000系列，8项基本原则如下：<br>（1）以顾客为中心<br>（2）领导作用<br>（3）全员参与<br>（4）过程方法<br>（5）管理的系统方法<br>（6）持续改进<br>（7）基于事实的决策方法<br>（8）与供方互利的关系</p></li><li><p>全面质量管理与6σ</p><ul><li>全面质量管理（TQM）是一种全员、全过程、全企业的品质管理。它是一个组织以质量为中心，以全员参与为基础，通过让顾客满意和本组织所有成员及社会受益而达到永续经营的目的。全面质量管理注重顾客需要强调参与团队工作，并力争形成一种文化,以促进所有的员工设法并持续改进组织所提供产品/服务的质量、工作过程和顾客反应时间等。全面质量管理有4个核心的特征：即全员参加的质量管理、全过程的质量管理、全面方法的质量管理和全面结果的质量管理。</li><li>六西格码意为“六倍标准差”，采用DMAIC （确定、测量、分析、改进、控制）改进方法对组织的关键流程进行改进，优越之处在于从项目实施过程中改进和保证质量，而不是从结果中检验控制质量。这样做不仅减少了检控质量的步骤，而且避免了由此带来的返工成本。更为重要的是，六西格玛管理培养了员工的质量意识，并把这种质量意识融入企业文化中。</li></ul></li></ul><h3 id="规划质量管理"><a href="#规划质量管理" class="headerlink" title="规划质量管理"></a>规划质量管理</h3><ul><li>识别项目及其可交付成果的质量要求和标准，并准备对策确保符合质量要求的过程为整个项目中如何管理和确认质量提供了指南和方向</li></ul><h4 id="输入-9"><a href="#输入-9" class="headerlink" title="输入"></a>输入</h4><p>1、项目管理计划<br>2、干系人登记册<br>3、风险登记册<br>4、需求文件<br>5、事业环境因素<br>6、组织过程资产</p><h4 id="输出-9"><a href="#输出-9" class="headerlink" title="输出"></a>输出</h4><p>1、质量管理计划：是项目管理计划的组成部分，描述如何实施组织的质量政策，以及项目管理团队准备如何达到项目的质量要求。质量管理计划可以是正式，也可以是非正式的，可以是非常详细的，也可以是高度概括的。<br>2、过程改进计划：详细说明对项目管理过程和产品开发过程进行分析的各个步骤，以识别增值活动。<br>3、质量测量指标：质量测量指标专用于描述项目或产品属性，以及控制质量过程将如何对属性进行测量。质量测量指标的例子包括准时性、成本控制、缺陷频率、故障率、可用性、可靠性和测试覆盖度等。<br>4、质量核对单：核对单是一种结构化工具，通常具体列出各项内容，用来核实所要求的一系列步骤是否已得到执行。<br>5、项目文件更新</p><h4 id="工具技术"><a href="#工具技术" class="headerlink" title="工具技术"></a>工具技术</h4><ul><li>成本收益分析法：对每个质量活动进行成本效益分析，就是要比较其可能的成本与预期的效益。达到质量要求的主要效益包括减少返工、提高生产率、降低成本、提升干系人满意度及提升赢利能力。</li><li>质量成本法：质量成本指在产品生命周期中发生的所有成本，包括为预防不符合要求、为评价产品或服务是否符合要求，以及因未达到要求而发生的所有成本。</li><li>标杆对照：标杆对照是将实际或计划的项目实践与可比项目的实践进行对 照，以便识别最佳实践，形成改进意见，并为绩效考核提供依据。</li><li>实验设计：实验设计（DOE）是一种统计方法，用来识别哪些因素会对正在生产的产品或正在开发的流程的特定变量产生影响。</li><li>规划阶段的其他工具，为定义质量要求并规划有效的质量管理活动，也可使用其他质量规划工具，包括（但不限于）：<ul><li>头脑风暴。用于产生创意的一种技术。</li><li>力场分析。显示变更的推力和阻力的图形。</li><li>名义小组技术。先由规模较小的群体进行头脑风暴，提出创意，再由规模较大的群体对创意进行评审。 </li></ul></li></ul><h3 id="质量保证"><a href="#质量保证" class="headerlink" title="质量保证"></a>质量保证</h3><ul><li>质量保证旨在建立对未来输出或未完输出（也称正在进行的工作）将在完工时满足特定的需求和期望的信心。质量保证部门或类似部门经常要对质量保证活动进行监督。</li><li>质量保证人员，在整个项目中应该完成的工作：<br>（1）计划阶段制定质量管理计划和相应的质量标准<br>（2）按计划实施质量检查，是否按标准过程实施项目工作。注意项目过程<br>中的质量检查，每次进行检查之前准备检查清单，并将质量管理相关情况予<br>以记录<br>（3）依据检查的情况和记录，分析问题，发现问题，与当事人协商进行解<br>决。问题解决后要进行验证；如果无法与当事人达成一致，应报告项目经理<br>或更高层领导，直至问题解决<br>（4）定期给项目干系人发质量报告<br>（5）为项目组成员提供质量管理要求方面的培训或指导</li></ul><h4 id="输入-10"><a href="#输入-10" class="headerlink" title="输入"></a>输入</h4><p>1、质量管理计划<br>2、过程改进计划<br>3、质量测量指标<br>4、质量控制测量结果<br>5、项目文件</p><h4 id="输出-10"><a href="#输出-10" class="headerlink" title="输出"></a>输出</h4><p>1、变更请求<br>2、项目管理计划更新<br>3、项目文件更新<br>4、组织过程资产更新</p><h4 id="工具技术-1"><a href="#工具技术-1" class="headerlink" title="工具技术"></a>工具技术</h4><ul><li>质量审计，又称质量保证体系审核，是对具体质量管理活动的结构性的评审。质量审计的目标是：<ul><li>识别全部正在实施的良好及最佳实践。</li><li>识别全部违规做法、差距及不足。</li><li>分享所在组织或行业中类似项目的良好实践。</li><li>积极、主动地提供协助，以改进过程的执行，从而帮助团队提高生产效率</li><li>强调每次审计都应对组织经验教训的积累做出贡献。</li></ul></li><li>质量审计可以是事先安排，也可随机进行。在具体领域中有专长的内部审计师或第三方组织都可以实施质量审计可由内部或外部审计师进行。</li><li>过程分析：过程分析是指按照过程改进计划中概括的步骤来识别所需的改进。过程分析包括根本原因分析—用于识别问题、探究根本原因，并制定预防措施的一种具体技术。</li></ul><h3 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h3><ul><li><p>监督并记录质量活动执行结果，以便评估绩效，并推荐必要的变更过程。<br>（1）识别过程低效或产品质量低劣的原因，建议并采取相应措施消除这些原因。<br>（2）确认项目的可交付成果及工作满足主要干系人的既定需求，足以进行最终验收。</p></li><li><p>项目质量控制过程一般要经历以下基本步骤：<br>（1）选择控制对象。项目进展的不同时期、不同阶段，质量控制的对象和重点也不相同，需要在项目实施过程中加以识别和选择。质量控制的对象，可以是某个因素、某个环节、某项工作或工序，以及项目的某个里程碑或某项阶段成果等一切与项目质量有关的要素。<br>（2）为控制对象确定标准或目标。<br>（3）制定实施计划，确定保证措施。<br>（4）按计划执行。<br>（5）对项目实施情况进行跟踪监测、检查，并将监测的结果与计划或标准相比较。<br>（6）发现并分析偏差。<br>（7）根据偏差采取相应对策：如果监测的实际情况与标准或计划相比有明显差异，则应采取相应的对策。</p></li></ul><h4 id="输入-11"><a href="#输入-11" class="headerlink" title="输入"></a>输入</h4><p>1、项目管理计划<br>2、质量测量指标<br>3、质量核对单<br>4、工作绩效数据<br>5、批准的变更请求<br>6、可交付成果<br>7、项目文件<br>8、组织过程资产</p><h4 id="输出-11"><a href="#输出-11" class="headerlink" title="输出"></a>输出</h4><p>1、质量控制测量结果<br>2、确认的变更<br>3、核实的可交付成果<br>4、工作绩效信息<br>5、变更请求<br>6、项目管理计划更新<br>7、项目文件更新<br>8、组织过程资产更新</p><h4 id="工具技术-2"><a href="#工具技术-2" class="headerlink" title="工具技术"></a>工具技术</h4><ul><li><p>老七工具：<br>（1）因果图，又称鱼骨图或石川馨图，用来追溯问题来源，回推到可行动的根本原因。<br>（2）流程图，也称过程图，用来显示在一个或多个输入转化成一个或多个输出的过程中，所需要的步骤顺序和可能分支。<br>（3）检查（核查）表，又称计数表，是用于收集数据的查对清单。<br>（4）排列图（帕累托图），用于识别造成大多数问题的少数重要原因。在帕累托图中，通常按类别排列条形，以测量频率或后果。<br>（5）直方图，用于描述集中趋势、分散程度和统计分布形状。与控制图不同，直方图不考虑时间对分布内的变化的影响。<br>（6）控制图，可以使用质量控制图及七点运行定律寻找数据中的规律。七点运行定律是指如果在一个质量控制图中，一行上的7个数据点都低于平均值或高于平均值，或者都是上升的，或者都是下降的，那么这个过程就需要因为非随机问题而接受检查。控制图可用于监测各种类型的输出变量。<br>（7）散点图：可以显示2个变量之间是否有关系，一条斜线上的数据点距离越近，2个变量之间的相关性就越密切。</p></li><li><p>新七工具：<br>（1）亲和图。亲和图与心智图相似。针对某个问题，产生出可联成有组织的想法模式的各种创意。 （2）过程决策程序图（PDPC)。用于理解一个目标与达成此目标的步骤之间的关系。PDPC有助于制订应急计划，因为它能帮助团队预测那些可能破坏目标实现的中间环节。<br>（3）相互关系图（关联图）。关系图的变种，有助于在包含相互交叉逻辑关系的中等复杂情形中创新性地解决问题。可以使用其他工具（诸如亲和图、树形图或鱼骨图）产生的数据，来绘制关图。<br>（4）树形图。也称系统图，可用于表现诸如WBS、RBS和OBS（组织分解结构）的层次分解结构。<br>（5）优先矩阵。用来识别关键事项和合适的备选方案，并通过一系列决策，排列出备选方案的优先顺序。先对标准排序和加权，再应用于所有备选方案，计算出数学得分,对备选方案排序。<br>（6）活动网络图。过去称为箭头图，包括两种格式的网络图：AOA(活动箭线图）和最常用的AON（活动节点图）<br>（7）矩阵图。一种质量管理和控制工具，使用矩阵结构对数据进行分析。在行列交叉的位置展示因素、原因和目标之间的关系强弱。</p></li><li><p>统计抽样：统计抽样是指从目标总体中抽取一部分相关样本用于检查和测量，以满足质量管理计划中的规定。可以降低质量控制的成本。</p></li><li><p>检査：检查也可称为审查、同行审查、审计或巡检等。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 考证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软考高项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven清理下载失败文件</title>
      <link href="2021/01/15/maven-qing-li-xia-zai-shi-bai-wen-jian/"/>
      <url>2021/01/15/maven-qing-li-xia-zai-shi-bai-wen-jian/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Maven清理下载失败文件"><a href="#Maven清理下载失败文件" class="headerlink" title="Maven清理下载失败文件"></a>Maven清理下载失败文件</h1><ul><li><p>cleanLastUpdated.bat（windows版本）</p><pre class="line-numbers language-visual" data-language="visual"><div class="caption"><span>basic</span></div><code class="language-visual">@echo offrem create by niudehua  rem 这里写你的仓库路径set REPOSITORY_PATH&#x3D;D:\Java\maven-repository\maven-aliyun\repositoryrem 正在搜索...for &#x2F;f &quot;delims&#x3D;&quot; %%i in (&#39;dir &#x2F;b &#x2F;s &quot;%REPOSITORY_PATH%\*lastUpdated*&quot;&#39;) do (    echo %%i    del &#x2F;s &#x2F;q &quot;%%i&quot;)rem 搜索完毕pause<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>cleanLastUpdated.sh（linux版本）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># create by niudehua# 这里写你的仓库路径REPOSITORY_PATH&#x3D;&#x2F;Users&#x2F;deng&#x2F;.m2&#x2F;repositoryrm -f lastUpdatedFile.txt# 查询  date &quot;+%Y-%m-%d %H:%M:%S&quot;  &gt;&gt; lastUpdatedFile.txt  echo  &quot;开始搜索&quot;$REPOSITORY_PATH &gt;&gt; lastUpdatedFile.txt  find $REPOSITORY_PATH -name &quot;*lastUpdated*&quot; &gt;&gt; lastUpdatedFile.txt# 删除  find $REPOSITORY_PATH -name &quot;*lastUpdated*&quot; |xargs rm -fr  date &quot;+%Y-%m-%d %H:%M:%S&quot;  &gt;&gt; lastUpdatedFile.txt  echo &quot;搜索完毕&quot;$REPOSITORY_PATH &gt;&gt; lastUpdatedFile.txt  cat  lastUpdatedFile.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10系统专业版激活</title>
      <link href="2020/11/17/win10-xi-tong-zhuan-ye-ban-ji-huo/"/>
      <url>2020/11/17/win10-xi-tong-zhuan-ye-ban-ji-huo/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="win10系统专业版激活"><a href="#win10系统专业版激活" class="headerlink" title="win10系统专业版激活"></a>win10系统专业版激活</h1><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/image-20190922122551902.png" alt="win10系统专业版激活"></p><ul><li>第一步：</li></ul><p>首先，我们先查看一下Win10正式专业版系统的激活状态：<br>点击桌面左下角的“Windows”按钮，从打开的扩展面板中依次点击“设置”-“更新和安全”，并切换到“激活”选项，</p><p>在此就可以查看到当前系统的激活状态。（Win10正式专业版当前未激活）</p><ul><li>第二步：</li></ul><p>接下来在桌面左下角的“cortana”搜索框中输入“CMD”，待出现“命令提示符”工具时，右击选择“以管理员身份”运行。</p><ul><li>第三步：</li></ul><p>此时将“以管理员身份”打开“MSDOS”窗口，在此界面中，依次输出以下命令：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">slmgr.vbs &#x2F;upk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制以上命令，并在黑窗口中右击以粘贴此命令，按回车进行确定。<br>此时弹出窗口显未“已成功卸载了产品密钥”。</p><ul><li>第四步：</li></ul><p>接着输入以下命令：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">slmgr &#x2F;ipk VK7JG-NPHTM-C97JM-9MPGT-3V66T<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>弹出窗口提示：“成功的安装了产品密钥”。</p><ul><li><p>第五步：<br>继续输入以下命令：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">slmgr &#x2F;skms kms.xspace.in<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>弹出窗口提示：“密钥管理服务计算机名成功的设置为kms.xspace.in”</p></li><li><p>第六步：<br>接下来输入以下命令：</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">slmgr &#x2F;ato<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>第七步：</p></li></ul><p>激活以后，为了查看激活的状态，这里我们可以按下键盘的”win+r”打开运行，然后这里我们输入命令，点击确定运行命令！</p><pre class="line-numbers language-cmd" data-language="cmd"><code class="language-cmd">slmgr.vbs -xpr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后就可以再次查看当前Win10正式专业版系统的激活状态啦。</p>]]></content>
      
      
      <categories>
          
          <category> Win10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础进阶：从函数到高级魔法方法</title>
      <link href="2020/09/13/python-ji-chu-jin-jie-cong-han-shu-dao-gao-ji-mo-fa-fang-fa/"/>
      <url>2020/09/13/python-ji-chu-jin-jie-cong-han-shu-dao-gao-ji-mo-fa-fang-fa/</url>
      
        <content type="html"><![CDATA[<hr><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Python 是一种通用编程语言，其在科学计算和机器学习领域具有广泛的应用。如果我们打算利用 Python 来执行机器学习，那么对 Python 有一些基本的了解就是至关重要的。本 Python 入门系列体验就是为这样的初学者精心准备的。</p><p>本实验包括以下内容：</p><ul><li>函数<ul><li>函数的定义</li><li>函数的调用</li><li>函数文档</li><li>函数参数</li><li>函数的返回值</li><li>变量作用域</li></ul></li><li>Lambda 表达式<ul><li>匿名函数的定义</li><li>匿名函数的应用</li></ul></li><li>类与对象<ul><li>对象 = 属性 + 方法</li><li>self 是什么？</li><li>Python 的魔法方法</li><li>公有和私有</li><li>继承</li><li>组合</li><li>类、类对象和实例对象</li><li>什么是绑定？</li><li>一些相关的内置函数（BIF）</li></ul></li><li>魔法方法<ul><li>基本的魔法方法</li><li>算术运算符</li><li>反算术运算符</li><li>增量赋值运算符</li><li>一元运算符</li><li>属性访问</li><li>描述符</li><li>定制序列</li><li>迭代器</li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>还记得 Python 里面“万物皆对象”么？Python 把函数也当成对象，可以从另一个函数中返回出来而去构建高阶函数，比如：<br>参数是函数、返回值是函数。</p><p>我们首先来介绍函数的定义。</p><ul><li>函数以<code>def</code>关键词开头，后接函数名和圆括号()。</li><li>函数执行的代码以冒号起始，并且缩进。</li><li>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回<code>None</code>。</li></ul><blockquote><p>def functionname (parameters):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;”函数_文档字符串”<br><br>&nbsp; &nbsp; &nbsp; &nbsp; function_suite<br><br>&nbsp; &nbsp; &nbsp; &nbsp; return [expression]</p></blockquote><h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def printme(str):    print(str)printme(&quot;我要调用用户自定义函数!&quot;)  # 我要调用用户自定义函数!printme(&quot;再次调用同一函数&quot;)  # 再次调用同一函数temp &#x3D; printme(&#39;hello&#39;) # helloprint(temp)  # None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数文档"><a href="#函数文档" class="headerlink" title="函数文档"></a>函数文档</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">def MyFirstFunction(name):    &quot;函数定义过程中name是形参&quot;    # 因为Ta只是一个形式，表示占据一个参数位置    print(&#39;传递进来的&#123;0&#125;叫做实参，因为Ta是具体的参数值！&#39;.format(name))MyFirstFunction(&#39;老马的程序人生&#39;)  # 传递进来的老马的程序人生叫做实参，因为Ta是具体的参数值！print(MyFirstFunction.__doc__)  # 函数定义过程中name是形参help(MyFirstFunction)# Help on function MyFirstFunction in module __main__:# MyFirstFunction(name)#    函数定义过程中name是形参<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>Python 的函数具有非常灵活多样的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。从简到繁的参数形态如下：</p><ul><li>位置参数 (positional argument)</li><li>默认参数 (default argument)</li><li>可变参数 (variable argument)</li><li>关键字参数 (keyword argument)</li><li>命名关键字参数 (name keyword argument)</li><li>参数组合</li></ul><p><strong>1. 位置参数</strong></p><blockquote><p>def functionname(arg1):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;”函数_文档字符串”<br><br>&nbsp; &nbsp; &nbsp; &nbsp;function_suite<br><br>&nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br></p></blockquote><ul><li><code>arg1</code> - 位置参数 ，这些参数在调用函数 (call function) 时位置要固定。</li></ul><p><strong>2. 默认参数</strong></p><blockquote><p>def functionname(arg1, arg2=v):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;”函数_文档字符串”<br><br>&nbsp; &nbsp; &nbsp; &nbsp;function_suite<br><br>&nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br></p></blockquote><ul><li><code>arg2 = v</code> - 默认参数 = 默认值，调用函数时，默认参数的值如果没有传入，则被认为是默认值。</li><li>默认参数一定要放在位置参数 <b>后面</b>，不然程序会报错。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def printinfo(name, age&#x3D;8):    print(&#39;Name:&#123;0&#125;,Age:&#123;1&#125;&#39;.format(name, age))printinfo(&#39;小马&#39;)  # Name:小马,Age:8printinfo(&#39;小马&#39;, 10)  # Name:小马,Age:10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Python 允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def printinfo(name, age):    print(&#39;Name:&#123;0&#125;,Age:&#123;1&#125;&#39;.format(name, age))printinfo(age&#x3D;8, name&#x3D;&#39;小马&#39;)  # Name:小马,Age:8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3. 可变参数</strong></p><p>顾名思义，可变参数就是传入的参数个数是可变的，可以是 0, 1, 2 到任意个，是不定长的参数。</p><blockquote><p>def functionname(arg1, arg2=v, *args):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;”函数_文档字符串”<br><br>&nbsp; &nbsp; &nbsp; &nbsp;function_suite<br><br>&nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br></p></blockquote><ul><li><code>*args</code> - 可变参数，可以是从零个到任意个，自动组装成元组。</li><li>加了星号（*）的变量名会存放所有未命名的变量参数。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def printinfo(arg1, *args):    print(arg1)    for var in args:        print(var)printinfo(10)  # 10printinfo(70, 60, 50)# 70# 60# 50<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>4. 关键字参数</strong></p><blockquote><p>def functionname(arg1, arg2=v, *args, **kw):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;”函数_文档字符串”<br><br>&nbsp; &nbsp; &nbsp; &nbsp;function_suite<br><br>&nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br></p></blockquote><ul><li><code>**kw</code> - 关键字参数，可以是从零个到任意个，自动组装成字典。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def printinfo(arg1, *args, **kwargs):    print(arg1)    print(args)    print(kwargs)printinfo(70, 60, 50)# 70# (60, 50)# &#123;&#125;printinfo(70, 60, 50, a&#x3D;1, b&#x3D;2)# 70# (60, 50)# &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>「可变参数」和「关键字参数」的同异总结如下：</p><ul><li>可变参数允许传入零个到任意个参数，它们在函数调用时自动组装为一个元组 (tuple)。</li><li>关键字参数允许传入零个到任意个参数，它们在函数内部自动组装为一个字典 (dict)。</li></ul><p><strong>5. 命名关键字参数</strong></p><blockquote><p>def functionname(arg1, arg2=v, <em>args, *, nkw, *</em>kw):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;”函数_文档字符串”<br><br>&nbsp; &nbsp; &nbsp; &nbsp;function_suite<br><br>&nbsp; &nbsp; &nbsp; &nbsp;return [expression]<br></p></blockquote><ul><li><code>*, nkw</code> - 命名关键字参数，用户想要输入的关键字参数，定义方式是在nkw 前面加个分隔符 <code>*</code>。</li><li>如果要限制关键字参数的名字，就可以用「命名关键字参数」</li><li>使用命名关键字参数时，要特别注意不能缺少参数名。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def printinfo(arg1, *, nkw, **kwargs):    print(arg1)    print(nkw)    print(kwargs)printinfo(70, nkw&#x3D;10, a&#x3D;1, b&#x3D;2)# 70# 10# &#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;printinfo(70, 10, a&#x3D;1, b&#x3D;2)# TypeError: printinfo() takes 1 positional argument but 2 were given<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>没有写参数名<code>nwk</code>，因此 10 被当成「位置参数」，而原函数只有 1 个位置函数，现在调用了 2 个，因此程序会报错。</li></ul><p><strong>6. 参数组合</strong></p><p>在 Python 中定义函数，可以用位置参数、默认参数、可变参数、命名关键字参数和关键字参数，这 5 种参数中的 4 个都可以一起使用，但是注意，参数定义的顺序必须是：</p><ul><li>位置参数、默认参数、可变参数和关键字参数。</li><li>位置参数、默认参数、命名关键字参数和关键字参数。</li></ul><p>要注意定义可变参数和关键字参数的语法：</p><ul><li><code>*args</code> 是可变参数，<code>args</code> 接收的是一个 <code>tuple</code></li><li><code>**kw</code> 是关键字参数，<code>kw</code> 接收的是一个 <code>dict</code></li></ul><p>命名关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名关键字参数不要忘了写分隔符 <code>*</code>，否则定义的是位置参数。</p><p>警告：虽然可以组合多达 5 种参数，但不要同时使用太多的组合，否则函数很难懂。</p><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def add(a, b):    return a + bprint(add(1, 2))  # 3print(add([1, 2, 3], [4, 5, 6]))  # [1, 2, 3, 4, 5, 6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def back():    return [1, &#39;小马的程序人生&#39;, 3.14]print(back())  # [1, &#39;小马的程序人生&#39;, 3.14]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def back():    return 1, &#39;小马的程序人生&#39;, 3.14print(back())  # (1, &#39;小马的程序人生&#39;, 3.14)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def printme(str):    print(str)temp &#x3D; printme(&#39;hello&#39;) # helloprint(temp) # Noneprint(type(temp))  # &lt;class &#39;NoneType&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</li><li>定义在函数内部的变量拥有局部作用域，该变量称为局部变量。</li><li>定义在函数外部的变量拥有全局作用域，该变量称为全局变量。</li><li>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def discounts(price, rate):    final_price &#x3D; price * rate    return final_priceold_price &#x3D; float(input(&#39;请输入原价:&#39;))  # 98rate &#x3D; float(input(&#39;请输入折扣率:&#39;))  # 0.9new_price &#x3D; discounts(old_price, rate)print(&#39;打折后价格是:%.2f&#39; % new_price)  # 88.20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当内部作用域想修改外部作用域的变量时，就要用到<code>global</code>和<code>nonlocal</code>关键字了。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">num &#x3D; 1def fun1():    global num  # 需要使用 global 关键字声明    print(num)  # 1    num &#x3D; 123    print(num)  # 123fun1()print(num)  # 123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内嵌函数</strong></p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def outer():    print(&#39;outer函数在这被调用&#39;)    def inner():        print(&#39;inner函数在这被调用&#39;)    inner()  # 该函数只能在outer函数内部被调用outer()# outer函数在这被调用# inner函数在这被调用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>闭包</strong></p><ul><li>是函数式编程的一个重要的语法结构，是一种特殊的内嵌函数。</li><li>如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包。</li><li>通过闭包可以访问外层非全局作用域的变量，这个作用域称为 <b>闭包作用域</b>。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def funX(x):    def funY(y):        return x * y    return funYi &#x3D; funX(8)print(type(i))  # &lt;class &#39;function&#39;&gt;print(i(5))  # 40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】闭包的返回值通常是函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def make_counter(init):    counter &#x3D; [init]    def inc(): counter[0] +&#x3D; 1    def dec(): counter[0] -&#x3D; 1    def get(): return counter[0]    def reset(): counter[0] &#x3D; init    return inc, dec, get, resetinc, dec, get, reset &#x3D; make_counter(0)inc()inc()inc()print(get())  # 3dec()print(get())  # 2reset()print(get())  # 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】 如果要修改闭包作用域中的变量则需要 <code>nonlocal</code> 关键字</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def outer():    num &#x3D; 10    def inner():        nonlocal num  # nonlocal关键字声明        num &#x3D; 100        print(num)    inner()    print(num)outer()# 100# 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递归</strong></p><ul><li>如果一个函数在内部调用自身本身，这个函数就是递归函数。</li></ul><p>【例子】<code>n! = 1 x 2 x 3 x ... x n</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 利用循环n &#x3D; 5for k in range(1, 5):    n &#x3D; n * kprint(n)  # 120# 利用递归def factorial(n):    if n &#x3D;&#x3D; 1:        return 1    return n * factorial(n - 1)print(factorial(5)) # 120<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】斐波那契数列 <code>f(n)=f(n-1)+f(n-2), f(0)=0 f(1)=1</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 利用循环i &#x3D; 0j &#x3D; 1lst &#x3D; list([i, j])for k in range(2, 11):    k &#x3D; i + j    lst.append(k)    i &#x3D; j    j &#x3D; kprint(lst)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]# 利用递归def recur_fibo(n):    if n &lt;&#x3D; 1:        return n    return recur_fibo(n - 1) + recur_fibo(n - 2)lst &#x3D; list()for k in range(11):    lst.append(recur_fibo(k))print(lst)  # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】设置递归的层数，Python默认递归层数为 100</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import syssys.setrecursionlimit(1000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><h3 id="匿名函数的定义"><a href="#匿名函数的定义" class="headerlink" title="匿名函数的定义"></a>匿名函数的定义</h3><p>在 Python 里有两类函数：</p><ul><li>第一类：用 <code>def</code> 关键词定义的正规函数</li><li>第二类：用 <code>lambda</code> 关键词定义的匿名函数</li></ul><p>Python 使用 <code>lambda</code> 关键词来创建匿名函数，而非<code>def</code>关键词，它没有函数名，其语法结构如下：</p><blockquote><p>lambda argument_list: expression</p></blockquote><ul><li><code>lambda</code> - 定义匿名函数的关键词。</li><li><code>argument_list</code> - 函数参数，它们可以是位置参数、默认参数、关键字参数，和正规函数里的参数类型一样。</li><li><code>:</code>- 冒号，在函数参数和表达式中间要加个冒号。</li><li><code>expression</code> - 只是一个表达式，输入函数参数，输出一些值。</li></ul><p>注意：</p><ul><li><code>expression</code> 中没有 return 语句，因为 lambda 不需要它来返回，表达式本身结果就是返回值。</li><li>匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def sqr(x):    return x ** 2print(sqr)# &lt;function sqr at 0x000000BABD3A4400&gt;y &#x3D; [sqr(x) for x in range(10)]print(y)# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]lbd_sqr &#x3D; lambda x: x ** 2print(lbd_sqr)# &lt;function &lt;lambda&gt; at 0x000000BABB6AC1E0&gt;y &#x3D; [lbd_sqr(x) for x in range(10)]print(y)# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]sumary &#x3D; lambda arg1, arg2: arg1 + arg2print(sumary(10, 20))  # 30func &#x3D; lambda *args: sum(args)print(func(1, 2, 3, 4, 5))  # 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匿名函数的应用"><a href="#匿名函数的应用" class="headerlink" title="匿名函数的应用"></a>匿名函数的应用</h3><p>函数式编程 是指代码中每一块都是不可变的，都由纯函数的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用。</p><p>【例子】非函数式编程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def f(x):    for i in range(0, len(x)):        x[i] +&#x3D; 10    return xx &#x3D; [1, 2, 3]f(x)print(x)# [11, 12, 13]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】函数式编程</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def f(x):    y &#x3D; []    for item in x:        y.append(item + 10)    return yx &#x3D; [1, 2, 3]f(x)print(x)# [1, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>匿名函数 常常应用于函数式编程的高阶函数 (high-order function)中，主要有两种形式：</p><ul><li>参数是函数 (filter, map)</li><li>返回值是函数 (closure)</li></ul><p>如，在 <code>filter</code>和<code>map</code>函数中的应用：</p><ul><li><code>filter(function, iterable)</code> 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 <code>list()</code> 来转换。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">odd &#x3D; lambda x: x % 2 &#x3D;&#x3D; 1templist &#x3D; filter(odd, [1, 2, 3, 4, 5, 6, 7, 8, 9])print(list(templist))  # [1, 3, 5, 7, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>map(function, *iterables)</code> 根据提供的函数对指定序列做映射。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">m1 &#x3D; map(lambda x: x ** 2, [1, 2, 3, 4, 5])print(list(m1))  # [1, 4, 9, 16, 25]m2 &#x3D; map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])print(list(m2))  # [3, 7, 11, 15, 19]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了 Python 这些内置函数，我们也可以自己定义高阶函数。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def apply_to_list(fun, some_list):    return fun(some_list)lst &#x3D; [1, 2, 3, 4, 5]print(apply_to_list(sum, lst))# 15print(apply_to_list(len, lst))# 5print(apply_to_list(lambda x: sum(x) &#x2F; len(x), lst))# 3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="对象-属性-方法"><a href="#对象-属性-方法" class="headerlink" title="对象 = 属性 + 方法"></a>对象 = 属性 + 方法</h3><p>对象是类的实例。换句话说，类主要定义对象的结构，然后我们以类为模板创建对象。类不但包含方法定义，而且还包含所有实例共享的数据。</p><ul><li>封装：信息隐蔽技术</li></ul><p>我们可以使用关键字 <code>class</code> 定义 Python 类，关键字后面紧跟类的名称、分号和类的实现。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Turtle:  # Python中的类名约定以大写字母开头    &quot;&quot;&quot;关于类的一个简单例子&quot;&quot;&quot;    # 属性    color &#x3D; &#39;green&#39;    weight &#x3D; 10    legs &#x3D; 4    shell &#x3D; True    mouth &#x3D; &#39;大嘴&#39;    # 方法    def climb(self):        print(&#39;我正在很努力的向前爬...&#39;)    def run(self):        print(&#39;我正在飞快的向前跑...&#39;)    def bite(self):        print(&#39;咬死你咬死你!!&#39;)    def eat(self):        print(&#39;有得吃，真满足...&#39;)    def sleep(self):        print(&#39;困了，睡了，晚安，zzz&#39;)tt &#x3D; Turtle()print(tt)# &lt;__main__.Turtle object at 0x0000007C32D67F98&gt;print(type(tt))# &lt;class &#39;__main__.Turtle&#39;&gt;print(tt.__class__)# &lt;class &#39;__main__.Turtle&#39;&gt;print(tt.__class__.__name__)# Turtlett.climb()# 我正在很努力的向前爬...tt.run()# 我正在飞快的向前跑...tt.bite()# 咬死你咬死你!!# Python类也是对象。它们是type的实例print(type(Turtle))# &lt;class &#39;type&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>继承：子类自动共享父类之间数据和方法的机制</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MyList(list):    passlst &#x3D; MyList([1, 5, 2, 7, 8])lst.append(9)lst.sort()print(lst)# [1, 2, 5, 7, 8, 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>多态：不同对象对同一方法响应不同的行动</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Animal:    def run(self):        raise AttributeError(&#39;子类必须实现这个方法&#39;)class People(Animal):    def run(self):        print(&#39;人正在走&#39;)class Pig(Animal):    def run(self):        print(&#39;pig is walking&#39;)class Dog(Animal):    def run(self):        print(&#39;dog is running&#39;)def func(animal):    animal.run()func(Pig())# pig is walking<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="self-是什么？"><a href="#self-是什么？" class="headerlink" title="self 是什么？"></a>self 是什么？</h3><p>Python 的 <code>self</code> 相当于 C++ 的 <code>this</code> 指针。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Test:    def prt(self):        print(self)        print(self.__class__)t &#x3D; Test()t.prt()# &lt;__main__.Test object at 0x000000BC5A351208&gt;# &lt;class &#39;__main__.Test&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身），按照惯例它的名称是 <code>self</code>。在调用方法时，我们无需明确提供与参数 <code>self</code> 相对应的参数。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Ball:    def setName(self, name):        self.name &#x3D; name    def kick(self):        print(&quot;我叫%s,该死的，谁踢我...&quot; % self.name)a &#x3D; Ball()a.setName(&quot;球A&quot;)b &#x3D; Ball()b.setName(&quot;球B&quot;)c &#x3D; Ball()c.setName(&quot;球C&quot;)a.kick()# 我叫球A,该死的，谁踢我...b.kick()# 我叫球B,该死的，谁踢我...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="Python-的魔法方法"><a href="#Python-的魔法方法" class="headerlink" title="Python 的魔法方法"></a>Python 的魔法方法</h3><p>据说，Python 的对象天生拥有一些神奇的方法，它们是面向对象的 Python 的一切…</p><p>它们是可以给你的类增加魔力的特殊方法…</p><p>如果你的对象实现了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，而这一切都是自动发生的…</p><p>类有一个名为<code>__init__(self[, param1, param2...])</code>的魔法方法，该方法在类实例化时会自动调用。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Ball:    def __init__(self, name):        self.name &#x3D; name    def kick(self):        print(&quot;我叫%s,该死的，谁踢我...&quot; % self.name)a &#x3D; Ball(&quot;球A&quot;)b &#x3D; Ball(&quot;球B&quot;)c &#x3D; Ball(&quot;球C&quot;)a.kick()# 我叫球A,该死的，谁踢我...b.kick()# 我叫球B,该死的，谁踢我...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="公有和私有"><a href="#公有和私有" class="headerlink" title="公有和私有"></a>公有和私有</h3><p>在 Python 中定义私有变量只需要在变量名或函数名前加上“__”两个下划线，那么这个函数或变量就会为私有的了。</p><p>【例子】类的私有属性实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class JustCounter:    __secretCount &#x3D; 0  # 私有变量    publicCount &#x3D; 0  # 公开变量    def count(self):        self.__secretCount +&#x3D; 1        self.publicCount +&#x3D; 1        print(self.__secretCount)counter &#x3D; JustCounter()counter.count()  # 1counter.count()  # 2print(counter.publicCount)  # 2# Python的私有为伪私有print(counter._JustCounter__secretCount)  # 2 print(counter.__secretCount)  # AttributeError: &#39;JustCounter&#39; object has no attribute &#39;__secretCount&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】类的私有方法实例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Site:    def __init__(self, name, url):        self.name &#x3D; name  # public        self.__url &#x3D; url  # private    def who(self):        print(&#39;name  : &#39;, self.name)        print(&#39;url : &#39;, self.__url)    def __foo(self):  # 私有方法        print(&#39;这是私有方法&#39;)    def foo(self):  # 公共方法        print(&#39;这是公共方法&#39;)        self.__foo()x &#x3D; Site(&#39;老马的程序人生&#39;, &#39;https:&#x2F;&#x2F;blog.csdn.net&#x2F;LSGO_MYP&#39;)x.who()# name  :  老马的程序人生# url :  https:&#x2F;&#x2F;blog.csdn.net&#x2F;LSGO_MYPx.foo()# 这是公共方法# 这是私有方法x.__foo()# AttributeError: &#39;Site&#39; object has no attribute &#39;__foo&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>Python 同样支持类的继承，派生类的定义如下所示：</p><blockquote><p>class DerivedClassName(BaseClassName):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;statement-1<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;statement-N</p></blockquote><p><code>BaseClassName</code>（基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用：</p><blockquote><p>class DerivedClassName(modname.BaseClassName):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;statement-1<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;statement-N</p></blockquote><p>【例子】如果子类中定义与父类同名的方法或属性，则会自动覆盖父类对应的方法或属性。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 类定义class people:    # 定义基本属性    name &#x3D; &#39;&#39;    age &#x3D; 0    # 定义私有属性,私有属性在类外部无法直接进行访问    __weight &#x3D; 0    # 定义构造方法    def __init__(self, n, a, w):        self.name &#x3D; n        self.age &#x3D; a        self.__weight &#x3D; w    def speak(self):        print(&quot;%s 说: 我 %d 岁。&quot; % (self.name, self.age))# 单继承示例class student(people):    grade &#x3D; &#39;&#39;    def __init__(self, n, a, w, g):        # 调用父类的构函        people.__init__(self, n, a, w)        self.grade &#x3D; g    # 覆写父类的方法    def speak(self):        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot; % (self.name, self.age, self.grade))s &#x3D; student(&#39;小马的程序人生&#39;, 10, 60, 3)s.speak()# 小马的程序人生 说: 我 10 岁了，我在读 3 年级<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：如果上面的程序去掉：<code>people.__init__(self, n, a, w)</code>，则输出：<code> 说: 我 0 岁了，我在读 3 年级</code>，因为子类的构造方法把父类的构造方法覆盖了。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import randomclass Fish:    def __init__(self):        self.x &#x3D; random.randint(0, 10)        self.y &#x3D; random.randint(0, 10)    def move(self):        self.x -&#x3D; 1        print(&quot;我的位置&quot;, self.x, self.y)class GoldFish(Fish):  # 金鱼    passclass Carp(Fish):  # 鲤鱼    passclass Salmon(Fish):  # 三文鱼    passclass Shark(Fish):  # 鲨鱼    def __init__(self):        self.hungry &#x3D; True    def eat(self):        if self.hungry:            print(&quot;吃货的梦想就是天天有得吃！&quot;)            self.hungry &#x3D; False        else:            print(&quot;太撑了，吃不下了！&quot;)            self.hungry &#x3D; Trueg &#x3D; GoldFish()g.move()  # 我的位置 9 4s &#x3D; Shark()s.eat() # 吃货的梦想就是天天有得吃！s.move()  # AttributeError: &#39;Shark&#39; object has no attribute &#39;x&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决该问题可用以下两种方式：</p><ul><li>调用未绑定的父类方法<code>Fish.__init__(self)</code></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Shark(Fish):  # 鲨鱼    def __init__(self):        Fish.__init__(self)        self.hungry &#x3D; True    def eat(self):        if self.hungry:            print(&quot;吃货的梦想就是天天有得吃！&quot;)            self.hungry &#x3D; False        else:            print(&quot;太撑了，吃不下了！&quot;)            self.hungry &#x3D; True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>使用super函数<code>super().__init__()</code></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Shark(Fish):  # 鲨鱼    def __init__(self):        super().__init__()        self.hungry &#x3D; True    def eat(self):        if self.hungry:            print(&quot;吃货的梦想就是天天有得吃！&quot;)            self.hungry &#x3D; False        else:            print(&quot;太撑了，吃不下了！&quot;)            self.hungry &#x3D; True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 虽然支持多继承的形式，但我们一般不使用多继承，因为容易引起混乱。</p><blockquote><p>class DerivedClassName(Base1, Base2, Base3):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;statement-1<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;.<br><br>&nbsp; &nbsp; &nbsp; &nbsp;statement-N<br></p></blockquote><p>需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，Python 从左至右搜索，即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 类定义class People:    # 定义基本属性    name &#x3D; &#39;&#39;    age &#x3D; 0    # 定义私有属性,私有属性在类外部无法直接进行访问    __weight &#x3D; 0    # 定义构造方法    def __init__(self, n, a, w):        self.name &#x3D; n        self.age &#x3D; a        self.__weight &#x3D; w    def speak(self):        print(&quot;%s 说: 我 %d 岁。&quot; % (self.name, self.age))# 单继承示例class Student(People):    grade &#x3D; &#39;&#39;    def __init__(self, n, a, w, g):        # 调用父类的构函        People.__init__(self, n, a, w)        self.grade &#x3D; g    # 覆写父类的方法    def speak(self):        print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot; % (self.name, self.age, self.grade))# 另一个类，多重继承之前的准备class Speaker:    topic &#x3D; &#39;&#39;    name &#x3D; &#39;&#39;    def __init__(self, n, t):        self.name &#x3D; n        self.topic &#x3D; t    def speak(self):        print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot; % (self.name, self.topic))# 多重继承class Sample01(Speaker, Student):    a &#x3D; &#39;&#39;    def __init__(self, n, a, w, g, t):        Student.__init__(self, n, a, w, g)        Speaker.__init__(self, n, t)# 方法名同，默认调用的是在括号中排前地父类的方法test &#x3D; Sample01(&quot;Tim&quot;, 25, 80, 4, &quot;Python&quot;)test.speak()  # 我叫 Tim，我是一个演说家，我演讲的主题是 Pythonclass Sample02(Student, Speaker):    a &#x3D; &#39;&#39;    def __init__(self, n, a, w, g, t):        Student.__init__(self, n, a, w, g)        Speaker.__init__(self, n, t)# 方法名同，默认调用的是在括号中排前地父类的方法test &#x3D; Sample02(&quot;Tim&quot;, 25, 80, 4, &quot;Python&quot;)test.speak()  # Tim 说: 我 25 岁了，我在读 4 年级<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Turtle:    def __init__(self, x):        self.num &#x3D; xclass Fish:    def __init__(self, x):        self.num &#x3D; xclass Pool:    def __init__(self, x, y):        self.turtle &#x3D; Turtle(x)        self.fish &#x3D; Fish(y)    def print_num(self):        print(&quot;水池里面有乌龟%s只，小鱼%s条&quot; % (self.turtle.num, self.fish.num))p &#x3D; Pool(2, 3)p.print_num()# 水池里面有乌龟2只，小鱼3条<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类、类对象和实例对象"><a href="#类、类对象和实例对象" class="headerlink" title="类、类对象和实例对象"></a>类、类对象和实例对象</h3><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/20191007090316462.png" alt="类对象和实例对象"></p><p>类对象：创建一个类，其实也是一个对象也在内存开辟了一块空间，称为类对象，类对象只有一个。</p><blockquote><p>class A(object):<br><br>&nbsp; &nbsp; &nbsp; &nbsp;pass</p></blockquote><p>实例对象：就是通过实例化类创建的对象，称为实例对象，实例对象可以有多个。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A(object):    pass# 实例化对象 a、b、c都属于实例对象。a &#x3D; A()b &#x3D; A()c &#x3D; A()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类属性：类里面方法外面定义的变量称为类属性。类属性所属于类对象并且多个实例对象之间共享同一个类属性，说白了就是类属性所有的通过该类实例化的对象都能共享。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A():    a &#x3D; 0  #类属性    def __init__(self, xx):        A.a &#x3D; xx  #使用类属性可以通过 （类名.类属性）调用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>实例属性：实例属性和具体的某个实例对象有关系，并且一个实例对象和另外一个实例对象是不共享属性的，说白了实例属性只能在自己的对象里面使用，其他的对象不能直接使用，因为<code>self</code>是谁调用，它的值就属于该对象。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 创建类对象class Test(object):    class_attr &#x3D; 100  # 类属性    def __init__(self):        self.sl_attr &#x3D; 100  # 实例属性    def func(self):        print(&#39;类对象.类属性的值:&#39;, Test.class_attr)  # 调用类属性        print(&#39;self.类属性的值&#39;, self.class_attr)  # 相当于把类属性 变成实例属性        print(&#39;self.实例属性的值&#39;, self.sl_attr)  # 调用实例属性a &#x3D; Test()a.func()# 类对象.类属性的值: 100# self.类属性的值 100# self.实例属性的值 100b &#x3D; Test()b.func()# 类对象.类属性的值: 100# self.类属性的值 100# self.实例属性的值 100a.class_attr &#x3D; 200a.sl_attr &#x3D; 200a.func()# 类对象.类属性的值: 100# self.类属性的值 200# self.实例属性的值 200b.func()# 类对象.类属性的值: 100# self.类属性的值 100# self.实例属性的值 100Test.class_attr &#x3D; 300a.func()# 类对象.类属性的值: 300# self.类属性的值 200# self.实例属性的值 200b.func()# 类对象.类属性的值: 300# self.类属性的值 300# self.实例属性的值 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：属性与方法名相同，属性会覆盖方法。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A:    def x(self):        print(&#39;x_man&#39;)aa &#x3D; A()aa.x()  # x_manaa.x &#x3D; 1print(aa.x)  # 1aa.x()# TypeError: &#39;int&#39; object is not callable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="什么是绑定？"><a href="#什么是绑定？" class="headerlink" title="什么是绑定？"></a>什么是绑定？</h3><p>Python 严格要求方法需要有实例才能被调用，这种限制其实就是 Python 所谓的绑定概念。</p><p>Python 对象的数据属性通常存储在名为<code>.__ dict__</code>的字典中，我们可以直接访问<code>__dict__</code>，或利用 Python 的内置函数<code>vars()</code>获取<code>.__ dict__</code>。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class CC:    def setXY(self, x, y):        self.x &#x3D; x        self.y &#x3D; y    def printXY(self):        print(self.x, self.y)dd &#x3D; CC()print(dd.__dict__)# &#123;&#125;print(vars(dd))# &#123;&#125;print(CC.__dict__)# &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;setXY&#39;: &lt;function CC.setXY at 0x000000C3473DA048&gt;, &#39;printXY&#39;: &lt;function CC.printXY at 0x000000C3473C4F28&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;CC&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;CC&#39; objects&gt;, &#39;__doc__&#39;: None&#125;dd.setXY(4, 5)print(dd.__dict__)# &#123;&#39;x&#39;: 4, &#39;y&#39;: 5&#125;print(vars(CC))# &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;setXY&#39;: &lt;function CC.setXY at 0x000000632CA9B048&gt;, &#39;printXY&#39;: &lt;function CC.printXY at 0x000000632CA83048&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;CC&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;CC&#39; objects&gt;, &#39;__doc__&#39;: None&#125;print(CC.__dict__)# &#123;&#39;__module__&#39;: &#39;__main__&#39;, &#39;setXY&#39;: &lt;function CC.setXY at 0x000000632CA9B048&gt;, &#39;printXY&#39;: &lt;function CC.printXY at 0x000000632CA83048&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;CC&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;CC&#39; objects&gt;, &#39;__doc__&#39;: None&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一些相关的内置函数（BIF）"><a href="#一些相关的内置函数（BIF）" class="headerlink" title="一些相关的内置函数（BIF）"></a>一些相关的内置函数（BIF）</h3><ul><li><code>issubclass(class, classinfo)</code> 方法用于判断参数 class 是否是类型参数 classinfo 的子类。</li><li>一个类被认为是其自身的子类。</li><li><code>classinfo</code>可以是类对象的元组，只要class是其中任何一个候选类的子类，则返回<code>True</code>。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A:    passclass B(A):    passprint(issubclass(B, A))  # Trueprint(issubclass(B, B))  # Trueprint(issubclass(A, B))  # Falseprint(issubclass(B, object))  # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>isinstance(object, classinfo)</code> 方法用于判断一个对象是否是一个已知的类型，类似<code>type()</code>。</li><li><code>type()</code>不会认为子类是一种父类类型，不考虑继承关系。</li><li><code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系。</li><li>如果第一个参数不是对象，则永远返回<code>False</code>。</li><li>如果第二个参数不是类或者由类对象组成的元组，会抛出一个<code>TypeError</code>异常。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; 2print(isinstance(a, int))  # Trueprint(isinstance(a, str))  # Falseprint(isinstance(a, (str, int, list)))  # Trueclass A:    passclass B(A):    passprint(isinstance(A(), A))  # Trueprint(type(A()) &#x3D;&#x3D; A)  # Trueprint(isinstance(B(), A))  # Trueprint(type(B()) &#x3D;&#x3D; A)  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>hasattr(object, name)</code>用于判断对象是否包含对应的属性。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Coordinate:    x &#x3D; 10    y &#x3D; -5    z &#x3D; 0point1 &#x3D; Coordinate()print(hasattr(point1, &#39;x&#39;))  # Trueprint(hasattr(point1, &#39;y&#39;))  # Trueprint(hasattr(point1, &#39;z&#39;))  # Trueprint(hasattr(point1, &#39;no&#39;))  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>getattr(object, name[, default])</code>用于返回一个对象属性值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A(object):    bar &#x3D; 1a &#x3D; A()print(getattr(a, &#39;bar&#39;))  # 1print(getattr(a, &#39;bar2&#39;, 3))  # 3print(getattr(a, &#39;bar2&#39;))# AttributeError: &#39;A&#39; object has no attribute &#39;bar2&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】这个例子很酷！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A(object):    def set(self, a, b):        x &#x3D; a        a &#x3D; b        b &#x3D; x        print(a, b)a &#x3D; A()c &#x3D; getattr(a, &#39;set&#39;)c(a&#x3D;&#39;1&#39;, b&#x3D;&#39;2&#39;)  # 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>setattr(object, name, value)</code>对应函数 <code>getattr()</code>，用于设置属性值，该属性不一定是存在的。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A(object):    bar &#x3D; 1a &#x3D; A()print(getattr(a, &#39;bar&#39;))  # 1setattr(a, &#39;bar&#39;, 5)print(a.bar)  # 5setattr(a, &quot;age&quot;, 28)print(a.age)  # 28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>delattr(object, name)</code>用于删除属性。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Coordinate:    x &#x3D; 10    y &#x3D; -5    z &#x3D; 0point1 &#x3D; Coordinate()print(&#39;x &#x3D; &#39;, point1.x)  # x &#x3D;  10print(&#39;y &#x3D; &#39;, point1.y)  # y &#x3D;  -5print(&#39;z &#x3D; &#39;, point1.z)  # z &#x3D;  0delattr(Coordinate, &#39;z&#39;)print(&#39;--删除 z 属性后--&#39;)  # --删除 z 属性后--print(&#39;x &#x3D; &#39;, point1.x)  # x &#x3D;  10print(&#39;y &#x3D; &#39;, point1.y)  # y &#x3D;  -5# 触发错误print(&#39;z &#x3D; &#39;, point1.z)# AttributeError: &#39;Coordinate&#39; object has no attribute &#39;z&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>class property([fget[, fset[, fdel[, doc]]]])</code>用于在新式类中返回属性值。<ul><li><code>fget</code> – 获取属性值的函数</li><li><code>fset</code> – 设置属性值的函数</li><li><code>fdel</code> – 删除属性值函数</li><li><code>doc</code> – 属性描述信息</li></ul></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class C(object):    def __init__(self):        self.__x &#x3D; None    def getx(self):        return self.__x    def setx(self, value):        self.__x &#x3D; value    def delx(self):        del self.__x    x &#x3D; property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;)cc &#x3D; C()cc.x &#x3D; 2print(cc.x)  # 2del cc.xprint(cc.x)# AttributeError: &#39;C&#39; object has no attribute &#39;_C__x&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h2><p>魔法方法总是被双下划线包围，例如<code>__init__</code>。</p><p>魔法方法是面向对象的 Python 的一切，如果你不知道魔法方法，说明你还没能意识到面向对象的 Python 的强大。</p><p>魔法方法的“魔力”体现在它们总能够在适当的时候被自动调用。</p><p>魔法方法的第一个参数应为<code>cls</code>（类方法） 或者<code>self</code>（实例方法）。</p><ul><li><code>cls</code>：代表一个类的名称</li><li><code>self</code>：代表一个实例对象的名称</li></ul><h3 id="基本的魔法方法"><a href="#基本的魔法方法" class="headerlink" title="基本的魔法方法"></a>基本的魔法方法</h3><ul><li><code>__init__(self[, ...])</code> 构造器，当一个实例被创建的时候调用的初始化方法</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Rectangle:    def __init__(self, x, y):        self.x &#x3D; x        self.y &#x3D; y    def getPeri(self):        return (self.x + self.y) * 2    def getArea(self):        return self.x * self.yrect &#x3D; Rectangle(4, 5)print(rect.getPeri())  # 18print(rect.getArea())  # 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__new__(cls[, ...])</code> 在一个对象实例化的时候所调用的第一个方法，在调用<code>__init__</code>初始化前，先调用<code>__new__</code>。<ul><li><code>__new__</code>至少要有一个参数<code>cls</code>，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给<code>__init__</code>。</li><li><code>__new__</code>对当前类进行了实例化，并将实例返回，传给<code>__init__</code>的<code>self</code>。但是，执行了<code>__new__</code>，并不一定会进入<code>__init__</code>，只有<code>__new__</code>返回了，当前类<code>cls</code>的实例，当前类的<code>__init__</code>才会进入。</li></ul></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class A(object):    def __init__(self, value):        print(&quot;into A __init__&quot;)        self.value &#x3D; value    def __new__(cls, *args, **kwargs):        print(&quot;into A __new__&quot;)        print(cls)        return object.__new__(cls)class B(A):    def __init__(self, value):        print(&quot;into B __init__&quot;)        self.value &#x3D; value    def __new__(cls, *args, **kwargs):        print(&quot;into B __new__&quot;)        print(cls)        return super().__new__(cls, *args, **kwargs)b &#x3D; B(10)# 结果：# into B __new__# &lt;class &#39;__main__.B&#39;&gt;# into A __new__# &lt;class &#39;__main__.B&#39;&gt;# into B __init__class A(object):    def __init__(self, value):        print(&quot;into A __init__&quot;)        self.value &#x3D; value    def __new__(cls, *args, **kwargs):        print(&quot;into A __new__&quot;)        print(cls)        return object.__new__(cls)class B(A):    def __init__(self, value):        print(&quot;into B __init__&quot;)        self.value &#x3D; value    def __new__(cls, *args, **kwargs):        print(&quot;into B __new__&quot;)        print(cls)        return super().__new__(A, *args, **kwargs)  # 改动了cls变为Ab &#x3D; B(10)# 结果：# into B __new__# &lt;class &#39;__main__.B&#39;&gt;# into A __new__# &lt;class &#39;__main__.A&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>若<code>__new__</code>没有正确返回当前类<code>cls</code>的实例，那<code>__init__</code>是不会被调用的，即使是父类的实例也不行，将没有<code>__init__</code>被调用。</li></ul><p>【例子】利用<code>__new__</code>实现单例模式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Earth:    passa &#x3D; Earth()print(id(a))  # 260728291456b &#x3D; Earth()print(id(b))  # 260728291624class Earth:    __instance &#x3D; None  # 定义一个类属性做判断    def __new__(cls):        if cls.__instance is None:            cls.__instance &#x3D; object.__new__(cls)            return cls.__instance        else:            return cls.__instancea &#x3D; Earth()print(id(a))  # 512320401648b &#x3D; Earth()print(id(b))  # 512320401648<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__new__</code>方法主要是当你继承一些不可变的 class 时（比如<code>int, str, tuple</code>）， 提供给你一个自定义这些类的实例化过程的途径。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class CapStr(str):    def __new__(cls, string):        string &#x3D; string.upper()        return str.__new__(cls, string)a &#x3D; CapStr(&quot;i love lsgogroup&quot;)print(a)  # I LOVE LSGOGROUP<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__del__(self)</code> 析构器，当一个对象将要被系统回收之时调用的方法。</li></ul><blockquote><p>Python 采用自动引用计数（ARC）方式来回收对象所占用的空间，当程序中有一个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 1；当程序中有两个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 2，依此类推，如果一个对象的引用计数变成了 0，则说明程序中不再有变量引用该对象，表明程序不再需要该对象，因此 Python 就会回收该对象。</p><p>大部分时候，Python 的 ARC 都能准确、高效地回收系统中的每个对象。但如果系统中出现循环引用的情况，比如对象 a 持有一个实例变量引用对象 b，而对象 b 又持有一个实例变量引用对象 a，此时两个对象的引用计数都是 1，而实际上程序已经不再有变量引用它们，系统应该回收它们，此时 Python 的垃圾回收器就可能没那么快，要等专门的循环垃圾回收器（Cyclic Garbage Collector）来检测并回收这种引用循环。</p></blockquote><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class C(object):    def __init__(self):        print(&#39;into C __init__&#39;)    def __del__(self):        print(&#39;into C __del__&#39;)c1 &#x3D; C()# into C __init__c2 &#x3D; c1c3 &#x3D; c2del c3del c2del c1# into C __del__<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>__str__(self)</code>:</p><ul><li>当你打印一个对象的时候，触发<code>__str__</code></li><li>当你使用<code>%s</code>格式化的时候，触发<code>__str__</code></li><li><code>str</code>强转数据类型的时候，触发<code>__str__</code></li></ul></li><li><p><code>__repr__(self)</code>：</p><ul><li><code>repr</code>是<code>str</code>的备胎</li><li>有<code>__str__</code>的时候执行<code>__str__</code>,没有实现<code>__str__</code>的时候，执行<code>__repr__</code></li><li><code>repr(obj)</code>内置函数对应的结果是<code>__repr__</code>的返回值</li><li>当你使用<code>%r</code>格式化的时候 触发<code>__repr__</code></li></ul></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Cat:    &quot;&quot;&quot;定义一个猫类&quot;&quot;&quot;    def __init__(self, new_name, new_age):        &quot;&quot;&quot;在创建完对象之后 会自动调用, 它完成对象的初始化的功能&quot;&quot;&quot;        self.name &#x3D; new_name        self.age &#x3D; new_age    def __str__(self):        &quot;&quot;&quot;返回一个对象的描述信息&quot;&quot;&quot;        return &quot;名字是:%s , 年龄是:%d&quot; % (self.name, self.age)            def __repr__(self):        &quot;&quot;&quot;返回一个对象的描述信息&quot;&quot;&quot;        return &quot;Cat:(%s,%d)&quot; % (self.name, self.age)    def eat(self):        print(&quot;%s在吃鱼....&quot; % self.name)    def drink(self):        print(&quot;%s在喝可乐...&quot; % self.name)    def introduce(self):        print(&quot;名字是:%s, 年龄是:%d&quot; % (self.name, self.age))# 创建了一个对象tom &#x3D; Cat(&quot;汤姆&quot;, 30)print(tom)  # 名字是:汤姆 , 年龄是:30print(str(tom)) # 名字是:汤姆 , 年龄是:30print(repr(tom))  # Cat:(汤姆,30)tom.eat()  # 汤姆在吃鱼....tom.introduce()  # 名字是:汤姆, 年龄是:30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>__str__(self)</code> 的返回结果可读性强。也就是说，<code>__str__</code> 的意义是得到便于人们阅读的信息，就像下面的 ‘2019-10-11’ 一样。</p><p><code>__repr__(self)</code> 的返回结果应更准确。怎么说，<code>__repr__</code> 存在的目的在于调试，便于开发者使用。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import datetimetoday &#x3D; datetime.date.today()print(str(today))  # 2019-10-11print(repr(today))  # datetime.date(2019, 10, 11)print(&#39;%s&#39; %today)  # 2019-10-11print(&#39;%r&#39; %today)  # datetime.date(2019, 10, 11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>类型工厂函数，指的是“不通过类而是通过函数来创建对象”。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class C:    passprint(type(len))  # &lt;class &#39;builtin_function_or_method&#39;&gt;print(type(dir))  # &lt;class &#39;builtin_function_or_method&#39;&gt;print(type(int))  # &lt;class &#39;type&#39;&gt;print(type(list))  # &lt;class &#39;type&#39;&gt;print(type(tuple))  # &lt;class &#39;type&#39;&gt;print(type(C))  # &lt;class &#39;type&#39;&gt;print(int(&#39;123&#39;))  # 123# 这个例子中list工厂函数把一个元祖对象加工成了一个列表对象。print(list((1, 2, 3)))  # [1, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__add__(self, other)</code>定义加法的行为：<code>+</code></li><li><code>__sub__(self, other)</code>定义减法的行为：<code>-</code></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MyClass:    def __init__(self, height, weight):        self.height &#x3D; height        self.weight &#x3D; weight    # 两个对象的长相加，宽不变.返回一个新的类    def __add__(self, others):        return MyClass(self.height + others.height, self.weight + others.weight)    # 两个对象的宽相减，长不变.返回一个新的类    def __sub__(self, others):        return MyClass(self.height - others.height, self.weight - others.weight)    # 说一下自己的参数    def intro(self):        print(&quot;高为&quot;, self.height, &quot; 重为&quot;, self.weight)def main():    a &#x3D; MyClass(height&#x3D;10, weight&#x3D;5)    a.intro()    b &#x3D; MyClass(height&#x3D;20, weight&#x3D;10)    b.intro()    c &#x3D; b - a    c.intro()    d &#x3D; a + b    d.intro()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    main()# 高为 10  重为 5# 高为 20  重为 10# 高为 10  重为 5# 高为 30  重为 15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__mul__(self, other)</code>定义乘法的行为：<code>*</code></li><li><code>__truediv__(self, other)</code>定义真除法的行为：<code>/</code></li><li><code>__floordiv__(self, other)</code>定义整数除法的行为：<code>//</code></li><li><code>__mod__(self, other)</code> 定义取模算法的行为：<code>%</code></li><li><code>__divmod__(self, other)</code>定义当被 <code>divmod()</code> 调用时的行为</li><li><code>divmod(a, b)</code>把除数和余数运算结果结合起来，返回一个包含商和余数的元组<code>(a // b, a % b)</code>。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(divmod(7, 2))  # (3, 1)print(divmod(8, 2))  # (4, 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>__pow__(self, other[, module])</code>定义当被 <code>power()</code> 调用或 <code>**</code> 运算时的行为</li><li><code>__lshift__(self, other)</code>定义按位左移位的行为：<code>&lt;&lt;</code></li><li><code>__rshift__(self, other)</code>定义按位右移位的行为：<code>&gt;&gt;</code></li><li><code>__and__(self, other)</code>定义按位与操作的行为：<code>&amp;</code></li><li><code>__xor__(self, other)</code>定义按位异或操作的行为：<code>^</code></li><li><code>__or__(self, other)</code>定义按位或操作的行为：<code>|</code></li></ul><h3 id="反算术运算符"><a href="#反算术运算符" class="headerlink" title="反算术运算符"></a>反算术运算符</h3><p>反运算魔方方法，与算术运算符保持一一对应，不同之处就是反运算的魔法方法多了一个“r”。当文件左操作不支持相应的操作时被调用。</p><ul><li><code>__radd__(self, other)</code>定义加法的行为：<code>+</code></li><li><code>__rsub__(self, other)</code>定义减法的行为：<code>-</code></li><li><code>__rmul__(self, other)</code>定义乘法的行为：<code>*</code></li><li><code>__rtruediv__(self, other)</code>定义真除法的行为：<code>/</code></li><li><code>__rfloordiv__(self, other)</code>定义整数除法的行为：<code>//</code></li><li><code>__rmod__(self, other)</code> 定义取模算法的行为：<code>%</code></li><li><code>__rdivmod__(self, other)</code>定义当被 divmod() 调用时的行为</li><li><code>__rpow__(self, other[, module])</code>定义当被 power() 调用或 <code>**</code> 运算时的行为</li><li><code>__rlshift__(self, other)</code>定义按位左移位的行为：<code>&lt;&lt;</code></li><li><code>__rrshift__(self, other)</code>定义按位右移位的行为：<code>&gt;&gt;</code></li><li><code>__rand__(self, other)</code>定义按位与操作的行为：<code>&amp;</code></li><li><code>__rxor__(self, other)</code>定义按位异或操作的行为：<code>^</code></li><li><code>__ror__(self, other)</code>定义按位或操作的行为：<code>|</code></li></ul><p><code>a + b</code></p><p>这里加数是<code>a</code>，被加数是<code>b</code>，因此是<code>a</code>主动，反运算就是如果<code>a</code>对象的<code>__add__()</code>方法没有实现或者不支持相应的操作，那么 Python 就会调用<code>b</code>的<code>__radd__()</code>方法。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Nint(int):    def __radd__(self, other):        return int.__sub__(other, self) # 注意 self 在后面a &#x3D; Nint(5)b &#x3D; Nint(3)print(a + b)  # 8print(1 + b)  # -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增量赋值运算符"><a href="#增量赋值运算符" class="headerlink" title="增量赋值运算符"></a>增量赋值运算符</h3><ul><li><code>__iadd__(self, other)</code>定义赋值加法的行为：<code>+=</code></li><li><code>__isub__(self, other)</code>定义赋值减法的行为：<code>-=</code></li><li><code>__imul__(self, other)</code>定义赋值乘法的行为：<code>*=</code></li><li><code>__itruediv__(self, other)</code>定义赋值真除法的行为：<code>/=</code></li><li><code>__ifloordiv__(self, other)</code>定义赋值整数除法的行为：<code>//=</code></li><li><code>__imod__(self, other)</code>定义赋值取模算法的行为：<code>%=</code></li><li><code>__ipow__(self, other[, modulo])</code>定义赋值幂运算的行为：<code>**=</code></li><li><code>__ilshift__(self, other)</code>定义赋值按位左移位的行为：<code>&lt;&lt;=</code></li><li><code>__irshift__(self, other)</code>定义赋值按位右移位的行为：<code>&gt;&gt;=</code></li><li><code>__iand__(self, other)</code>定义赋值按位与操作的行为：<code>&amp;=</code></li><li><code>__ixor__(self, other)</code>定义赋值按位异或操作的行为：<code>^=</code></li><li><code>__ior__(self, other)</code>定义赋值按位或操作的行为：<code>|=</code></li></ul><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul><li><code>__neg__(self)</code>定义正号的行为：<code>+x</code></li><li><code>__pos__(self)</code>定义负号的行为：<code>-x</code></li><li><code>__abs__(self)</code>定义当被<code>abs()</code>调用时的行为</li><li><code>__invert__(self)</code>定义按位求反的行为：<code>~x</code></li></ul><h3 id="属性访问"><a href="#属性访问" class="headerlink" title="属性访问"></a>属性访问</h3><ul><li><code>__getattr__(self, name)</code>: 定义当用户试图获取一个不存在的属性时的行为。</li><li><code>__getattribute__(self, name)</code>：定义当该类的属性被访问时的行为（先调用该方法，查看是否存在该属性，若不存在，接着去调用<code>__getattr__</code>）。</li><li><code>__setattr__(self, name, value)</code>：定义当一个属性被设置时的行为。</li><li><code>__delattr__(self, name)</code>：定义当一个属性被删除时的行为。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class C:    def __getattribute__(self, item):        print(&#39;__getattribute__&#39;)        return super().__getattribute__(item)    def __getattr__(self, item):        print(&#39;__getattr__&#39;)    def __setattr__(self, key, value):        print(&#39;__setattr__&#39;)        super().__setattr__(key, value)    def __delattr__(self, item):        print(&#39;__delattr__&#39;)        super().__delattr__(item)c &#x3D; C()c.x# __getattribute__# __getattr__c.x &#x3D; 1# __setattr__del c.x# __delattr__<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h3><p>描述符就是将某种特殊类型的类的实例指派给另一个类的属性。</p><ul><li><code>__get__(self, instance, owner)</code>用于访问属性，它返回属性的值。</li><li><code>__set__(self, instance, value)</code>将在属性分配操作中调用，不返回任何内容。</li><li><code>__del__(self, instance)</code>控制删除操作，不返回任何内容。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class MyDecriptor:    def __get__(self, instance, owner):        print(&#39;__get__&#39;, self, instance, owner)    def __set__(self, instance, value):        print(&#39;__set__&#39;, self, instance, value)    def __delete__(self, instance):        print(&#39;__delete__&#39;, self, instance)class Test:    x &#x3D; MyDecriptor()t &#x3D; Test()t.x# __get__ &lt;__main__.MyDecriptor object at 0x000000CEAAEB6B00&gt; &lt;__main__.Test object at 0x000000CEABDC0898&gt; &lt;class &#39;__main__.Test&#39;&gt;t.x &#x3D; &#39;x-man&#39;# __set__ &lt;__main__.MyDecriptor object at 0x00000023687C6B00&gt; &lt;__main__.Test object at 0x00000023696B0940&gt; x-mandel t.x# __delete__ &lt;__main__.MyDecriptor object at 0x000000EC9B160A90&gt; &lt;__main__.Test object at 0x000000EC9B160B38&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定制序列"><a href="#定制序列" class="headerlink" title="定制序列"></a>定制序列</h3><p>协议（Protocols）与其它编程语言中的接口很相似，它规定你哪些方法必须要定义。然而，在 Python 中的协议就显得不那么正式。事实上，在 Python 中，协议更像是一种指南。</p><p><strong>容器类型的协议</strong></p><ul><li>如果说你希望定制的容器是不可变的话，你只需要定义<code>__len__()</code>和<code>__getitem__()</code>方法。</li><li>如果你希望定制的容器是可变的话，除了<code>__len__()</code>和<code>__getitem__()</code>方法，你还需要定义<code>__setitem__()</code>和<code>__delitem__()</code>两个方法。</li></ul><p>【例子】编写一个不可改变的自定义列表，要求记录列表中每个元素被访问的次数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class CountList:    def __init__(self, *args):        self.values &#x3D; [x for x in args]        self.count &#x3D; &#123;&#125;.fromkeys(range(len(self.values)), 0)    def __len__(self):        return len(self.values)    def __getitem__(self, item):        self.count[item] +&#x3D; 1        return self.values[item]c1 &#x3D; CountList(1, 3, 5, 7, 9)c2 &#x3D; CountList(2, 4, 6, 8, 10)print(c1[1])  # 3print(c2[2])  # 6print(c1[1] + c2[1])  # 7print(c1.count)# &#123;0: 0, 1: 2, 2: 0, 3: 0, 4: 0&#125;print(c2.count)# &#123;0: 0, 1: 1, 2: 1, 3: 0, 4: 0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>__len__(self)</code>定义当被<code>len()</code>调用时的行为（返回容器中元素的个数）。</li><li><code>__getitem__(self, key)</code>定义获取容器中元素的行为，相当于<code>self[key]</code>。</li><li><code>__setitem__(self, key, value)</code>定义设置容器中指定元素的行为，相当于<code>self[key] = value</code>。</li><li><code>__delitem__(self, key)</code>定义删除容器中指定元素的行为，相当于<code>del self[key]</code>。</li></ul><p>【例子】编写一个可改变的自定义列表，要求记录列表中每个元素被访问的次数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">- &#96;__len__(self)&#96;定义当被&#96;len()&#96;调用时的行为（返回容器中元素的个数）。- &#96;__getitem__(self, key)&#96;定义获取容器中元素的行为，相当于&#96;self[key]&#96;。- &#96;__setitem__(self, key, value)&#96;定义设置容器中指定元素的行为，相当于&#96;self[key] &#x3D; value&#96;。- &#96;__delitem__(self, key)&#96;定义删除容器中指定元素的行为，相当于&#96;del self[key]&#96;。【例子】编写一个可改变的自定义列表，要求记录列表中每个元素被访问的次数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul><li>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。</li><li>迭代器是一个可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。</li><li>迭代器只能往前不会后退。</li><li>字符串，列表或元组对象都可用于创建迭代器：</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">string &#x3D; &#39;lsgogroup&#39;for c in string:    print(c)&#39;&#39;&#39;lsgogroup&#39;&#39;&#39;for c in iter(string):    print(c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">links &#x3D; &#123;&#39;B&#39;: &#39;百度&#39;, &#39;A&#39;: &#39;阿里&#39;, &#39;T&#39;: &#39;腾讯&#39;&#125;for each in links:    print(&#39;%s -&gt; %s&#39; % (each, links[each]))    &#39;&#39;&#39;B -&gt; 百度A -&gt; 阿里T -&gt; 腾讯&#39;&#39;&#39;for each in iter(links):    print(&#39;%s -&gt; %s&#39; % (each, links[each]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代器有两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</li><li><code>iter(object)</code> 函数用来生成迭代器。</li><li><code>next(iterator[, default])</code> 返回迭代器的下一个项目。</li><li><code>iterator</code> – 可迭代对象</li><li><code>default</code> – 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 <code>StopIteration</code> 异常。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">links &#x3D; &#123;&#39;B&#39;: &#39;百度&#39;, &#39;A&#39;: &#39;阿里&#39;, &#39;T&#39;: &#39;腾讯&#39;&#125;it &#x3D; iter(links)while True:    try:        each &#x3D; next(it)    except StopIteration:        break    print(each)# B# A# Tit &#x3D; iter(links)print(next(it))  # Bprint(next(it))  # Aprint(next(it))  # Tprint(next(it))  # StopIteration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把一个类作为一个迭代器使用需要在类中实现两个魔法方法 <code>__iter__()</code> 与 <code>__next__()</code> 。</p><ul><li><code>__iter__(self)</code>定义当迭代容器中的元素的行为，返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。</li><li><code>__next__()</code> 返回下一个迭代器对象。</li><li><code>StopIteration</code> 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">class Fibs:    def __init__(self, n&#x3D;10):        self.a &#x3D; 0        self.b &#x3D; 1        self.n &#x3D; n    def __iter__(self):        return self    def __next__(self):        self.a, self.b &#x3D; self.b, self.a + self.b        if self.a &gt; self.n:            raise StopIteration        return self.afibs &#x3D; Fibs(100)for each in fibs:    print(each, end&#x3D;&#39; &#39;)# 1 1 2 3 5 8 13 21 34 55 89<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><b>4.10 生成器</b></p><ul><li>在 Python 中，使用了 <code>yield</code> 的函数被称为生成器（generator）。</li><li>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</li><li>在调用生成器运行的过程中，每次遇到 <code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code> 的值, 并在下一次执行 <code>next()</code> 方法时从当前位置继续运行。</li><li>调用一个生成器函数，返回的是一个迭代器对象。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def myGen():    print(&#39;生成器执行！&#39;)    yield 1    yield 2    myG &#x3D; myGen()for each in myG:    print(each)&#39;&#39;&#39;生成器执行！12&#39;&#39;&#39;myG &#x3D; myGen()print(next(myG))  # 生成器执行！# 1print(next(myG))  # 2print(next(myG))  # StopIteration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】用生成器实现斐波那契数列。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def libs(n):    a &#x3D; 0    b &#x3D; 1    while True:        a, b &#x3D; b, a + b        if a &gt; n:            return        yield afor each in libs(100):    print(each, end&#x3D;&#39; &#39;)# 1 1 2 3 5 8 13 21 34 55 89<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础入门：从变量到异常处理</title>
      <link href="2020/09/13/python-ji-chu-ru-men-cong-bian-liang-dao-yi-chang-chu-li/"/>
      <url>2020/09/13/python-ji-chu-ru-men-cong-bian-liang-dao-yi-chang-chu-li/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Python 是一种通用编程语言，其在科学计算和机器学习领域具有广泛的应用。如果我们打算利用 Python 来执行机器学习，那么对 Python 有一些基本的了解就是至关重要的。本 Python 入门系列体验就是为这样的初学者精心准备的。</p><p>本实验包括以下内容：</p><h2 id="变量、运算符与数据类型"><a href="#变量、运算符与数据类型" class="headerlink" title="变量、运算符与数据类型"></a>变量、运算符与数据类型</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><ul><li>在Python中，# 表示单行注释，作用于整行</li></ul><p>【例子】单行注释</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 单行注释print(&quot;单行注释&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>‘’’ ‘’’ 或者 “”” “”” 表示区间注释，在三引号之间的所有内容被注释</li></ul><p>【例子】 多行注释</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#39;&#39;&#39;单引号多行注释&#39;&#39;&#39;print(&quot;多行注释&quot;)&quot;&quot;&quot;双引号多行注释&quot;&quot;&quot;print(&quot;双引号多行注释&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2.运算符"></a>2.运算符</h3><p><strong>算术运算符</strong></p><table><thead><tr><th align="center">操作符</th><th align="center">名称</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>+</code></td><td align="center">加</td><td align="center"><code>1 + 1</code></td></tr><tr><td align="center"><code>-</code></td><td align="center">减</td><td align="center"><code>2 - 1</code></td></tr><tr><td align="center"><code>*</code></td><td align="center">乘</td><td align="center"><code>3 * 4</code></td></tr><tr><td align="center"><code>/</code></td><td align="center">除</td><td align="center"><code>3 / 4</code></td></tr><tr><td align="center"><code>//</code></td><td align="center">整除（地板除）</td><td align="center"><code>3 // 4</code></td></tr><tr><td align="center"><code>%</code></td><td align="center">取余</td><td align="center"><code>3 % 4</code></td></tr><tr><td align="center"><code>**</code></td><td align="center">幂</td><td align="center"><code>2 ** 3</code></td></tr></tbody></table><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(1 + 1)  # 2print(2 - 1)  # 1print(3 * 4)  # 12print(3 &#x2F; 4)  # 0.75print(3 &#x2F;&#x2F; 4) # 0print(3 % 4)  # 3print(2**3)   # 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>比较运算符</strong></p><table><thead><tr><th align="center">操作符</th><th align="center">名称</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>&gt;</code></td><td align="center">大于</td><td align="center"><code>2 &gt; 1</code></td></tr><tr><td align="center"><code>&gt;=</code></td><td align="center">大于等于</td><td align="center"><code>2 &gt;= 4</code></td></tr><tr><td align="center"><code>&lt;</code></td><td align="center">小于</td><td align="center"><code>1 &lt; 2</code></td></tr><tr><td align="center"><code>&lt;=</code></td><td align="center">小于等于</td><td align="center"><code>5 &lt;= 2</code></td></tr><tr><td align="center"><code>==</code></td><td align="center">等于</td><td align="center"><code>3 == 4</code></td></tr><tr><td align="center"><code>!=</code></td><td align="center">不等于</td><td align="center"><code>3 != 5</code></td></tr></tbody></table><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(2 &gt; 1)   # Trueprint(2 &gt;&#x3D; 4)  # Falseprint(1 &lt; 2)   # Trueprint(5 &lt;&#x3D; 2)  # Falseprint(3 &#x3D;&#x3D; 4)  # Falseprint(3 !&#x3D; 5)  # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>逻辑运算符</strong></p><table><thead><tr><th align="center">操作符</th><th align="center">名称</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>and</code></td><td align="center">与</td><td align="center"><code>(3 &gt; 2) and (3 &lt; 5)</code></td></tr><tr><td align="center"><code>or</code></td><td align="center">或</td><td align="center"><code>(1 &gt; 3) or (9 &lt; 2)</code></td></tr><tr><td align="center"><code>not</code></td><td align="center">非</td><td align="center"><code>not (2 &gt; 1)</code></td></tr></tbody></table><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print((3 &gt; 2) and (3 &lt; 5))  # Trueprint((1 &gt; 3) or (9 &lt; 89))  # Falseprint(not (2 &gt; 1))          # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>位运算符</strong></p><table><thead><tr><th align="center">操作符</th><th align="center">名称</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>~</code></td><td align="center">按位取反</td><td align="center"><code>~4</code></td></tr><tr><td align="center"><code>&amp;</code></td><td align="center">按位与</td><td align="center"><code>4 &amp; 5</code></td></tr><tr><td align="center">`</td><td align="center">`</td><td align="center">按位或</td></tr><tr><td align="center"><code>^</code></td><td align="center">按位异或</td><td align="center"><code>4 ^ 5</code></td></tr><tr><td align="center"><code>&lt;&lt;</code></td><td align="center">左移</td><td align="center"><code>4 &lt;&lt; 2</code></td></tr><tr><td align="center"><code>&gt;&gt;</code></td><td align="center">右移</td><td align="center"><code>4 &gt;&gt; 2</code></td></tr></tbody></table><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(bin(4))               # 0b100print(bin(5))               # 0b101print(bin(~4), ~4)          # -0b101 -5print(bin(4 &amp; 5), 4 &amp; 5)    # 0b100 4print(bin(4 | 5), 4 | 5)    # 0b101 5print(bin(4 ^ 5), 4 ^ 5)    # 0b1 1print(bin(4 &lt;&lt; 2), 4 &lt;&lt; 2)  # 0b10000 16print(bin(4 &gt;&gt; 2), 4 &gt;&gt; 2)  # 0b1 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>三元运算符</strong></p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x, y &#x3D; 4, 5if x &lt; y:    small &#x3D; xelse:    small &#x3D; yprint(small)  # 4x, y &#x3D; 4, 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了三元操作符的条件表达式，你可以使用一条语句来完成以上的条件判断和赋值操作。<br>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x, y &#x3D; 4, 5small &#x3D; x if x &lt; y else yprint(small)  # 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>其他运算符</strong></p><table><thead><tr><th align="center">操作符</th><th align="center">名称</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>in</code></td><td align="center">存在</td><td align="center"><code>&#39;A&#39; in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td></tr><tr><td align="center"><code>not in</code></td><td align="center">不存在</td><td align="center"><code>&#39;h&#39; not in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td></tr><tr><td align="center"><code>is</code></td><td align="center">是</td><td align="center"><code>&quot;hello&quot; is &quot;hello&quot;</code></td></tr><tr><td align="center"><code>not is</code></td><td align="center">不是</td><td align="center"><code>&quot;hello&quot; is not &quot;hello&quot;</code></td></tr></tbody></table><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">letters &#x3D; [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]if &#39;A&#39; in letters:    print(&#39;A&#39; + &#39; exists&#39;)if &#39;h&#39; not in letters:    print(&#39;h&#39; + &#39; not exists&#39;)# A exists# h not exists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】比较的两个变量均指向不可变类型。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; &quot;hello&quot;b &#x3D; &quot;hello&quot;print(a is b, a &#x3D;&#x3D; b)           # True Trueprint(a is not b, a !&#x3D; b)       # False False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】比较的两个变量均指向可变类型。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; [&quot;hello&quot;]b &#x3D; [&quot;hello&quot;]print(a is b, a &#x3D;&#x3D; b)       # False Trueprint(a is not b, a !&#x3D; b)   # True False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><ul><li>is, is not 对比的是两个变量的内存地址</li><li>==, != 对比的是两个变量的值</li><li>比较的两个变量，指向的都是地址不可变的类型（str等），那么is，is not 和 ==，！= 是完全等价的。</li><li>对比的两个变量，指向的是地址可变的类型（list，dict，tuple等），则两者是有区别的。</li></ul><p><strong>运算符的优先级</strong></p><ul><li>一元运算符优于二元运算符。例如<code>3 ** -2</code>等价于<code>3 ** (-2)</code>。</li><li>先算术运算，后移位运算，最后位运算。例如 <code>1 &lt;&lt; 3 + 2 &amp; 7</code>等价于 <code>(1 &lt;&lt; (3 + 2)) &amp; 7</code>。</li><li>逻辑运算最后结合。例如<code>3 &lt; 4 and 4 &lt; 5</code>等价于<code>(3 &lt; 4) and (4 &lt; 5)</code>。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(-3 ** 2)              # -9print(3 ** -2)              # 0.1111111111111111print(1 &lt;&lt; 3 + 2 &amp; 7)       # 0print(-3 * 2 + 5 &#x2F; -2 - 4)  # -12.5print(3 &lt; 4 and 4 &lt; 5)      # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-变量和赋值"><a href="#3-变量和赋值" class="headerlink" title="3. 变量和赋值"></a>3. 变量和赋值</h3><ul><li>在使用变量之前，需要对其先赋值。</li><li>变量名可以包括字母、数字、下划线、但变量名不能以数字开头。</li><li>Python 变量名是大小写敏感的，foo != Foo。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">teacher &#x3D; &quot;老马的程序人生&quot;print(teacher)  # 老马的程序人生first &#x3D; 2second &#x3D; 3third &#x3D; first + secondprint(third)  # 5myTeacher &#x3D; &quot;老马的程序人生&quot;yourTeacher &#x3D; &quot;小马的程序人生&quot;ourTeacher &#x3D; myTeacher + &#39;,&#39; + yourTeacherprint(ourTeacher)  # 老马的程序人生,小马的程序人生<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-数据类型与转换"><a href="#4-数据类型与转换" class="headerlink" title="4. 数据类型与转换"></a>4. 数据类型与转换</h3><table><thead><tr><th align="center">类型</th><th align="center">名称</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">整型 <code>&lt;class &#39;int&#39;&gt;</code></td><td align="center"><code>-876, 10</code></td></tr><tr><td align="center">float</td><td align="center">浮点型<code>&lt;class &#39;float&#39;&gt;</code></td><td align="center"><code>3.149, 11.11</code></td></tr><tr><td align="center">bool</td><td align="center">布尔型<code>&lt;class &#39;bool&#39;&gt;</code></td><td align="center"><code>True, False</code></td></tr></tbody></table><p><strong>整型</strong></p><p>【例子】通过 <code>print()</code> 可看出 <code>a</code> 的值，以及类 (class) 是<code>int</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; 1031print(a, type(a))# 1031 &lt;class &#39;int&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Python 里面万物皆对象（object），整型也不例外，只要是对象，就有相应的属性 （attributes） 和方法（methods）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">b &#x3D; dir(int)print(b)# [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;,# &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;,# &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;,# &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;,# &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;,# &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;,# &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;,# &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;,# &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;,# &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;,# &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;,# &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;,# &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;,# &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对它们有个大概印象就可以了，具体怎么用，需要哪些参数 （argument），还需要查文档。看个<code>bit_length()</code>的例子。</p><p>【例子】找到一个整数的二进制表示，再返回其长度。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; 1031print(bin(a))           # 0b10000000111print(a.bit_length())   # 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>浮点型</strong></p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(1, type(1))# 1 &lt;class &#39;int&#39;&gt;print(1., type(1.))# 1.0 &lt;class &#39;float&#39;&gt;a &#x3D; 0.00000023b &#x3D; 2.3e-7print(a)  # 2.3e-07print(b)  # 2.3e-07<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有时候我们想保留浮点型的小数点后 <code>n</code> 位。可以用 <code>decimal</code> 包里的 <code>Decimal</code> 对象和 <code>getcontext()</code> 方法来实现。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import decimalfrom decimal import Decimal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Python 里面有很多用途广泛的包 (package)，用什么你就引进 (import) 什么。包也是对象，也可以用上面提到的<code>dir(decimal)</code> 来看其属性和方法。</p><p>【例子】<code>getcontext()</code> 显示了 <code>Decimal</code> 对象的默认精度值是 28 位 (<code>prec=28</code>)。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import decimalfrom decimal import Decimaldecimal.getcontext().prec &#x3D; 4b &#x3D; Decimal(1) &#x2F; Decimal(3)print(b)decimal.getcontext().prec &#x3D; 4c &#x3D; Decimal(1012) &#x2F; Decimal(3)print(c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>布尔型</strong></p><p>布尔 (boolean) 型变量只能取两个值，<code>True</code> 和 <code>False</code>。当把布尔型变量用在数字运算中，用 <code>1</code> 和 <code>0</code> 代表 <code>True</code> 和 <code>False</code>。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(True + True)  # 2print(True + False)  # 1print(True * False)  # 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>除了直接给变量赋值 <code>True</code> 和 <code>False</code>，还可以用 <code>bool(X)</code> 来创建变量，其中 <code>X</code> 可以是</p><ul><li>基本类型：整型、浮点型、布尔型</li><li>容器类型：字符串、元组、列表、字典和集合</li></ul><p>【例子】<code>bool</code> 作用在基本类型变量：<code>X</code> 只要不是整型 <code>0</code>、浮点型 <code>0.0</code>，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p><p>确定<code>bool(X)</code> 的值是 <code>True</code> 还是 <code>False</code>，就看 <code>X</code> 是不是空，空的话就是 <code>False</code>，不空的话就是 <code>True</code>。</p><ul><li>对于数值变量，<code>0</code>, <code>0.0</code> 都可认为是空的。</li><li>对于容器变量，里面没元素就是空的。</li></ul><p><strong>获取类型信息</strong></p><ul><li>获取类型信息 <code>type(object)</code></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(isinstance(1, int))  # Trueprint(isinstance(5.2, float))  # Trueprint(isinstance(True, bool))  # Trueprint(isinstance(&#39;5.2&#39;, str))  # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注：</p><ul><li><code>type()</code> 不会认为子类是一种父类类型，不考虑继承关系。</li><li><code>isinstance()</code> 会认为子类是一种父类类型，考虑继承关系。</li></ul><p>如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。</p><p><strong>类型转换</strong></p><ul><li>转换为整型 <code>int(x, base=10)</code></li><li>转换为字符串 <code>str(object=&#39;&#39;)</code></li><li>转换为浮点型 <code>float(x)</code></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(int(&#39;520&#39;))  # 520print(int(520.52))  # 520print(float(&#39;520.52&#39;))  # 520.52print(float(520))  # 520.0print(str(10 + 10))  # 20print(str(10.1 + 5.2))  # 15.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-print-函数"><a href="#5-print-函数" class="headerlink" title="5. print() 函数"></a>5. print() 函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(*objects, sep&#x3D;&#39; &#39;, end&#x3D;&#39;\n&#39;, file&#x3D;sys.stdout, flush&#x3D;False)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>将对象以字符串表示的方式格式化输出到流文件对象file里。其中所有非关键字参数都按<code>str()</code>方式进行转换为字符串输出；</li><li>关键字参数<code>sep</code>是实现分隔符，比如多个参数输出时想要输出中间的分隔字符；</li><li>关键字参数<code>end</code>是输出结束时的字符，默认是换行符<code>\n</code>；</li><li>关键字参数<code>file</code>是定义流输出的文件，可以是标准的系统输出<code>sys.stdout</code>，也可以重定义为别的文件；</li><li>关键字参数<code>flush</code>是立即把内容输出到流文件，不作缓存。</li></ul><p>【例子】没有参数时，每次输出后都会换行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shoplist &#x3D; [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]print(&quot;This is printed without &#39;end&#39;and &#39;sep&#39;.&quot;)for item in shoplist:    print(item)# This is printed without &#39;end&#39;and &#39;sep&#39;.# apple# mango# carrot# banana<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】每次输出结束都用<code>end</code>设置的参数<code>&amp;</code>结尾，并没有默认换行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shoplist &#x3D; [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]print(&quot;This is printed with &#39;end&#x3D;&#39;&amp;&#39;&#39;.&quot;)for item in shoplist:    print(item, end&#x3D;&#39;&amp;&#39;)print(&#39;hello world&#39;)# This is printed with &#39;end&#x3D;&#39;&amp;&#39;&#39;.# apple&amp;mango&amp;carrot&amp;banana&amp;hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】<code>item</code>值与<code>&#39;another string&#39;</code>两个值之间用<code>sep</code>设置的参数<code>&amp;</code>分割。由于<code>end</code>参数没有设置，因此默认是输出解释后换行，即<code>end</code>参数的默认值为<code>\n</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shoplist &#x3D; [&#39;apple&#39;, &#39;mango&#39;, &#39;carrot&#39;, &#39;banana&#39;]print(&quot;This is printed with &#39;sep&#x3D;&#39;&amp;&#39;&#39;.&quot;)for item in shoplist:    print(item, &#39;another string&#39;, sep&#x3D;&#39;&amp;&#39;)# This is printed with &#39;sep&#x3D;&#39;&amp;&#39;&#39;.# apple&amp;another string# mango&amp;another string# carrot&amp;another string# banana&amp;another string<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h3 id="1-原码、反码和补码"><a href="#1-原码、反码和补码" class="headerlink" title="1. 原码、反码和补码"></a>1. 原码、反码和补码</h3><p>二进制有三种不同的表示形式：原码、反码和补码，<u>计算机内部使用补码来表示</u>。</p><p><strong>原码</strong>：就是其二进制表示（注意，有一位符号位,第一是符号位，0表示整数，1表示负数）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 00 11 -&gt; 310 00 00 11 -&gt; -3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>反码</strong>：正数的反码就是原码，负数的反码是符号位不变，其余位取反（对应正数按位取反）。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 00 11 -&gt; 311 11 11 00 -&gt; -3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>补码</strong>：正数的补码就是原码，负数的补码是反码+1。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 00 11 -&gt; 311 11 11 01 -&gt; -3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>符号位</strong>：最高位为符号位，0表示正数，1表示负数。在位运算中符号位也参与运算。</p><h3 id="2-按位运算"><a href="#2-按位运算" class="headerlink" title="2. 按位运算"></a>2. 按位运算</h3><ul><li>按位非操作 ~</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">~ 1 &#x3D; 0~ 0 &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>~</code> 把<code>num</code>的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 01 01 -&gt; 5~---11 11 10 10 -&gt; -611 11 10 11 -&gt; -5~---00 00 01 00 -&gt; 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>按位与操作 &amp;  </li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 &amp; 1 &#x3D; 11 &amp; 0 &#x3D; 00 &amp; 1 &#x3D; 00 &amp; 0 &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只有两个对应位都为 1 时才为 1</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 01 01 -&gt; 5&amp;00 00 01 10 -&gt; 6---00 00 01 00 -&gt; 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>按位或操作 |</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 | 1 &#x3D; 11 | 0 &#x3D; 10 | 1 &#x3D; 10 | 0 &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只要两个对应位中有一个 1 时就为 1</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 01 01 -&gt; 5|00 00 01 10 -&gt; 6---00 00 01 11 -&gt; 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>按位异或操作 ^</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">1 ^ 1 &#x3D; 01 ^ 0 &#x3D; 10 ^ 1 &#x3D; 10 ^ 0 &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只有两个对应位不同时才为 1</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 01 01 -&gt; 5^00 00 01 10 -&gt; 6---00 00 00 11 -&gt; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>异或操作的性质：满足交换律和结合律</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">A: 00 00 11 00B: 00 00 01 11A^B: 00 00 10 11B^A: 00 00 10 11A^A: 00 00 00 00A^0: 00 00 11 00A^B^A: &#x3D; A^A^B &#x3D; B &#x3D; 00 00 01 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>按位左移操作 &lt;&lt;</li></ul><p><code>num &lt;&lt; i</code> 将<code>num</code>的二进制表示向左移动<code>i</code>位所得的值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 10 11 -&gt; 1111 &lt;&lt; 3---01 01 10 00 -&gt; 88 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>按位右移操作 &gt;&gt;</li></ul><p><code>num &gt;&gt; i</code> 将<code>num</code>的二进制表示向右移动<code>i</code>位所得的值。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 10 11 -&gt; 1111 &gt;&gt; 2---00 00 00 10 -&gt; 2 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-利用位运算实现快速计算"><a href="#3-利用位运算实现快速计算" class="headerlink" title="3. 利用位运算实现快速计算"></a>3. 利用位运算实现快速计算</h3><p>通过 <code>&lt;&lt;</code>，<code>&gt;&gt;</code> 快速计算2的倍数问题。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">n &lt;&lt; 1 -&gt; 计算 n*2n &gt;&gt; 1 -&gt; 计算 n&#x2F;2，负奇数的运算不可用n &lt;&lt; m -&gt; 计算 n*(2^m)，即乘以 2 的 m 次方n &gt;&gt; m -&gt; 计算 n&#x2F;(2^m)，即除以 2 的 m 次方1 &lt;&lt; n -&gt; 2^n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 <code>^</code> 快速交换两个整数。（异或交换律）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a ^&#x3D; bb ^&#x3D; aa ^&#x3D; b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过 <code>a &amp; (-a)</code> 快速获取<code>a</code>的最后为 1 位置的整数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">00 00 01 01 -&gt; 5&amp;11 11 10 11 -&gt; -5---00 00 00 01 -&gt; 100 00 11 10 -&gt; 14&amp;11 11 00 10 -&gt; -14---00 00 00 10 -&gt; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-利用位运算实现整数集合"><a href="#4-利用位运算实现整数集合" class="headerlink" title="4. 利用位运算实现整数集合"></a>4. 利用位运算实现整数集合</h3><p>一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。</p><p>比如集合 <code>&#123;1, 3, 4, 8&#125;</code>，可以表示成 <code>01 00 01 10 10</code> 而对应的位运算也就可以看作是对集合进行的操作。</p><p>元素与集合的操作：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a | (1&lt;&lt;i)  -&gt; 把 i 插入到集合中a &amp; ~(1&lt;&lt;i) -&gt; 把 i 从集合中删除a &amp; (1&lt;&lt;i)  -&gt; 判断 i 是否属于该集合（零不属于，非零属于）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>集合之间的操作：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a 补   -&gt; ~aa 交 b -&gt; a &amp; ba 并 b -&gt; a | ba 差 b -&gt; a &amp; (~b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：整数在内存中是以补码的形式存在的，输出自然也是按照补码输出。</p><p>【例子】C#语言输出负数。</p><pre class="line-numbers language-C#" data-language="C#"><code class="language-C#">class Program&#123;    static void Main(string[] args)    &#123;        string s1 &#x3D; Convert.ToString(-3, 2);        Console.WriteLine(s1);         &#x2F;&#x2F; 11111111111111111111111111111101                string s2 &#x3D; Convert.ToString(-3, 16);        Console.WriteLine(s2);         &#x2F;&#x2F; fffffffd    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】 Python 的<code>bin()</code> 输出。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(bin(3))  # 0b11print(bin(-3))  # -0b11print(bin(-3 &amp; 0xffffffff))  # 0b11111111111111111111111111111101print(bin(0xfffffffd))       # 0b11111111111111111111111111111101print(0xfffffffd)  # 4294967293<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是很颠覆认知，我们从结果可以看出：</p><ul><li>Python中<code>bin</code>一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，巨坑。</li><li>Python中的整型是补码形式存储的。</li><li>Python中整型是不限制长度的不会超范围溢出。</li></ul><p>所以为了获得负数（十进制表示）的补码，需要手动将其和十六进制数<code>0xffffffff</code>进行按位与操作，再交给<code>bin()</code>进行输出，得到的才是负数的补码表示。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">if expression:    expr_true_suite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>if 语句的 <code>expr_true_suite</code> 代码块只有当条件表达式 <code>expression</code> 结果为真时才执行，否则将继续执行紧跟在该代码块后面的语句。</li><li>单个 if 语句中的 <code>expression</code> 条件表达式可以通过布尔操作符 <code>and</code>，<code>or</code>和<code>not</code> 实现多重条件判断。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if 2 &gt; 1 and not 2 &gt; 3:    print(&#39;Correct Judgement!&#39;)# Correct Judgement!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-if-else-语句"><a href="#2-if-else-语句" class="headerlink" title="2. if - else 语句"></a>2. if - else 语句</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">if expression:    expr_true_suiteelse:    expr_false_suite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Python 提供与 if 搭配使用的 else，如果 if 语句的条件表达式结果布尔值为假，那么程序将执行 else 语句后的代码。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">temp &#x3D; input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)guess &#x3D; int(temp) # input 函数将接收的任何数据类型都默认为 str。if guess &#x3D;&#x3D; 666:    print(&quot;你太了解小姐姐的心思了！&quot;)    print(&quot;哼，猜对也没有奖励！&quot;)else:    print(&quot;猜错了，小姐姐现在心里想的是666！&quot;)print(&quot;游戏结束，不玩儿啦！&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>if</code>语句支持嵌套，即在一个<code>if</code>语句中嵌入另一个<code>if</code>语句，从而构成不同层次的选择结构。</p><p>【例子】Python 使用缩进而不是大括号来标记代码块边界，因此要特别注意<code>else</code>的悬挂问题。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">hi &#x3D; 6if hi &gt; 2:    if hi &gt; 7:        print(&#39;好棒!好棒!&#39;)else:    print(&#39;切~&#39;)# 无输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">temp &#x3D; input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)guess &#x3D; int(temp)if guess &gt; 8:    print(&quot;大了，大了&quot;)else:    if guess &#x3D;&#x3D; 8:        print(&quot;你太了解小姐姐的心思了！&quot;)        print(&quot;哼，猜对也没有奖励！&quot;)    else:        print(&quot;小了，小了&quot;)print(&quot;游戏结束，不玩儿啦！&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-if-elif-else-语句"><a href="#3-if-elif-else-语句" class="headerlink" title="3. if - elif - else 语句"></a>3. if - elif - else 语句</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">if expression1:    expr1_true_suiteelif expression2:    expr2_true_suite    .    .elif expressionN:    exprN_true_suiteelse:    expr_false_suite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>elif 语句即为 else if，用来检查多个表达式是否为真，并在为真时执行特定代码块中的代码。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">temp &#x3D; input(&#39;请输入成绩:&#39;)source &#x3D; int(temp)if 100 &gt;&#x3D; source &gt;&#x3D; 90:    print(&#39;A&#39;)elif 90 &gt; source &gt;&#x3D; 80:    print(&#39;B&#39;)elif 80 &gt; source &gt;&#x3D; 60:    print(&#39;C&#39;)elif 60 &gt; source &gt;&#x3D; 0:    print(&#39;D&#39;)else:    print(&#39;输入错误！&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-assert-关键词"><a href="#4-assert-关键词" class="headerlink" title="4. assert 关键词"></a>4. assert 关键词</h3><ul><li><code>assert</code>这个关键词我们称之为“断言”，当这个关键词后边的条件为 False 时，程序自动崩溃并抛出<code>AssertionError</code>的异常。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">my_list &#x3D; [&#39;lsgogroup&#39;]my_list.pop(0)assert len(my_list) &gt; 0# AssertionError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">assert 3 &gt; 7# AssertionError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a>1. while 循环</h3><p><code>while</code>语句最基本的形式包括一个位于顶部的布尔表达式，一个或多个属于<code>while</code>代码块的缩进语句。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">while 布尔表达式:    代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>while</code>循环的代码块会一直循环执行，直到布尔表达式的值为布尔假。</p><p>如果布尔表达式不带有<code>&lt;、&gt;、==、！=、in、not in</code>等运算符，仅仅给出数值之类的条件，也是可以的。当<code>while</code>后写入一个非零整数时，视为真值，执行循环体；写入<code>0</code>时，视为假值，不执行循环体。也可以写入<code>str、list</code>或任何序列，长度非零则视为真值，执行循环体；否则视为假值，不执行循环体。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">count &#x3D; 0while count &lt; 3:    temp &#x3D; input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)    guess &#x3D; int(temp)    if guess &gt; 8:        print(&quot;大了，大了&quot;)    else:        if guess &#x3D;&#x3D; 8:            print(&quot;你太了解小姐姐的心思了！&quot;)            print(&quot;哼，猜对也没有奖励！&quot;)            count &#x3D; 3        else:            print(&quot;小了，小了&quot;)    count &#x3D; count + 1print(&quot;游戏结束，不玩儿啦！&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2-while-else-循环"><a href="#2-while-else-循环" class="headerlink" title="2. while - else 循环"></a>2. while - else 循环</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">while 布尔表达式:    代码块else:    代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当<code>while</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>while</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容。    </p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">count &#x3D; 0while count &lt; 5:    print(&quot;%d is  less than 5&quot; % count)    count &#x3D; count + 1else:    print(&quot;%d is not less than 5&quot; % count)    # 0 is  less than 5# 1 is  less than 5# 2 is  less than 5# 3 is  less than 5# 4 is  less than 5# 5 is not less than 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">count &#x3D; 0while count &lt; 5:    print(&quot;%d is  less than 5&quot; % count)    count &#x3D; 6    breakelse:    print(&quot;%d is not less than 5&quot; % count)# 0 is  less than 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h3><p><code>for</code>循环是迭代循环，在Python中相当于一个通用的序列迭代器，可以遍历任何有序序列，如<code>str、list、tuple</code>等，也可以遍历任何可迭代对象，如<code>dict</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for 迭代变量 in 可迭代对象:    代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>每次循环，迭代变量被设置为可迭代对象的当前元素，提供给代码块使用。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i in &#39;ILoveLSGO&#39;:    print(i, end&#x3D;&#39; &#39;)  # 不换行输出# I L o v e L S G O<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">member &#x3D; [&#39;张三&#39;, &#39;李四&#39;, &#39;刘德华&#39;, &#39;刘六&#39;, &#39;周润发&#39;]for each in member:    print(each)# 张三# 李四# 刘德华# 刘六# 周润发for i in range(len(member)):    print(member[i])# 张三# 李四# 刘德华# 刘六# 周润发<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;for key, value in dic.items():    print(key, value, sep&#x3D;&#39;:&#39;, end&#x3D;&#39; &#39;)    # a:1 b:2 c:3 d:4 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;for key in dic.keys():    print(key, end&#x3D;&#39; &#39;)    # a b c d <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;for value in dic.values():    print(value, end&#x3D;&#39; &#39;)    # 1 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="4-for-else-循环"><a href="#4-for-else-循环" class="headerlink" title="4. for - else 循环"></a>4. for - else 循环</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">for 迭代变量 in 可迭代对象:    代码块else:    代码块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当<code>for</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>for</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容，与<code>while - else</code>语句一样。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for num in range(10, 20):  # 迭代 10 到 20 之间的数字    for i in range(2, num):  # 根据因子迭代        if num % i &#x3D;&#x3D; 0:  # 确定第一个因子            j &#x3D; num &#x2F; i  # 计算第二个因子            print(&#39;%d 等于 %d * %d&#39; % (num, i, j))            break  # 跳出当前循环    else:  # 循环的 else 部分        print(num, &#39;是一个质数&#39;)# 10 等于 2 * 5# 11 是一个质数# 12 等于 2 * 6# 13 是一个质数# 14 等于 2 * 7# 15 等于 3 * 5# 16 等于 2 * 8# 17 是一个质数# 18 等于 2 * 9# 19 是一个质数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="5-range-函数"><a href="#5-range-函数" class="headerlink" title="5. range() 函数"></a>5. range() 函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">range([start,] stop[, step&#x3D;1])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>这个BIF（Built-in functions）有三个参数，其中用中括号括起来的两个表示这两个参数是可选的。</li><li><code>step=1</code> 表示第三个参数的默认值是1。</li><li><code>range</code> 这个BIF的作用是生成一个从<code>start</code>参数的值开始到<code>stop</code>参数的值结束的数字序列，该序列包含<code>start</code>的值但不包含<code>stop</code>的值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i in range(2, 9):  # 不包含9    print(i)# 2# 3# 4# 5# 6# 7# 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i in range(1, 10, 2):    print(i)# 1# 3# 5# 7# 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="6-enumerate-函数"><a href="#6-enumerate-函数" class="headerlink" title="6. enumerate()函数"></a>6. enumerate()函数</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">enumerate(sequence, [start&#x3D;0])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>sequence：一个序列、迭代器或其他支持迭代对象。</li><li>start：下标起始位置。</li><li>返回 enumerate(枚举) 对象</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">seasons &#x3D; [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;]lst &#x3D; list(enumerate(seasons))print(lst)# [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]lst &#x3D; list(enumerate(seasons, start&#x3D;1))  # 下标从 1 开始print(lst)# [(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>enumerate()</code>与 for 循环的结合使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i, a in enumerate(A)    do something with a  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>用 <code>enumerate(A)</code> 不仅返回了 <code>A</code> 中的元素，还顺便给该元素一个索引值 (默认从 0 开始)。此外，用 <code>enumerate(A, j)</code> 还可以确定索引起始值为 <code>j</code>。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">languages &#x3D; [&#39;Python&#39;, &#39;R&#39;, &#39;Matlab&#39;, &#39;C++&#39;]for language in languages:    print(&#39;I love&#39;, language)print(&#39;Done!&#39;)# I love Python# I love R# I love Matlab# I love C++# Done!for i, language in enumerate(languages, 2):    print(i, &#39;I love&#39;, language)print(&#39;Done!&#39;)# 2 I love Python# 3 I love R# 4 I love Matlab# 5 I love C++# Done!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="7-break-语句"><a href="#7-break-语句" class="headerlink" title="7. break 语句"></a>7. break 语句</h3><p><code>break</code>语句可以跳出当前所在层的循环。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import randomsecret &#x3D; random.randint(1, 10) #[1,10]之间的随机数while True:    temp &#x3D; input(&quot;猜一猜小姐姐想的是哪个数字？&quot;)    guess &#x3D; int(temp)    if guess &gt; secret:        print(&quot;大了，大了&quot;)    else:        if guess &#x3D;&#x3D; secret:            print(&quot;你太了解小姐姐的心思了！&quot;)            print(&quot;哼，猜对也没有奖励！&quot;)            break        else:            print(&quot;小了，小了&quot;)print(&quot;游戏结束，不玩儿啦！&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="8-continue-语句"><a href="#8-continue-语句" class="headerlink" title="8. continue 语句"></a>8. continue 语句</h3><p><code>continue</code>终止本轮循环并开始下一轮循环。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i in range(10):    if i % 2 !&#x3D; 0:        print(i)        continue    i +&#x3D; 2    print(i)# 2# 1# 4# 3# 6# 5# 8# 7# 10# 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="9-pass-语句"><a href="#9-pass-语句" class="headerlink" title="9. pass 语句"></a>9. pass 语句</h3><p><code>pass</code> 语句的意思是“不做任何事”，如果你在需要有语句的地方不写任何语句，那么解释器会提示出错，而 <code>pass</code> 语句就是用来解决这些问题的。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def a_func():# SyntaxError: unexpected EOF while parsing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def a_func():    pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>pass</code>是空语句，不做任何操作，只起到占位的作用，其作用是为了保持程序结构的完整性。尽管<code>pass</code>语句不做任何操作，但如果暂时不确定要在一个位置放上什么样的代码，可以先放置一个<code>pass</code>语句，让代码可以正常运行。</p><hr><h3 id="10-推导式"><a href="#10-推导式" class="headerlink" title="10. 推导式"></a>10. 推导式</h3><h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">[ expr for value in collection [if condition] ]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [-4, -2, 0, 2, 4]y &#x3D; [a * 2 for a in x]print(y)# [-8, -4, 0, 4, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [i ** 2 for i in range(1, 10)]print(x)# [1, 4, 9, 16, 25, 36, 49, 64, 81]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [(i, i ** 2) for i in range(6)]print(x)# [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [i for i in range(100) if (i % 2) !&#x3D; 0 and (i % 3) &#x3D;&#x3D; 0]print(x)# [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; [(i, j) for i in range(0, 3) for j in range(0, 3)]print(a)# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [[i, j] for i in range(0, 3) for j in range(0, 3)]print(x)# [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]x[0][0] &#x3D; 10print(x)# [[10, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; [(i, j) for i in range(0, 3) if i &lt; 1 for j in range(0, 3) if j &gt; 1]print(a)# [(0, 2)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">( expr for value in collection [if condition] )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; (x for x in range(10))print(a)# &lt;generator object &lt;genexpr&gt; at 0x0000025BE511CC48&gt;print(tuple(a))# (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#123; key_expr: value_expr for value in collection [if condition] &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">b &#x3D; &#123;i: i % 2 &#x3D;&#x3D; 0 for i in range(10) if i % 3 &#x3D;&#x3D; 0&#125;print(b)# &#123;0: True, 3: False, 6: True, 9: False&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">&#123; expr for value in collection [if condition] &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">c &#x3D; &#123;i for i in [1, 2, 3, 4, 5, 5, 6, 4, 3, 2, 1]&#125;print(c)# &#123;1, 2, 3, 4, 5, 6&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><code>next(iterator[, default])</code> Return the next item from the iterator. If default is given and the iterator is exhausted, it is returned instead of raising Stop Iteration.</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">e &#x3D; (i for i in range(10))print(e)# &lt;generator object &lt;genexpr&gt; at 0x0000007A0B8D01B0&gt;print(next(e))  # 0print(next(e))  # 1for each in e:    print(each, end&#x3D;&#39; &#39;)# 2 3 4 5 6 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; sum([i for i in range(101)])print(s)  # 5050s &#x3D; sum((i for i in range(101)))print(s)  # 5050<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而恢复程序的正常运行。</p><h3 id="1-Python-标准异常总结"><a href="#1-Python-标准异常总结" class="headerlink" title="1. Python 标准异常总结"></a>1. Python 标准异常总结</h3><ul><li>BaseException：所有异常的 <strong>基类</strong></li><li>Exception：常规异常的 <strong>基类</strong></li><li>StandardError：所有的内建标准异常的基类</li><li>ArithmeticError：所有数值计算异常的基类</li><li>FloatingPointError：浮点计算异常</li><li><u>OverflowError</u>：数值运算超出最大限制</li><li><u>ZeroDivisionError</u>：除数为零</li><li><u>AssertionError</u>：断言语句（assert）失败</li><li><u>AttributeError</u>：尝试访问未知的对象属性</li><li>EOFError：没有内建输入，到达EOF标记</li><li>EnvironmentError：操作系统异常的基类</li><li>IOError：输入/输出操作失败</li><li><u>OSError</u>：操作系统产生的异常（例如打开一个不存在的文件）</li><li>WindowsError：系统调用失败</li><li><u>ImportError</u>：导入模块失败的时候</li><li>KeyboardInterrupt：用户中断执行</li><li>LookupError：无效数据查询的基类</li><li><u>IndexError</u>：索引超出序列的范围</li><li><u>KeyError</u>：字典中查找一个不存在的关键字</li><li><u>MemoryError</u>：内存溢出（可通过删除对象释放内存）</li><li><u>NameError</u>：尝试访问一个不存在的变量</li><li>UnboundLocalError：访问未初始化的本地变量</li><li>ReferenceError：弱引用试图访问已经垃圾回收了的对象</li><li>RuntimeError：一般的运行时异常</li><li>NotImplementedError：尚未实现的方法</li><li><u>SyntaxError</u>：语法错误导致的异常</li><li>IndentationError：缩进错误导致的异常</li><li>TabError：Tab和空格混用</li><li>SystemError：一般的解释器系统异常</li><li><u>TypeError</u>：不同类型间的无效操作</li><li><u>ValueError</u>：传入无效的参数</li><li>UnicodeError：Unicode相关的异常</li><li>UnicodeDecodeError：Unicode解码时的异常</li><li>UnicodeEncodeError：Unicode编码错误导致的异常</li><li>UnicodeTranslateError：Unicode转换错误导致的异常</li></ul><p>异常体系内部有层次关系，Python异常体系中的部分关系如下所示：</p><p><img src="https://gitee.com/niu_dehua/oss/raw/master/uPic/SF51E36otkNDlQ9.png"></p><hr><h3 id="2-Python标准警告总结"><a href="#2-Python标准警告总结" class="headerlink" title="2. Python标准警告总结"></a>2. Python标准警告总结</h3><ul><li><p>Warning：警告的基类</p></li><li><p>DeprecationWarning：关于被弃用的特征的警告</p></li><li><p>FutureWarning：关于构造将来语义会有改变的警告</p></li><li><p>UserWarning：用户代码生成的警告</p></li><li><p>PendingDeprecationWarning：关于特性将会被废弃的警告</p></li><li><p>RuntimeWarning：可疑的运行时行为(runtime behavior)的警告</p></li><li><p>SyntaxWarning：可疑语法的警告</p></li><li><p>ImportWarning：用于在导入模块过程中触发的警告</p></li><li><p>UnicodeWarning：与Unicode相关的警告</p></li><li><p>BytesWarning：与字节或字节码相关的警告</p></li><li><p>ResourceWarning：与资源使用相关的警告</p><hr></li></ul><h3 id="3-try-except-语句"><a href="#3-try-except-语句" class="headerlink" title="3. try - except 语句"></a>3. try - except 语句</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    检测范围except Exception[as reason]:    出现异常后的处理代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>try 语句按照如下方式工作：</p><ul><li>首先，执行<code>try</code>子句（在关键字<code>try</code>和关键字<code>except</code>之间的语句）</li><li>如果没有异常发生，忽略<code>except</code>子句，<code>try</code>子句执行后结束。</li><li>如果在执行<code>try</code>子句的过程中发生了异常，那么<code>try</code>子句余下的部分将被忽略。如果异常的类型和<code>except</code>之后的名称相符，那么对应的<code>except</code>子句将被执行。最后执行<code>try - except</code>语句之后的代码。</li><li>如果一个异常没有与任何的<code>except</code>匹配，那么这个异常将会传递给上层的<code>try</code>中。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    f &#x3D; open(&#39;test.txt&#39;)    print(f.read())    f.close()except OSError:    print(&#39;打开文件出错&#39;)# 打开文件出错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    f &#x3D; open(&#39;test.txt&#39;)    print(f.read())    f.close()except OSError as error:    print(&#39;打开文件出错\n原因是：&#39; + str(error))# 打开文件出错# 原因是：[Errno 2] No such file or directory: &#39;test.txt&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】一个<code>try</code>语句可能包含多个<code>except</code>子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    int(&quot;abc&quot;)    s &#x3D; 1 + &#39;1&#39;    f &#x3D; open(&#39;test.txt&#39;)    print(f.read())    f.close()except OSError as error:    print(&#39;打开文件出错\n原因是：&#39; + str(error))except TypeError as error:    print(&#39;类型出错\n原因是：&#39; + str(error))except ValueError as error:    print(&#39;数值出错\n原因是：&#39; + str(error))# 数值出错# 原因是：invalid literal for int() with base 10: &#39;abc&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】<code>try-except-else</code>语句尝试查询不在<code>dict</code>中的键值对，从而引发了异常。这一异常准确地说应属于<code>KeyError</code>，但由于<code>KeyError</code>是<code>LookupError</code>的子类，且将<code>LookupError</code>置于<code>KeyError</code>之前，因此程序优先执行该<code>except</code>代码块。所以，使用多个<code>except</code>代码块时，必须坚持对其规范排序，要从最具针对性的异常到最通用的异常。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dict1 &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;v&#39;: 22&#125;try:    x &#x3D; dict1[&#39;y&#39;]except LookupError:    print(&#39;查询错误&#39;)except KeyError:    print(&#39;键错误&#39;)else:    print(x)    # 查询错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dict1 &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;v&#39;: 22&#125;try:    x &#x3D; dict1[&#39;y&#39;]except KeyError:    print(&#39;键错误&#39;)except LookupError:    print(&#39;查询错误&#39;)else:    print(x)# 键错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】一个 <code>except</code> 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    s &#x3D; 1 + &#39;1&#39;    int(&quot;abc&quot;)    f &#x3D; open(&#39;test.txt&#39;)    print(f.read())    f.close()except (OSError, TypeError, ValueError) as error:    print(&#39;出错了！\n原因是：&#39; + str(error))# 出错了！# 原因是：unsupported operand type(s) for +: &#39;int&#39; and &#39;str&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="4-try-except-finally-语句"><a href="#4-try-except-finally-语句" class="headerlink" title="4. try - except - finally 语句"></a>4. try - except - finally 语句</h3><p>try:<br>    检测范围<br>except Exception[as reason]:<br>    出现异常后的处理代码<br>finally:<br>    无论如何都会被执行的代码</p><p>不管<code>try</code>子句里面有没有发生异常，<code>finally</code>子句都会执行。</p><p>【例子】如果一个异常在<code>try</code>子句里被抛出，而又没有任何的<code>except</code>把它截住，那么这个异常会在<code>finally</code>子句执行后被抛出。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def divide(x, y):    try:        result &#x3D; x &#x2F; y        print(&quot;result is&quot;, result)    except ZeroDivisionError:        print(&quot;division by zero!&quot;)    finally:        print(&quot;executing finally clause&quot;)divide(2, 1)# result is 2.0# executing finally clausedivide(2, 0)# division by zero!# executing finally clausedivide(&quot;2&quot;, &quot;1&quot;)# executing finally clause# TypeError: unsupported operand type(s) for &#x2F;: &#39;str&#39; and &#39;str&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="5-try-except-else-语句"><a href="#5-try-except-else-语句" class="headerlink" title="5. try - except - else 语句"></a>5. try - except - else 语句</h3><p>如果在<code>try</code>子句执行时没有发生异常，Python将执行<code>else</code>语句后的语句。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    检测范围except:    出现异常后的处理代码else:    如果没有异常执行这块代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>except</code>而不带任何异常类型，这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息，因为它捕获所有的异常。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    检测范围except(Exception1[, Exception2[,...ExceptionN]]]):   发生以上多个异常中的一个，执行这块代码else:    如果没有异常执行这块代码    【例子】<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    fh &#x3D; open(&quot;testfile.txt&quot;, &quot;w&quot;)    fh.write(&quot;这是一个测试文件，用于测试异常!!&quot;)except IOError:    print(&quot;Error: 没有找到文件或读取文件失败&quot;)else:    print(&quot;内容写入文件成功&quot;)    fh.close()# 内容写入文件成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<code>else</code>语句的存在必须以<code>except</code>语句的存在为前提，在没有<code>except</code>语句的<code>try</code>语句中使用<code>else</code>语句，会引发语法错误。</p><hr><h3 id="6-raise语句"><a href="#6-raise语句" class="headerlink" title="6. raise语句"></a>6. raise语句</h3><p>Python 使用<code>raise</code>语句抛出一个指定的异常。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    raise NameError(&#39;HiThere&#39;)except NameError:    print(&#39;An exception flew by!&#39;)    # An exception flew by!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础练习：数据结构大汇总</title>
      <link href="2020/09/12/python-ji-chu-lian-xi-shu-ju-jie-gou-da-hui-zong/"/>
      <url>2020/09/12/python-ji-chu-lian-xi-shu-ju-jie-gou-da-hui-zong/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Python 是一种通用编程语言，其在科学计算和机器学习领域具有广泛的应用。如果我们打算利用 Python 来执行机器学习，那么对 Python 有一些基本的了解就是至关重要的。本 Python 入门系列体验就是为这样的初学者精心准备的。</p><p><strong>本实验包括以下内容</strong>：</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>简单数据类型</p><ul><li>整型<code>&lt;class &#39;int&#39;&gt;</code></li><li>浮点型<code>&lt;class &#39;float&#39;&gt;</code></li><li>布尔型<code>&lt;class &#39;bool&#39;&gt;</code></li></ul><p>容器数据类型</p><ul><li>列表<code>&lt;class &#39;list&#39;&gt;</code></li><li>元组<code>&lt;class &#39;tuple&#39;&gt;</code></li><li>字典<code>&lt;class &#39;dict&#39;&gt;</code></li><li>集合<code>&lt;class &#39;set&#39;&gt;</code></li><li>字符串<code>&lt;class &#39;str&#39;&gt;</code></li></ul><h3 id="1-列表的定义"><a href="#1-列表的定义" class="headerlink" title="1. 列表的定义"></a>1. 列表的定义</h3><p>列表是有序集合，没有固定大小，能够保存任意数量任意类型的 Python 对象，语法为 <code>[元素1, 元素2, ..., 元素n]</code>。</p><ul><li>关键点是「中括号 []」和「逗号 ,」</li><li>中括号 把所有元素绑在一起</li><li>逗号 将每个元素一一分开</li></ul><h3 id="2-列表的创建"><a href="#2-列表的创建" class="headerlink" title="2. 列表的创建"></a>2. 列表的创建</h3><ul><li>创建一个普通列表</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]print(x, type(x))# [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;] &lt;class &#39;list&#39;&gt;x &#x3D; [2, 3, 4, 5, 6, 7]print(x, type(x))# [2, 3, 4, 5, 6, 7] &lt;class &#39;list&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>利用<code>range()</code>创建列表</li></ul><p>【例子】 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; list(range(10))print(x, type(x))# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class &#39;list&#39;&gt;x &#x3D; list(range(1, 11, 2))print(x, type(x))# [1, 3, 5, 7, 9] &lt;class &#39;list&#39;&gt;x &#x3D; list(range(10, 1, -2))print(x, type(x))# [10, 8, 6, 4, 2] &lt;class &#39;list&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>利用推导式创建列表</li></ul><p>【例子】 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [0] * 5print(x, type(x))# [0, 0, 0, 0, 0] &lt;class &#39;list&#39;&gt;x &#x3D; [0 for i in range(5)]print(x, type(x))# [0, 0, 0, 0, 0] &lt;class &#39;list&#39;&gt;x &#x3D; [i for i in range(10)]print(x, type(x))# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class &#39;list&#39;&gt;x &#x3D; [i for i in range(1, 10, 2)]print(x, type(x))# [1, 3, 5, 7, 9] &lt;class &#39;list&#39;&gt;x &#x3D; [i for i in range(10, 1, -2)]print(x, type(x))# [10, 8, 6, 4, 2] &lt;class &#39;list&#39;&gt;x &#x3D; [i ** 2 for i in range(1, 10)]print(x, type(x))# [1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class &#39;list&#39;&gt;x &#x3D; [i for i in range(100) if (i % 2) !&#x3D; 0 and (i % 3) &#x3D;&#x3D; 0]print(x, type(x))# [3, 9, 15, 21, 27, 33, 39,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：</p><p>由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。即使保存一个简单的<code>[1,2,3]</code>，也有3个指针和3个整数对象。</p><p><code>x = [a] * 4</code>操作中，只是创建4个指向list的引用，所以一旦<code>a</code>改变，<code>x</code>中4个<code>a</code>也会随之改变。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [[0] * 3] * 4print(x, type(x))# [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class &#39;list&#39;&gt;x[0][0] &#x3D; 1print(x, type(x))# [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class &#39;list&#39;&gt;a &#x3D; [0] * 3x &#x3D; [a] * 4print(x, type(x))# [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class &#39;list&#39;&gt;x[0][0] &#x3D; 1print(x, type(x))# [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class &#39;list&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建一个混合列表</li></ul><p>【例子】 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mix &#x3D; [1, &#39;lsgo&#39;, 3.14, [1, 2, 3]]print(mix, type(mix))  # [1, &#39;lsgo&#39;, 3.14, [1, 2, 3]] &lt;class &#39;list&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>创建一个空列表</li></ul><p>【例子】 </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">empty &#x3D; []print(empty, type(empty))  # [] &lt;class &#39;list&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>列表不像元组，列表内容可更改 (mutable)，因此附加 (<code>append</code>, <code>extend</code>)、插入 (<code>insert</code>)、删除 (<code>remove</code>, <code>pop</code>) 这些操作都可以用在它身上。</p><h3 id="3-向列表中添加元素"><a href="#3-向列表中添加元素" class="headerlink" title="3. 向列表中添加元素"></a>3. 向列表中添加元素</h3><ul><li><code>list.append(obj)</code> 在列表末尾添加新的对象，只接受一个参数，参数可以是任何数据类型，被追加的元素在 list 中保持着原结构类型。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]x.append(&#39;Thursday&#39;)print(x)  # [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Thursday&#39;]print(len(x))  # 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此元素如果是一个 list，那么这个 list 将作为一个整体进行追加，注意<code>append()</code>和<code>extend()</code>的区别。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]x.append([&#39;Thursday&#39;, &#39;Sunday&#39;])print(x)  # [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, [&#39;Thursday&#39;, &#39;Sunday&#39;]]print(len(x))  # 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>list.extend(seq)</code> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]x.extend([&#39;Thursday&#39;, &#39;Sunday&#39;])print(x)  # [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;, &#39;Thursday&#39;, &#39;Sunday&#39;]print(len(x))  # 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>严格来说 <code>append</code> 是追加，把一个东西整体添加在列表后，而 <code>extend</code> 是扩展，把一个东西里的所有元素添加在列表后。</p><ul><li><code>list.insert(index, obj)</code> 在编号 <code>index</code> 位置插入 <code>obj</code>。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]x.insert(2, &#39;Sunday&#39;)print(x)# [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Sunday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]print(len(x))  # 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-删除列表中的元素"><a href="#4-删除列表中的元素" class="headerlink" title="4. 删除列表中的元素"></a>4. 删除列表中的元素</h3><ul><li><code>list.remove(obj)</code> 移除列表中某个值的第一个匹配项</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]x.remove(&#39;Monday&#39;)print(x)  # [&#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>list.pop([index=-1])</code> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]y &#x3D; x.pop()print(y)  # Fridayy &#x3D; x.pop(0)print(y)  # Mondayy &#x3D; x.pop(-2)print(y)  # Wednesdayprint(x)  # [&#39;Tuesday&#39;, &#39;Thursday&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>remove</code> 和 <code>pop</code> 都可以删除元素，前者是指定具体要删除的元素，后者是指定一个索引。</p><ul><li><code>del var1[, var2 ……]</code> 删除单个或多个对象。</li></ul><p>【例子】</p><p>如果知道要删除的元素在列表中的位置，可使用<code>del</code>语句。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]del x[0:2]print(x)  # [&#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用<code>del</code>语句；如果你要在删除元素后还能继续使用它，就使用方法<code>pop()</code>。</p><h3 id="5-获取列表中的元素"><a href="#5-获取列表中的元素" class="headerlink" title="5. 获取列表中的元素"></a>5. 获取列表中的元素</h3><ul><li>通过元素的索引值，从列表获取单个元素，注意，列表索引值是从0开始的。</li><li>通过将索引指定为-1，可让Python返回最后一个列表元素，索引 -2 返回倒数第二个列表元素，以此类推。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, [&#39;Thursday&#39;, &#39;Friday&#39;]]print(x[0], type(x[0]))  # Monday &lt;class &#39;str&#39;&gt;print(x[-1], type(x[-1]))  # [&#39;Thursday&#39;, &#39;Friday&#39;] &lt;class &#39;list&#39;&gt;print(x[-2], type(x[-2]))  # Wednesday &lt;class &#39;str&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>切片的通用写法是 <code>start : stop : step</code></p><ul><li>情况 1 - “start :” </li><li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往列表尾部切片。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]print(x[3:])  # [&#39;Thursday&#39;, &#39;Friday&#39;]print(x[-3:])  # [&#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>情况 2 - “: stop”</li><li>以 <code>step</code> 为 1 (默认) 从列表头部往编号 <code>stop</code> 切片。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">week &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]print(week[:3])  # [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;]print(week[:-3])  # [&#39;Monday&#39;, &#39;Tuesday&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>情况 3 - “start : stop”</li><li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往编号 <code>stop</code> 切片。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">week &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]print(week[1:3])  # [&#39;Tuesday&#39;, &#39;Wednesday&#39;]print(week[-3:-1])  # [&#39;Wednesday&#39;, &#39;Thursday&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>情况 4 - “start : stop : step”</li><li>以具体的 <code>step</code> 从编号 <code>start</code> 往编号 <code>stop</code> 切片。注意最后把 <code>step</code> 设为 -1，相当于将列表反向排列。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">week &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]print(week[1:4:2])  # [&#39;Tuesday&#39;, &#39;Thursday&#39;]print(week[:4:2])  # [&#39;Monday&#39;, &#39;Wednesday&#39;]print(week[1::2])  # [&#39;Tuesday&#39;, &#39;Thursday&#39;]print(week[::-1])  # [&#39;Friday&#39;, &#39;Thursday&#39;, &#39;Wednesday&#39;, &#39;Tuesday&#39;, &#39;Monday&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>情况 5 - “ : “</li><li>复制列表中的所有元素（浅拷贝）。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">week &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]print(week[:])  # [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【例子】浅拷贝与深拷贝</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">list1 &#x3D; [123, 456, 789, 213]list2 &#x3D; list1list3 &#x3D; list1[:]print(list2)  # [123, 456, 789, 213]print(list3)  # [123, 456, 789, 213]list1.sort()print(list2)  # [123, 213, 456, 789] print(list3)  # [123, 456, 789, 213]list1 &#x3D; [[123, 456], [789, 213]]list2 &#x3D; list1list3 &#x3D; list1[:]print(list2)  # [[123, 456], [789, 213]]print(list3)  # [[123, 456], [789, 213]]list1[0][0] &#x3D; 111print(list2)  # [[111, 456], [789, 213]]print(list3)  # [[111, 456], [789, 213]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-列表的常用操作符"><a href="#6-列表的常用操作符" class="headerlink" title="6. 列表的常用操作符"></a>6. 列表的常用操作符</h3><ul><li>等号操作符：<code>==</code></li><li>连接操作符 <code>+</code></li><li>重复操作符 <code>*</code></li><li>成员关系操作符 <code>in</code>、<code>not in</code></li></ul><p>「等号 ==」，只有成员、成员位置都相同时才返回True。</p><p>列表拼接有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">list1 &#x3D; [123, 456]list2 &#x3D; [456, 123]list3 &#x3D; [123, 456]print(list1 &#x3D;&#x3D; list2)  # Falseprint(list1 &#x3D;&#x3D; list3)  # Truelist4 &#x3D; list1 + list2  # extend()print(list4)  # [123, 456, 456, 123]list5 &#x3D; list3 * 3print(list5)  # [123, 456, 123, 456, 123, 456]list3 *&#x3D; 3print(list3)  # [123, 456, 123, 456, 123, 456]print(123 in list3)  # Trueprint(456 not in list3)  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前面三种方法（<code>append</code>, <code>extend</code>, <code>insert</code>）可对列表增加元素，它们没有返回值，是直接修改了原数据对象。<br>而将两个list相加，需要创建新的 list 对象，从而需要消耗额外的内存，特别是当 list 较大时，尽量不要使用 “+” 来添加list。</p><h3 id="7-列表的其它方法"><a href="#7-列表的其它方法" class="headerlink" title="7. 列表的其它方法"></a>7. 列表的其它方法</h3><p><code>list.count(obj)</code> 统计某个元素在列表中出现的次数</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">list1 &#x3D; [123, 456] * 3print(list1)  # [123, 456, 123, 456, 123, 456]num &#x3D; list1.count(123)print(num)  # 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>list.index(x[, start[, end]])</code> 从列表中找出某个值第一个匹配项的索引位置</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">list1 &#x3D; [123, 456] * 5print(list1.index(123))  # 0print(list1.index(123, 1))  # 2print(list1.index(123, 3, 7))  # 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><code>list.reverse()</code> 反向列表中元素</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [123, 456, 789]x.reverse()print(x)  # [789, 456, 123]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>list.sort(key=None, reverse=False)</code> 对原列表进行排序。</p><ul><li><code>key</code> – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li><code>reverse</code> – 排序规则，<code>reverse = True</code> 降序， <code>reverse = False</code> 升序（默认）。</li><li>该方法没有返回值，但是会对列表的对象进行排序。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [123, 456, 789, 213]x.sort()print(x)# [123, 213, 456, 789]x.sort(reverse&#x3D;True)print(x)# [789, 456, 213, 123]# 获取列表的第二个元素def takeSecond(elem):    return elem[1]x &#x3D; [(2, 2), (3, 4), (4, 1), (1, 3)]x.sort(key&#x3D;takeSecond)print(x)# [(4, 1), (2, 2), (1, 3), (3, 4)]x.sort(key&#x3D;lambda a: a[0])print(x)# [(1, 3), (2, 2), (3, 4), (4, 1)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="1-元组的定义"><a href="#1-元组的定义" class="headerlink" title="1. 元组的定义"></a>1. 元组的定义</h3><p>「元组」定义语法为：<code>(元素1, 元素2, ..., 元素n)</code></p><ul><li>小括号把所有元素绑在一起</li><li>逗号将每个元素一一分开</li></ul><h3 id="2-创建和访问一个元组"><a href="#2-创建和访问一个元组" class="headerlink" title="2. 创建和访问一个元组"></a>2. 创建和访问一个元组</h3><ul><li>Python 的元组与列表类似，不同之处在于tuple被创建后就不能对其进行修改，类似字符串。</li><li>元组使用小括号，列表使用方括号。</li><li>元组与列表类似，也用整数来对它进行索引 (indexing) 和切片 (slicing)。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t1 &#x3D; (1, 10.31, &#39;python&#39;)t2 &#x3D; 1, 10.31, &#39;python&#39;print(t1, type(t1))# (1, 10.31, &#39;python&#39;) &lt;class &#39;tuple&#39;&gt;print(t2, type(t2))# (1, 10.31, &#39;python&#39;) &lt;class &#39;tuple&#39;&gt;tuple1 &#x3D; (1, 2, 3, 4, 5, 6, 7, 8)print(tuple1[1])  # 2print(tuple1[5:])  # (6, 7, 8)print(tuple1[:5])  # (1, 2, 3, 4, 5)tuple2 &#x3D; tuple1[:]print(tuple2)  # (1, 2, 3, 4, 5, 6, 7, 8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建元组可以用小括号 ()，也可以什么都不用，为了可读性，建议还是用 ()。</li><li>元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; (1)print(type(x))  # &lt;class &#39;int&#39;&gt;x &#x3D; 2, 3, 4, 5print(type(x))  # &lt;class &#39;tuple&#39;&gt;x &#x3D; []print(type(x))  # &lt;class &#39;list&#39;&gt;x &#x3D; ()print(type(x))  # &lt;class &#39;tuple&#39;&gt;x &#x3D; (1,)print(type(x))  # &lt;class &#39;tuple&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(8 * (8))  # 64print(8 * (8,))  # (8, 8, 8, 8, 8, 8, 8, 8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【例子】创建二维元组。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; (1, 10.31, &#39;python&#39;), (&#39;data&#39;, 11)print(x)# ((1, 10.31, &#39;python&#39;), (&#39;data&#39;, 11))print(x[0])# (1, 10.31, &#39;python&#39;)print(x[0][0], x[0][1], x[0][2])# 1 10.31 pythonprint(x[0][0:2])# (1, 10.31)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-更新和删除一个元组"><a href="#3-更新和删除一个元组" class="headerlink" title="3. 更新和删除一个元组"></a>3. 更新和删除一个元组</h3><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">week &#x3D; (&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)week &#x3D; week[:2] + (&#39;Wednesday&#39;,) + week[2:]print(week)  # (&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;, &#39;Thursday&#39;, &#39;Friday&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【例子】元组有不可更改 (immutable) 的性质，因此不能直接给元组的元素赋值，但是只要元组中的元素可更改 (mutable)，那么我们可以直接更改其元素，注意这跟赋值其元素不同。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t1 &#x3D; (1, 2, 3, [4, 5, 6])print(t1)  # (1, 2, 3, [4, 5, 6])t1[3][0] &#x3D; 9print(t1)  # (1, 2, 3, [9, 5, 6])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-元组相关的操作符"><a href="#4-元组相关的操作符" class="headerlink" title="4. 元组相关的操作符"></a>4. 元组相关的操作符</h3><ul><li>等号操作符：<code>==</code></li><li>连接操作符 <code>+</code></li><li>重复操作符 <code>*</code></li><li>成员关系操作符 <code>in</code>、<code>not in</code></li></ul><p>「等号 ==」，只有成员、成员位置都相同时才返回True。</p><p>元组拼接有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t1 &#x3D; (123, 456)t2 &#x3D; (456, 123)t3 &#x3D; (123, 456)print(t1 &#x3D;&#x3D; t2)  # Falseprint(t1 &#x3D;&#x3D; t3)  # Truet4 &#x3D; t1 + t2print(t4)  # (123, 456, 456, 123)t5 &#x3D; t3 * 3print(t5)  # (123, 456, 123, 456, 123, 456)t3 *&#x3D; 3print(t3)  # (123, 456, 123, 456, 123, 456)print(123 in t3)  # Trueprint(456 not in t3)  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-内置方法"><a href="#5-内置方法" class="headerlink" title="5. 内置方法"></a>5. 内置方法</h3><p>元组大小和内容都不可更改，因此只有 <code>count</code> 和 <code>index</code> 两种方法。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; (1, 10.31, &#39;python&#39;)print(t.count(&#39;python&#39;))  # 1print(t.index(10.31))  # 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>count(&#39;python&#39;)</code> 是记录在元组 <code>t</code> 中该元素出现几次，显然是 1 次</li><li><code>index(10.31)</code> 是找到该元素在元组 <code>t</code> 的索引，显然是 1</li></ul><h3 id="6-解压元组"><a href="#6-解压元组" class="headerlink" title="6. 解压元组"></a>6. 解压元组</h3><p>【例子】解压（unpack）一维元组（有几个元素左边括号定义几个变量）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; (1, 10.31, &#39;python&#39;)(a, b, c) &#x3D; tprint(a, b, c)# 1 10.31 python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】解压二维元组（按照元组里的元组结构来定义变量）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; (1, 10.31, (&#39;OK&#39;, &#39;python&#39;))(a, b, (c, d)) &#x3D; tprint(a, b, c, d)# 1 10.31 OK python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】如果你只想要元组其中几个元素，用通配符「*」，英文叫 wildcard，在计算机语言中代表一个或多个元素。下例就是把多个元素丢给了 <code>rest</code> 变量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; 1, 2, 3, 4, 5a, b, *rest, c &#x3D; tprint(a, b, c)  # 1 2 5print(rest)  # [3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】如果你根本不在乎 rest 变量，那么就用通配符「*」加上下划线「_」。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t &#x3D; 1, 2, 3, 4, 5a, b, *_ &#x3D; tprint(a, b)  # 1 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1-字符串的定义"><a href="#1-字符串的定义" class="headerlink" title="1. 字符串的定义"></a>1. 字符串的定义</h3><ul><li>Python 中字符串被定义为引号之间的字符集合。</li><li>Python 支持使用成对的 单引号 或 双引号。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">t1 &#x3D; &#39;i love Python!&#39;print(t1, type(t1))# i love Python! &lt;class &#39;str&#39;&gt;t2 &#x3D; &quot;I love Python!&quot;print(t2, type(t2))# I love Python! &lt;class &#39;str&#39;&gt;print(5 + 8)  # 13print(&#39;5&#39; + &#39;8&#39;)  # 58<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Python 的常用转义字符</li></ul><table><thead><tr><th align="center">转义字符</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>\\</code></td><td>反斜杠符号</td></tr><tr><td align="center"><code>\&#39;</code></td><td>单引号</td></tr><tr><td align="center"><code>\&quot;</code></td><td>双引号</td></tr><tr><td align="center"><code>\n</code></td><td>换行</td></tr><tr><td align="center"><code>\t</code></td><td>横向制表符(TAB)</td></tr><tr><td align="center"><code>\r</code></td><td>回车</td></tr></tbody></table><p>【例子】如果字符串中需要出现单引号或双引号，可以使用转义符号<code>\</code>对字符串中的符号进行转义。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&#39;let\&#39;s go&#39;)  # let&#39;s goprint(&quot;let&#39;s go&quot;)  # let&#39;s goprint(&#39;C:\\now&#39;)  # C:\nowprint(&quot;C:\\Program Files\\Intel\\Wifi\\Help&quot;)# C:\Program Files\Intel\Wifi\Help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】原始字符串只需要在字符串前边加一个英文字母 r 即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(r&#39;C:\Program Files\Intel\Wifi\Help&#39;)  # C:\Program Files\Intel\Wifi\Help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>【例子】三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">para_str &#x3D; &quot;&quot;&quot;这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \t )。也可以使用换行符 [ \n ]。&quot;&quot;&quot;print(para_str)# 这是一个多行字符串的实例# 多行字符串可以使用制表符# TAB (    )。# 也可以使用换行符 [#  ]。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-字符串的切片与拼接"><a href="#2-字符串的切片与拼接" class="headerlink" title="2. 字符串的切片与拼接"></a>2. 字符串的切片与拼接</h3><ul><li>类似于元组具有不可修改性</li><li>从 0 开始 (和 Java 一样)</li><li>切片通常写成 <code>start:end</code> 这种形式，包括「<code>start</code> 索引」对应的元素，不包括「<code>end</code>索引」对应的元素。</li><li>索引值可正可负，正索引从 0 开始，从左往右；负索引从 -1 开始，从右往左。使用负数索引时，会从最后一个元素开始计数。最后一个元素的位置编号是 -1。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str1 &#x3D; &#39;I Love LsgoGroup&#39;print(str1[:6])  # I Loveprint(str1[5])  # eprint(str1[:6] + &quot; 插入的字符串 &quot; + str1[6:])  # I Love 插入的字符串  LsgoGroups &#x3D; &#39;Python&#39;print(s)  # Pythonprint(s[2:4])  # thprint(s[-5:-2])  # ythprint(s[2])  # tprint(s[-1])  # n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-字符串的常用内置方法"><a href="#3-字符串的常用内置方法" class="headerlink" title="3. 字符串的常用内置方法"></a>3. 字符串的常用内置方法</h3><ul><li><code>capitalize()</code> 将字符串的第一个字符转换为大写。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str2 &#x3D; &#39;xiaoxie&#39;print(str2.capitalize())  # Xiaoxie<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>lower()</code> 转换字符串中所有大写字符为小写。</li><li><code>upper()</code> 转换字符串中的小写字母为大写。</li><li><code>swapcase()</code> 将字符串中大写转换为小写，小写转换为大写。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str2 &#x3D; &quot;DAXIExiaoxie&quot;print(str2.lower())  # daxiexiaoxieprint(str2.upper())  # DAXIEXIAOXIEprint(str2.swapcase())  # daxieXIAOXIE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>count(str, beg= 0,end=len(string))</code> 返回<code>str</code>在 string 里面出现的次数，如果<code>beg</code>或者<code>end</code>指定则返回指定范围内<code>str</code>出现的次数。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str2 &#x3D; &quot;DAXIExiaoxie&quot;print(str2.count(&#39;xi&#39;))  # 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>endswith(suffix, beg=0, end=len(string))</code> 检查字符串是否以指定子字符串 <code>suffix</code> 结束，如果是，返回 True，否则返回 False。如果 <code>beg</code> 和 <code>end</code> 指定值，则在指定范围内检查。</li><li><code>startswith(substr, beg=0,end=len(string))</code> 检查字符串是否以指定子字符串 <code>substr</code> 开头，如果是，返回 True，否则返回 False。如果 <code>beg</code> 和 <code>end</code> 指定值，则在指定范围内检查。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str2 &#x3D; &quot;DAXIExiaoxie&quot;print(str2.endswith(&#39;ie&#39;))  # Trueprint(str2.endswith(&#39;xi&#39;))  # Falseprint(str2.startswith(&#39;Da&#39;))  # Falseprint(str2.startswith(&#39;DA&#39;))  # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>find(str, beg=0, end=len(string))</code> 检测 <code>str</code> 是否包含在字符串中，如果指定范围 <code>beg</code> 和 <code>end</code>，则检查是否包含在指定范围内，如果包含，返回开始的索引值，否则返回 -1。</li><li><code>rfind(str, beg=0,end=len(string))</code> 类似于 <code>find()</code> 函数，不过是从右边开始查找。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str2 &#x3D; &quot;DAXIExiaoxie&quot;print(str2.find(&#39;xi&#39;))  # 5print(str2.find(&#39;ix&#39;))  # -1print(str2.rfind(&#39;xi&#39;))  # 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>isnumeric()</code> 如果字符串中只包含数字字符，则返回 True，否则返回 False。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str3 &#x3D; &#39;12345&#39;print(str3.isnumeric())  # Truestr3 +&#x3D; &#39;a&#39;print(str3.isnumeric())  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>ljust(width[, fillchar])</code>返回一个原字符串左对齐，并使用<code>fillchar</code>（默认空格）填充至长度<code>width</code>的新字符串。</li><li><code>rjust(width[, fillchar])</code>返回一个原字符串右对齐，并使用<code>fillchar</code>（默认空格）填充至长度<code>width</code>的新字符串。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str4 &#x3D; &#39;1101&#39;print(str4.ljust(8, &#39;0&#39;))  # 11010000print(str4.rjust(8, &#39;0&#39;))  # 00001101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>lstrip([chars])</code> 截掉字符串左边的空格或指定字符。</li><li><code>rstrip([chars])</code> 删除字符串末尾的空格或指定字符。</li><li><code>strip([chars])</code> 在字符串上执行<code>lstrip()</code>和<code>rstrip()</code>。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str5 &#x3D; &#39; I Love LsgoGroup &#39;print(str5.lstrip())  # &#39;I Love LsgoGroup &#39;print(str5.lstrip().strip(&#39;I&#39;))  # &#39; Love LsgoGroup &#39;print(str5.rstrip())  # &#39; I Love LsgoGroup&#39;print(str5.strip())  # &#39;I Love LsgoGroup&#39;print(str5.strip().strip(&#39;p&#39;))  # &#39;I Love LsgoGrou&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>partition(sub)</code> 找到子字符串sub，把字符串分为一个三元组<code>(pre_sub,sub,fol_sub)</code>，如果字符串中不包含sub则返回<code>(&#39;原字符串&#39;,&#39;&#39;,&#39;&#39;)</code>。</li><li><code>rpartition(sub)</code>类似于<code>partition()</code>方法，不过是从右边开始查找。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str5 &#x3D; &#39; I Love LsgoGroup &#39;print(str5.strip().partition(&#39;o&#39;))  # (&#39;I L&#39;, &#39;o&#39;, &#39;ve LsgoGroup&#39;)print(str5.strip().partition(&#39;m&#39;))  # (&#39;I Love LsgoGroup&#39;, &#39;&#39;, &#39;&#39;)print(str5.strip().rpartition(&#39;o&#39;))  # (&#39;I Love LsgoGr&#39;, &#39;o&#39;, &#39;up&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>replace(old, new [, max])</code> 把 将字符串中的<code>old</code>替换成<code>new</code>，如果<code>max</code>指定，则替换不超过<code>max</code>次。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str5 &#x3D; &#39; I Love LsgoGroup &#39;print(str5.strip().replace(&#39;I&#39;, &#39;We&#39;))  # We Love LsgoGroup<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>split(str=&quot;&quot;, num)</code> 不带参数默认是以空格为分隔符切片字符串，如果<code>num</code>参数有设置，则仅分隔<code>num</code>个子字符串，返回切片后的子字符串拼接的列表。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str5 &#x3D; &#39; I Love LsgoGroup &#39;print(str5.strip().split())  # [&#39;I&#39;, &#39;Love&#39;, &#39;LsgoGroup&#39;]print(str5.strip().split(&#39;o&#39;))  # [&#39;I L&#39;, &#39;ve Lsg&#39;, &#39;Gr&#39;, &#39;up&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">u &#x3D; &quot;www.baidu.com.cn&quot;# 使用默认分隔符print(u.split())  # [&#39;www.baidu.com.cn&#39;]# 以&quot;.&quot;为分隔符print((u.split(&#39;.&#39;)))  # [&#39;www&#39;, &#39;baidu&#39;, &#39;com&#39;, &#39;cn&#39;]# 分割0次print((u.split(&quot;.&quot;, 0)))  # [&#39;www.baidu.com.cn&#39;]# 分割一次print((u.split(&quot;.&quot;, 1)))  # [&#39;www&#39;, &#39;baidu.com.cn&#39;]# 分割两次print(u.split(&quot;.&quot;, 2))  # [&#39;www&#39;, &#39;baidu&#39;, &#39;com.cn&#39;]# 分割两次，并取序列为1的项print((u.split(&quot;.&quot;, 2)[1]))  # baidu# 分割两次，并把分割后的三个部分保存到三个变量u1, u2, u3 &#x3D; u.split(&quot;.&quot;, 2)print(u1)  # wwwprint(u2)  # baiduprint(u3)  # com.cn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】去掉换行符</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">c &#x3D; &#39;&#39;&#39;sayhellobaby&#39;&#39;&#39;print(c)# say# hello# babyprint(c.split(&#39;\n&#39;))  # [&#39;say&#39;, &#39;hello&#39;, &#39;baby&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">string &#x3D; &quot;hello boy&lt;[www.baidu.com]&gt;byebye&quot;print(string.split(&#39;[&#39;)[1].split(&#39;]&#39;)[0])  # www.baidu.comprint(string.split(&#39;[&#39;)[1].split(&#39;]&#39;)[0].split(&#39;.&#39;))  # [&#39;www&#39;, &#39;baidu&#39;, &#39;com&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>splitlines([keepends])</code> 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数<code>keepends</code>为 False，不包含换行符，如果为 True，则保留换行符。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str6 &#x3D; &#39;I \n Love \n LsgoGroup&#39;print(str6.splitlines())  # [&#39;I &#39;, &#39; Love &#39;, &#39; LsgoGroup&#39;]print(str6.splitlines(True))  # [&#39;I \n&#39;, &#39; Love \n&#39;, &#39; LsgoGroup&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>maketrans(intab, outtab)</code> 创建字符映射的转换表，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</li><li><code>translate(table, deletechars=&quot;&quot;)</code> 根据参数<code>table</code>给出的表，转换字符串的字符，要过滤掉的字符放到<code>deletechars</code>参数中。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str7 &#x3D; &#39;this is string example....wow!!!&#39;intab &#x3D; &#39;aeiou&#39;outtab &#x3D; &#39;12345&#39;trantab &#x3D; str7.maketrans(intab, outtab)print(trantab)  # &#123;97: 49, 111: 52, 117: 53, 101: 50, 105: 51&#125;print(str7.translate(trantab))  # th3s 3s str3ng 2x1mpl2....w4w!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-字符串格式化"><a href="#4-字符串格式化" class="headerlink" title="4. 字符串格式化"></a>4. 字符串格式化</h3><ul><li><code>format</code> 格式化函数</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str8 &#x3D; &quot;&#123;0&#125; Love &#123;1&#125;&quot;.format(&#39;I&#39;, &#39;Lsgogroup&#39;)  # 位置参数print(str8)  # I Love Lsgogroupstr8 &#x3D; &quot;&#123;a&#125; Love &#123;b&#125;&quot;.format(a&#x3D;&#39;I&#39;, b&#x3D;&#39;Lsgogroup&#39;)  # 关键字参数print(str8)  # I Love Lsgogroupstr8 &#x3D; &quot;&#123;0&#125; Love &#123;b&#125;&quot;.format(&#39;I&#39;, b&#x3D;&#39;Lsgogroup&#39;)  # 位置参数要在关键字参数之前print(str8)  # I Love Lsgogroupstr8 &#x3D; &#39;&#123;0:.2f&#125;&#123;1&#125;&#39;.format(27.658, &#39;GB&#39;)  # 保留小数点后两位print(str8)  # 27.66GB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Python 字符串格式化符号</li></ul><table><thead><tr><th align="center">符   号</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">%c</td><td align="left">格式化字符及其ASCII码</td></tr><tr><td align="center">%s</td><td align="left">格式化字符串，用str()方法处理对象</td></tr><tr><td align="center">%r</td><td align="left">格式化字符串，用rper()方法处理对象</td></tr><tr><td align="center">%d</td><td align="left">格式化整数</td></tr><tr><td align="center">%o</td><td align="left">格式化无符号八进制数</td></tr><tr><td align="center">%x</td><td align="left">格式化无符号十六进制数</td></tr><tr><td align="center">%X</td><td align="left">格式化无符号十六进制数（大写）</td></tr><tr><td align="center">%f</td><td align="left">格式化浮点数字，可指定小数点后的精度</td></tr><tr><td align="center">%e</td><td align="left">用科学计数法格式化浮点数</td></tr><tr><td align="center">%E</td><td align="left">作用同%e，用科学计数法格式化浮点数</td></tr><tr><td align="center">%g</td><td align="left">根据值的大小决定使用%f或%e</td></tr><tr><td align="center">%G</td><td align="left">作用同%g，根据值的大小决定使用%f或%E</td></tr></tbody></table><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&#39;%c&#39; % 97)  # aprint(&#39;%c %c %c&#39; % (97, 98, 99))  # a b cprint(&#39;%d + %d &#x3D; %d&#39; % (4, 5, 9))  # 4 + 5 &#x3D; 9print(&quot;我叫 %s 今年 %d 岁!&quot; % (&#39;小明&#39;, 10))  # 我叫 小明 今年 10 岁!print(&#39;%o&#39; % 10)  # 12print(&#39;%x&#39; % 10)  # aprint(&#39;%X&#39; % 10)  # Aprint(&#39;%f&#39; % 27.658)  # 27.658000print(&#39;%e&#39; % 27.658)  # 2.765800e+01print(&#39;%E&#39; % 27.658)  # 2.765800E+01print(&#39;%g&#39; % 27.658)  # 27.658text &#x3D; &quot;I am %d years old.&quot; % 22print(&quot;I said: %s.&quot; % text)  # I said: I am 22 years old..print(&quot;I said: %r.&quot; % text)  # I said: &#39;I am 22 years old.&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>格式化操作符辅助指令</li></ul><table><thead><tr><th align="center">符号</th><th align="left">功能</th></tr></thead><tbody><tr><td align="center"><code>m.n</code></td><td align="left">m 是显示的最小总宽度,n 是小数点后的位数（如果可用的话）</td></tr><tr><td align="center"><code>-</code></td><td align="left">用作左对齐</td></tr><tr><td align="center"><code>+</code></td><td align="left">在正数前面显示加号( + )</td></tr><tr><td align="center"><code>#</code></td><td align="left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td></tr><tr><td align="center"><code>0</code></td><td align="left">显示的数字前面填充’0’而不是默认的空格</td></tr></tbody></table><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(&#39;%5.1f&#39; % 27.658)  # &#39; 27.7&#39;print(&#39;%.2e&#39; % 27.658)  # 2.77e+01print(&#39;%10d&#39; % 10)  # &#39;        10&#39;print(&#39;%-10d&#39; % 10)  # &#39;10        &#39;print(&#39;%+d&#39; % 10)  # +10print(&#39;%#o&#39; % 10)  # 0o12print(&#39;%#x&#39; % 108)  # 0x6cprint(&#39;%010d&#39; % 5)  # 0000000005<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="1-可变类型与不可变类型"><a href="#1-可变类型与不可变类型" class="headerlink" title="1. 可变类型与不可变类型"></a>1. 可变类型与不可变类型</h3><ul><li>序列是以连续的整数为索引，与此不同的是，字典以”关键字”为索引，关键字可以是任意不可变类型，通常用字符串或数值。</li><li>字典是 Python 唯一的一个 <u>映射类型</u>，字符串、元组、列表属于<u>序列类型</u>。</li></ul><p>那么如何快速判断一个数据类型 <code>X</code> 是不是可变类型的呢？两种方法：</p><ul><li>麻烦方法：用 <code>id(X)</code> 函数，对 X 进行某种操作，比较操作前后的 <code>id</code>，如果不一样，则 <code>X</code> 不可变，如果一样，则 <code>X</code> 可变。</li><li>便捷方法：用 <code>hash(X)</code>，只要不报错，证明 <code>X</code> 可被哈希，即不可变，反过来不可被哈希，即可变。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">i &#x3D; 1print(id(i))  # 140732167000896i &#x3D; i + 2print(id(i))  # 140732167000960l &#x3D; [1, 2]print(id(l))  # 4300825160l.append(&#39;Python&#39;)print(id(l))  # 4300825160<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>整数 <code>i</code> 在加 1 之后的 <code>id</code> 和之前不一样，因此加完之后的这个 <code>i</code> (虽然名字没变)，但不是加之前的那个 <code>i</code> 了，因此整数是不可变类型。</li><li>列表 <code>l</code> 在附加 <code>&#39;Python&#39;</code> 之后的 <code>id</code> 和之前一样，因此列表是可变类型。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(hash(&#39;Name&#39;))  # 7047218704141848153print(hash((1, 2, &#39;Python&#39;)))  # 1704535747474881831print(hash([1, 2, &#39;Python&#39;]))# TypeError: unhashable type: &#39;list&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">print(hash(&#123;1, 2, 3&#125;))# TypeError: unhashable type: &#39;set&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>数值、字符和元组 都能被哈希，因此它们是不可变类型。</li><li>列表、集合、字典不能被哈希，因此它是可变类型。</li></ul><h3 id="2-字典的定义"><a href="#2-字典的定义" class="headerlink" title="2. 字典的定义"></a>2. 字典的定义</h3><p>字典 是无序的 键:值（<code>key:value</code>）对集合，键必须是互不相同的（在同一个字典之内）。</p><ul><li><code>dict</code> 内部存放的顺序和 <code>key</code> 放入的顺序是没有关系的。</li><li><code>dict</code> 查找和插入的速度极快，不会随着 <code>key</code> 的增加而增加，但是需要占用大量的内存。</li></ul><p>字典 定义语法为 <code>&#123;元素1, 元素2, ..., 元素n&#125;</code></p><ul><li>其中每一个元素是一个「键值对」– 键:值 (<code>key:value</code>)</li><li>关键点是「大括号 {}」,「逗号 ,」和「冒号 :」</li><li>大括号 – 把所有元素绑在一起</li><li>逗号 – 将每个键值对分开</li><li>冒号 – 将键和值分开</li></ul><h3 id="3-创建和访问字典"><a href="#3-创建和访问字典" class="headerlink" title="3. 创建和访问字典"></a>3. 创建和访问字典</h3><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">brand &#x3D; [&#39;李宁&#39;, &#39;耐克&#39;, &#39;阿迪达斯&#39;]slogan &#x3D; [&#39;一切皆有可能&#39;, &#39;Just do it&#39;, &#39;Impossible is nothing&#39;]print(&#39;耐克的口号是:&#39;, slogan[brand.index(&#39;耐克&#39;)])  # 耐克的口号是: Just do itdic &#x3D; &#123;&#39;李宁&#39;: &#39;一切皆有可能&#39;, &#39;耐克&#39;: &#39;Just do it&#39;, &#39;阿迪达斯&#39;: &#39;Impossible is nothing&#39;&#125;print(&#39;耐克的口号是:&#39;, dic[&#39;耐克&#39;])  # 耐克的口号是: Just do it<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】通过字符串或数值作为<code>key</code>来创建字典。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic1 &#x3D; &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;print(dic1)  # &#123;1: &#39;one&#39;, 2: &#39;two&#39;, 3: &#39;three&#39;&#125;print(dic1[1])  # oneprint(dic1[4])  # KeyError: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic2 &#x3D; &#123;&#39;rice&#39;: 35, &#39;wheat&#39;: 101, &#39;corn&#39;: 67&#125;print(dic2)  # &#123;&#39;wheat&#39;: 101, &#39;corn&#39;: 67, &#39;rice&#39;: 35&#125;print(dic2[&#39;rice&#39;])  # 35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：如果我们取的键在字典中不存在，会直接报错<code>KeyError</code>。</p><p>【例子】通过元组作为<code>key</code>来创建字典，但一般不这样使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;(1, 2, 3): &quot;Tom&quot;, &quot;Age&quot;: 12, 3: [3, 5, 7]&#125;print(dic)  # &#123;(1, 2, 3): &#39;Tom&#39;, &#39;Age&#39;: 12, 3: [3, 5, 7]&#125;print(type(dic))  # &lt;class &#39;dict&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过构造函数<code>dict</code>来创建字典。</p><ul><li><code>dict()</code> 创建一个空的字典。</li></ul><p>【例子】通过<code>key</code>直接把数据放入字典中，但一个<code>key</code>只能对应一个<code>value</code>，多次对一个<code>key</code>放入 <code>value</code>，后面的值会把前面的值冲掉。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; dict()dic[&#39;a&#39;] &#x3D; 1dic[&#39;b&#39;] &#x3D; 2dic[&#39;c&#39;] &#x3D; 3print(dic)# &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;dic[&#39;a&#39;] &#x3D; 11print(dic)# &#123;&#39;a&#39;: 11, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;dic[&#39;d&#39;] &#x3D; 4print(dic)# &#123;&#39;a&#39;: 11, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict(mapping)</code> new dictionary initialized from a mapping object’s (key, value) pairs</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic1 &#x3D; dict([(&#39;apple&#39;, 4139), (&#39;peach&#39;, 4127), (&#39;cherry&#39;, 4098)])print(dic1)  # &#123;&#39;cherry&#39;: 4098, &#39;apple&#39;: 4139, &#39;peach&#39;: 4127&#125;dic2 &#x3D; dict(((&#39;apple&#39;, 4139), (&#39;peach&#39;, 4127), (&#39;cherry&#39;, 4098)))print(dic2)  # &#123;&#39;peach&#39;: 4127, &#39;cherry&#39;: 4098, &#39;apple&#39;: 4139&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict(**kwargs)</code> -&gt; new dictionary initialized with the name=value pairs in the keyword argument list.  For example:  dict(one=1, two=2)</li></ul><p>【例子】这种情况下，键只能为字符串类型，并且创建的时候字符串不能加引号，加上就会直接报语法错误。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; dict(name&#x3D;&#39;Tom&#39;, age&#x3D;10)print(dic)  # &#123;&#39;name&#39;: &#39;Tom&#39;, &#39;age&#39;: 10&#125;print(type(dic))  # &lt;class &#39;dict&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="4-字典的内置方法"><a href="#4-字典的内置方法" class="headerlink" title="4. 字典的内置方法"></a>4. 字典的内置方法</h3><ul><li><code>dict.fromkeys(seq[, value])</code> 用于创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">seq &#x3D; (&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;)dic1 &#x3D; dict.fromkeys(seq)print(dic1)# &#123;&#39;name&#39;: None, &#39;age&#39;: None, &#39;sex&#39;: None&#125;dic2 &#x3D; dict.fromkeys(seq, 10)print(dic2)# &#123;&#39;name&#39;: 10, &#39;age&#39;: 10, &#39;sex&#39;: 10&#125;dic3 &#x3D; dict.fromkeys(seq, (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;))print(dic3)# &#123;&#39;name&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;), &#39;age&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;), &#39;sex&#39;: (&#39;小马&#39;, &#39;8&#39;, &#39;男&#39;)&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.keys()</code>返回一个可迭代对象，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有键。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Name&#39;: &#39;lsgogroup&#39;, &#39;Age&#39;: 7&#125;print(dic.keys())  # dict_keys([&#39;Name&#39;, &#39;Age&#39;])lst &#x3D; list(dic.keys())  # 转换为列表print(lst)  # [&#39;Name&#39;, &#39;Age&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.values()</code>返回一个迭代器，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 7, &#39;Name&#39;: &#39;Zara&#39;&#125;print(dic.values())# dict_values([&#39;female&#39;, 7, &#39;Zara&#39;])print(list(dic.values()))# [7, &#39;female&#39;, &#39;Zara&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.items()</code>以列表返回可遍历的 (键, 值) 元组数组。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;print(dic.items())# dict_items([(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)])print(tuple(dic.items()))# ((&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7))print(list(dic.items()))# [(&#39;Name&#39;, &#39;Lsgogroup&#39;), (&#39;Age&#39;, 7)]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.get(key, default=None)</code> 返回指定键的值，如果值不在字典中返回默认值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 27&#125;print(&quot;Age 值为 : %s&quot; % dic.get(&#39;Age&#39;))  # Age 值为 : 27print(&quot;Sex 值为 : %s&quot; % dic.get(&#39;Sex&#39;, &quot;NA&quot;))  # Sex 值为 : NAprint(dic)  # &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 27&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.setdefault(key, default=None)</code>和<code>get()</code>方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;print(&quot;Age 键的值为 : %s&quot; % dic.setdefault(&#39;Age&#39;, None))  # Age 键的值为 : 7print(&quot;Sex 键的值为 : %s&quot; % dic.setdefault(&#39;Sex&#39;, None))  # Sex 键的值为 : Noneprint(dic)  # &#123;&#39;Age&#39;: 7, &#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Sex&#39;: None&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>key in dict</code> <code>in</code> 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回<code>true</code>，否则返回<code>false</code>。而<code>not in</code>操作符刚好相反，如果键在字典 dict 里返回<code>false</code>，否则返回<code>true</code>。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;# in 检测键 Age 是否存在if &#39;Age&#39; in dic:    print(&quot;键 Age 存在&quot;)else:    print(&quot;键 Age 不存在&quot;)# 检测键 Sex 是否存在if &#39;Sex&#39; in dic:    print(&quot;键 Sex 存在&quot;)else:    print(&quot;键 Sex 不存在&quot;)# not in 检测键 Age 是否存在if &#39;Age&#39; not in dic:    print(&quot;键 Age 不存在&quot;)else:    print(&quot;键 Age 存在&quot;)# 键 Age 存在# 键 Sex 不存在# 键 Age 存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.pop(key[,default])</code>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。若<code>key</code>不存在，则返回 <code>default</code> 值。</li><li><code>del dict[key]</code> 删除字典给定键 <code>key</code> 所对应的值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic1 &#x3D; &#123;1: &quot;a&quot;, 2: [1, 2]&#125;print(dic1.pop(1), dic1)  # a &#123;2: [1, 2]&#125;# 设置默认值，必须添加，否则报错print(dic1.pop(3, &quot;nokey&quot;), dic1)  # nokey &#123;2: [1, 2]&#125;del dic1[2]print(dic1)  # &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.popitem()</code>随机返回并删除字典中的一对键和值，如果字典已经为空，却调用了此方法，就报出KeyError异常。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic1 &#x3D; &#123;1: &quot;a&quot;, 2: [1, 2]&#125;print(dic1.popitem())  # &#123;2: [1, 2]&#125;print(dic1)  # (1, &#39;a&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.clear()</code>用于删除字典内所有元素。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7&#125;print(&quot;字典长度 : %d&quot; % len(dic))  # 字典长度 : 2dic.clear()print(&quot;字典删除后长度 : %d&quot; % len(dic))  # 字典删除后长度 : 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.copy()</code>返回一个字典的浅复制。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic1 &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;dic2 &#x3D; dic1.copy()print(&quot;dic2&quot;)  # &#123;&#39;Age&#39;: 7, &#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Class&#39;: &#39;First&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】直接赋值和 copy 的区别</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic1 &#x3D; &#123;&#39;user&#39;: &#39;lsgogroup&#39;, &#39;num&#39;: [1, 2, 3]&#125;# 引用对象dic2 &#x3D; dic1  # 浅拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用dic3 &#x3D; dic1.copy()  print(id(dic1))  # 148635574728print(id(dic2))  # 148635574728print(id(dic3))  # 148635574344# 修改 data 数据dic1[&#39;user&#39;] &#x3D; &#39;root&#39;dic1[&#39;num&#39;].remove(1)# 输出结果print(dic1)  # &#123;&#39;user&#39;: &#39;root&#39;, &#39;num&#39;: [2, 3]&#125;print(dic2)  # &#123;&#39;user&#39;: &#39;root&#39;, &#39;num&#39;: [2, 3]&#125;print(dic3)  # &#123;&#39;user&#39;: &#39;runoob&#39;, &#39;num&#39;: [2, 3]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>dict.update(dict2)</code>把字典参数 <code>dict2</code> 的 <code>key:value</code>对 更新到字典 <code>dict</code> 里。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">dic &#x3D; &#123;&#39;Name&#39;: &#39;Lsgogroup&#39;, &#39;Age&#39;: 7&#125;dic2 &#x3D; &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 8&#125;dic.update(dic2)print(dic)  # &#123;&#39;Sex&#39;: &#39;female&#39;, &#39;Age&#39;: 8, &#39;Name&#39;: &#39;Lsgogroup&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Python 中<code>set</code>与<code>dict</code>类似，也是一组<code>key</code>的集合，但不存储<code>value</code>。由于<code>key</code>不能重复，所以，在<code>set</code>中，没有重复的<code>key</code>。</p><p>注意，<code>key</code>为不可变类型，即可哈希的值。</p><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">num &#x3D; &#123;&#125;print(type(num))  # &lt;class &#39;dict&#39;&gt;num &#x3D; &#123;1, 2, 3, 4&#125;print(type(num))  # &lt;class &#39;set&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-集合的创建"><a href="#1-集合的创建" class="headerlink" title="1. 集合的创建"></a>1. 集合的创建</h3><ul><li>先创建对象再加入元素。</li><li>在创建空集合的时候只能使用<code>s = set()</code>，因为<code>s = &#123;&#125;</code>创建的是空字典。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">basket &#x3D; set()basket.add(&#39;apple&#39;)basket.add(&#39;banana&#39;)print(basket)  # &#123;&#39;banana&#39;, &#39;apple&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>直接把一堆元素用花括号括起来<code>&#123;元素1, 元素2, ..., 元素n&#125;</code>。</li><li>重复元素在<code>set</code>中会被自动被过滤。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">basket &#x3D; &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;print(basket)  # &#123;&#39;banana&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>使用<code>set(value)</code>工厂函数，把列表或元组转换成集合。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; set(&#39;abracadabra&#39;)print(a)  # &#123;&#39;r&#39;, &#39;b&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;&#125;b &#x3D; set((&quot;Google&quot;, &quot;Lsgogroup&quot;, &quot;Taobao&quot;, &quot;Taobao&quot;))print(b)  # &#123;&#39;Taobao&#39;, &#39;Lsgogroup&#39;, &#39;Google&#39;&#125;c &#x3D; set([&quot;Google&quot;, &quot;Lsgogroup&quot;, &quot;Taobao&quot;, &quot;Google&quot;])print(c)  # &#123;&#39;Taobao&#39;, &#39;Lsgogroup&#39;, &#39;Google&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>【例子】去掉列表中重复的元素</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">lst &#x3D; [0, 1, 2, 3, 4, 5, 5, 3, 1]temp &#x3D; []for item in lst:    if item not in temp:        temp.append(item)print(temp)  # [0, 1, 2, 3, 4, 5]a &#x3D; set(lst)print(list(a))  # [0, 1, 2, 3, 4, 5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果发现集合的两个特点：无序 (unordered) 和唯一 (unique)。</p><p>由于 <code>set</code> 存储的是无序集合，所以我们不可以为集合创建索引或执行切片(slice)操作，也没有键(keys)可用来获取集合中元素的值，但是可以判断一个元素是否在集合中。</p><h3 id="2-访问集合中的值"><a href="#2-访问集合中的值" class="headerlink" title="2. 访问集合中的值"></a>2. 访问集合中的值</h3><ul><li>可以使用<code>len()</code>內建函数得到集合的大小。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])print(len(s))  # 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>可以使用<code>for</code>把集合中的数据一个个读取出来。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])for item in s:    print(item)    # Baidu# Google# Taobao<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以通过<code>in</code>或<code>not in</code>判断一个元素是否在集合中已经存在</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; set([&#39;Google&#39;, &#39;Baidu&#39;, &#39;Taobao&#39;])print(&#39;Taobao&#39; in s)  # Trueprint(&#39;Facebook&#39; not in s)  # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-集合的内置方法"><a href="#3-集合的内置方法" class="headerlink" title="3. 集合的内置方法"></a>3. 集合的内置方法</h3><ul><li><code>set.add(elmnt)</code>用于给集合添加元素，如果添加的元素在集合中已存在，则不执行任何操作。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;fruits.add(&quot;orange&quot;)print(fruits)  # &#123;&#39;orange&#39;, &#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;fruits.add(&quot;apple&quot;)print(fruits)  # &#123;&#39;orange&#39;, &#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>set.update(set)</code>用于修改当前集合，可以添加新的元素或集合到当前集合中，如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;y &#x3D; &#123;&quot;google&quot;, &quot;baidu&quot;, &quot;apple&quot;&#125;x.update(y)print(x)# &#123;&#39;cherry&#39;, &#39;banana&#39;, &#39;apple&#39;, &#39;google&#39;, &#39;baidu&#39;&#125;y.update([&quot;lsgo&quot;, &quot;dreamtech&quot;])print(y)# &#123;&#39;lsgo&#39;, &#39;baidu&#39;, &#39;dreamtech&#39;, &#39;apple&#39;, &#39;google&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>set.remove(item)</code> 用于移除集合中的指定元素。如果元素不存在，则会发生错误。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;fruits.remove(&quot;banana&quot;)print(fruits)  # &#123;&#39;apple&#39;, &#39;cherry&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>set.discard(value)</code> 用于移除指定的集合元素。<code>remove()</code> 方法在移除一个不存在的元素时会发生错误，而 <code>discard()</code> 方法不会。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;fruits.discard(&quot;banana&quot;)print(fruits)  # &#123;&#39;apple&#39;, &#39;cherry&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>set.pop()</code> 用于随机移除一个元素。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fruits &#x3D; &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;&#125;x &#x3D; fruits.pop()print(fruits)  # &#123;&#39;cherry&#39;, &#39;apple&#39;&#125;print(x)  # banana<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于 set 是无序和无重复元素的集合，所以两个或多个 set 可以做数学意义上的集合操作。</p><ul><li><code>set.intersection(set1, set2)</code> 返回两个集合的交集。</li><li><code>set1 &amp; set2</code> 返回两个集合的交集。</li><li><code>set.intersection_update(set1, set2)</code> 交集，在原始的集合上移除不重叠的元素。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; set(&#39;abracadabra&#39;)b &#x3D; set(&#39;alacazam&#39;)print(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;print(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;c &#x3D; a.intersection(b)print(c)  # &#123;&#39;a&#39;, &#39;c&#39;&#125;print(a &amp; b)  # &#123;&#39;c&#39;, &#39;a&#39;&#125;print(a)  # &#123;&#39;a&#39;, &#39;r&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;a.intersection_update(b)print(a)  # &#123;&#39;a&#39;, &#39;c&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>set.union(set1, set2)</code> 返回两个集合的并集。</li><li><code>set1 | set2</code> 返回两个集合的并集。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; set(&#39;abracadabra&#39;)b &#x3D; set(&#39;alacazam&#39;)print(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;print(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;print(a | b)  # &#123;&#39;l&#39;, &#39;d&#39;, &#39;m&#39;, &#39;b&#39;, &#39;a&#39;, &#39;r&#39;, &#39;z&#39;, &#39;c&#39;&#125;c &#x3D; a.union(b)print(c)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;d&#39;, &#39;m&#39;, &#39;r&#39;, &#39;b&#39;, &#39;z&#39;, &#39;l&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>set.difference(set)</code> 返回集合的差集。</li><li><code>set1 - set2</code> 返回集合的差集。</li><li><code>set.difference_update(set)</code> 集合的差集，直接在原来的集合中移除元素，没有返回值。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; set(&#39;abracadabra&#39;)b &#x3D; set(&#39;alacazam&#39;)print(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;print(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;c &#x3D; a.difference(b)print(c)  # &#123;&#39;b&#39;, &#39;d&#39;, &#39;r&#39;&#125;print(a - b)  # &#123;&#39;d&#39;, &#39;b&#39;, &#39;r&#39;&#125;print(a)  # &#123;&#39;r&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;a.difference_update(b)print(a)  # &#123;&#39;d&#39;, &#39;r&#39;, &#39;b&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>set.symmetric_difference(set)</code>返回集合的异或。</li><li><code>set1 ^ set2</code> 返回集合的异或。</li><li><code>set.symmetric_difference_update(set)</code>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; set(&#39;abracadabra&#39;)b &#x3D; set(&#39;alacazam&#39;)print(a)  # &#123;&#39;r&#39;, &#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;&#125;print(b)  # &#123;&#39;c&#39;, &#39;a&#39;, &#39;l&#39;, &#39;m&#39;, &#39;z&#39;&#125;c &#x3D; a.symmetric_difference(b)print(c)  # &#123;&#39;m&#39;, &#39;r&#39;, &#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;d&#39;&#125;print(a ^ b)  # &#123;&#39;m&#39;, &#39;r&#39;, &#39;l&#39;, &#39;b&#39;, &#39;z&#39;, &#39;d&#39;&#125;print(a)  # &#123;&#39;r&#39;, &#39;d&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;a.symmetric_difference_update(b)print(a)  # &#123;&#39;r&#39;, &#39;b&#39;, &#39;m&#39;, &#39;l&#39;, &#39;z&#39;, &#39;d&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>set.issubset(set)</code>判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</li><li><code>set1 &lt;= set2</code> 判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;y &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;z &#x3D; x.issubset(y)print(z)  # Trueprint(x &lt;&#x3D; y)  # Truex &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;y &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;z &#x3D; x.issubset(y)print(z)  # Falseprint(x &lt;&#x3D; y)  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>set.issuperset(set)</code>用于判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。</li><li><code>set1 &gt;= set2</code> 判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;&#125;y &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;z &#x3D; x.issuperset(y)print(z)  # Trueprint(x &gt;&#x3D; y)  # Truex &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;y &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;z &#x3D; x.issuperset(y)print(z)  # Falseprint(x &gt;&#x3D; y)  # False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>set.isdisjoint(set)</code> 用于判断两个集合是不是不相交，如果是返回 True，否则返回 False。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;&#125;y &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;z &#x3D; x.isdisjoint(y)print(z)  # Falsex &#x3D; &#123;&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;m&quot;, &quot;g&quot;&#125;y &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;z &#x3D; x.isdisjoint(y)print(z)  # True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-集合的转换"><a href="#4-集合的转换" class="headerlink" title="4. 集合的转换"></a>4. 集合的转换</h3><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">se &#x3D; set(range(4))li &#x3D; list(se)tu &#x3D; tuple(se)print(se, type(se))  # &#123;0, 1, 2, 3&#125; &lt;class &#39;set&#39;&gt;print(li, type(li))  # [0, 1, 2, 3] &lt;class &#39;list&#39;&gt;print(tu, type(tu))  # (0, 1, 2, 3) &lt;class &#39;tuple&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-不可变集合"><a href="#5-不可变集合" class="headerlink" title="5. 不可变集合"></a>5. 不可变集合</h3><p>Python 提供了不能改变元素的集合的实现版本，即不能增加或删除元素，类型名叫<code>frozenset</code>。需要注意的是<code>frozenset</code>仍然可以进行集合操作，只是不能用带有<code>update</code>的方法。</p><ul><li><code>frozenset([iterable])</code> 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; frozenset(range(10))  # 生成一个新的不可变集合print(a)  # frozenset(&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;)b &#x3D; frozenset(&#39;lsgogroup&#39;)print(b)  # frozenset(&#123;&#39;g&#39;, &#39;s&#39;, &#39;p&#39;, &#39;r&#39;, &#39;u&#39;, &#39;o&#39;, &#39;l&#39;&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>在 Python 中，序列类型包括字符串、列表、元组、集合和字典，这些序列支持一些通用的操作，但比较特殊的是，集合和字典不支持索引、切片、相加和相乘操作。</p><h3 id="1-针对序列的内置函数"><a href="#1-针对序列的内置函数" class="headerlink" title="1. 针对序列的内置函数"></a>1. 针对序列的内置函数</h3><ul><li><code>list(sub)</code> 把一个可迭代对象转换为列表。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; list()print(a)  # []b &#x3D; &#39;I Love LsgoGroup&#39;b &#x3D; list(b)print(b)  # [&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;]c &#x3D; (1, 1, 2, 3, 5, 8)c &#x3D; list(c)print(c)  # [1, 1, 2, 3, 5, 8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>tuple(sub)</code> 把一个可迭代对象转换为元组。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; tuple()print(a)  # ()b &#x3D; &#39;I Love LsgoGroup&#39;b &#x3D; tuple(b)print(b)  # (&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;)c &#x3D; [1, 1, 2, 3, 5, 8]c &#x3D; tuple(c)print(c)  # (1, 1, 2, 3, 5, 8)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>str(obj)</code> 把obj对象转换为字符串</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; 123a &#x3D; str(a)print(a)  # 123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>len(s)</code> 返回对象（字符、列表、元组等）长度或元素个数。<ul><li><code>s</code> – 对象。</li></ul></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; list()print(len(a))  # 0b &#x3D; (&#39;I&#39;, &#39; &#39;, &#39;L&#39;, &#39;o&#39;, &#39;v&#39;, &#39;e&#39;, &#39; &#39;, &#39;L&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;G&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;)print(len(b))  # 16c &#x3D; &#39;I Love LsgoGroup&#39;print(len(c))  # 16<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>max(sub)</code>返回序列或者参数集合中的最大值</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(max(1, 2, 3, 4, 5))  # 5print(max([-8, 99, 3, 7, 83]))  # 99print(max(&#39;IloveLsgoGroup&#39;))  # v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>min(sub)</code>返回序列或参数集合中的最小值</li></ul><p>【例子】</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">print(min(1, 2, 3, 4, 5))  # 1print(min([-8, 99, 3, 7, 83]))  # -8print(min(&#39;IloveLsgoGroup&#39;))  # G<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><code>sum(iterable[, start=0])</code> 返回序列<code>iterable</code>与可选参数<code>start</code>的总和。</li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(sum([1, 3, 5, 7, 9]))  # 25print(sum([1, 3, 5, 7, 9], 10))  # 35print(sum((1, 3, 5, 7, 9)))  # 25print(sum((1, 3, 5, 7, 9), 20))  # 45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>sorted(iterable, key=None, reverse=False) </code> 对所有可迭代的对象进行排序操作。<ul><li><code>iterable</code> – 可迭代对象。</li><li><code>key</code> – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li><code>reverse</code> – 排序规则，<code>reverse = True</code> 降序 ， <code>reverse = False</code> 升序（默认）。</li><li>返回重新排序的列表。</li></ul></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x &#x3D; [-8, 99, 3, 7, 83]print(sorted(x))  # [-8, 3, 7, 83, 99]print(sorted(x, reverse&#x3D;True))  # [99, 83, 7, 3, -8]t &#x3D; (&#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;a&quot;&#125;, &#123;&quot;age&quot;: 25, &quot;name&quot;: &quot;b&quot;&#125;, &#123;&quot;age&quot;: 10, &quot;name&quot;: &quot;c&quot;&#125;)x &#x3D; sorted(t, key&#x3D;lambda a: a[&quot;age&quot;])print(x)# [&#123;&#39;age&#39;: 10, &#39;name&#39;: &#39;c&#39;&#125;, &#123;&#39;age&#39;: 20, &#39;name&#39;: &#39;a&#39;&#125;, &#123;&#39;age&#39;: 25, &#39;name&#39;: &#39;b&#39;&#125;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>reversed(seq)</code> 函数返回一个反转的迭代器。<ul><li><code>seq</code> – 要转换的序列，可以是 tuple, string, list 或 range。</li></ul></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s &#x3D; &#39;lsgogroup&#39;x &#x3D; reversed(s)print(type(x))  # &lt;class &#39;reversed&#39;&gt;print(x)  # &lt;reversed object at 0x000002507E8EC2C8&gt;print(list(x))# [&#39;p&#39;, &#39;u&#39;, &#39;o&#39;, &#39;r&#39;, &#39;g&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39;, &#39;l&#39;]t &#x3D; (&#39;l&#39;, &#39;s&#39;, &#39;g&#39;, &#39;o&#39;, &#39;g&#39;, &#39;r&#39;, &#39;o&#39;, &#39;u&#39;, &#39;p&#39;)print(list(reversed(t)))# [&#39;p&#39;, &#39;u&#39;, &#39;o&#39;, &#39;r&#39;, &#39;g&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39;, &#39;l&#39;]r &#x3D; range(5, 9)print(list(reversed(r)))# [8, 7, 6, 5]x &#x3D; [-8, 99, 3, 7, 83]print(list(reversed(x)))# [83, 7, 3, 99, -8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>enumerate(sequence, [start=0])</code></li></ul><p>【例子】用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">seasons &#x3D; [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;]a &#x3D; list(enumerate(seasons))print(a)  # [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)]b &#x3D; list(enumerate(seasons, 1))print(b)  # [(1, &#39;Spring&#39;), (2, &#39;Summer&#39;), (3, &#39;Fall&#39;), (4, &#39;Winter&#39;)]for i, element in a:    print(&#39;&#123;0&#125;,&#123;1&#125;&#39;.format(i, element))# 0,Spring# 1,Summer# 2,Fall# 3,Winter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>zip(iter1 [,iter2 [...]])</code><ul><li>用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。</li><li>我们可以使用 <code>list()</code> 转换来输出列表。</li><li>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 <code>*</code> 号操作符，可以将元组解压为列表。</li></ul></li></ul><p>【例子】</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; [1, 2, 3]b &#x3D; [4, 5, 6]c &#x3D; [4, 5, 6, 7, 8]zipped &#x3D; zip(a, b)print(zipped)  # &lt;zip object at 0x000000C5D89EDD88&gt;print(list(zipped))  # [(1, 4), (2, 5), (3, 6)]zipped &#x3D; zip(a, c)print(list(zipped))  # [(1, 4), (2, 5), (3, 6)]a1, a2 &#x3D; zip(*zip(a, b))print(list(a1))  # [1, 2, 3]print(list(a2))  # [4, 5, 6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
